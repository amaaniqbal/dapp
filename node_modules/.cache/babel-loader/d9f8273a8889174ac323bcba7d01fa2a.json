{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst cryptoRandom_1 = require(\"./cryptoRandom\");\n\nconst errors_1 = require(\"../errors\");\n\nconst keys_1 = require(\"../keys\");\n\nconst sha2Hash_1 = require(\"./sha2Hash\");\n\nconst hmacSha256_1 = require(\"./hmacSha256\");\n\nconst aesCipher_1 = require(\"./aesCipher\");\n\nconst utils_1 = require(\"../utils\");\n\nconst ecurve = new elliptic_1.ec('secp256k1');\n/**\n* @ignore\n*/\n\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cipher = yield aesCipher_1.createCipher();\n    const result = yield cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n    return result;\n  });\n}\n\nexports.aes256CbcEncrypt = aes256CbcEncrypt;\n/**\n* @ignore\n*/\n\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cipher = yield aesCipher_1.createCipher();\n    const result = yield cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n    return result;\n  });\n}\n/**\n* @ignore\n*/\n\n\nfunction hmacSha256(key, content) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const hmacSha256 = yield hmacSha256_1.createHmacSha256();\n    return hmacSha256.digest(key, content);\n  });\n}\n/**\n* @ignore\n*/\n\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  let res = 0;\n\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n/**\n* @ignore\n*/\n\n\nfunction sharedSecretToKeys(sharedSecret) {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = sha2Hash_1.hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n/**\n * Hex encodes a 32-byte BN.js instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\n\n\nfunction getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString('hex', 64);\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\nexports.getHexFromBN = getHexFromBN;\n/**\n * Returns a big-endian encoded 32-byte BN.js instance.\n * The result Buffer is zero padded and always 32 bytes in length.\n * @ignore\n */\n\nfunction getBufferFromBN(bnInput) {\n  const result = bnInput.toArrayLike(Buffer, 'be', 32);\n\n  if (result.byteLength !== 32) {\n    throw new Error('Generated a 32-byte BN for encryption. Failing.');\n  }\n\n  return result;\n}\n\nexports.getBufferFromBN = getBufferFromBN;\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\n\nfunction getCipherObjectWrapper(opts) {\n  // Placeholder structure of the ciphertext payload, used to determine the \n  // stringified JSON overhead length. \n  const shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  } // Hex encoded 16 byte buffer.\n\n\n  const ivLength = 32; // Hex encoded, compressed EC pubkey of 33 bytes.\n\n  const ephemeralPKLength = 66; // Hex encoded 32 byte hmac-sha256.\n\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\n\nexports.getCipherObjectWrapper = getCipherObjectWrapper;\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\n\nfunction getSignedCipherObjectWrapper(payloadShell) {\n  // Placeholder structure of the signed ciphertext payload, used to determine the \n  // stringified JSON overhead length. \n  const shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  }; // Hex encoded DER signature, up to 72 byte length. \n\n  const signatureLength = 144; // Hex encoded 33 byte public key.\n\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\n\nexports.getSignedCipherObjectWrapper = getSignedCipherObjectWrapper;\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\n\nfunction eciesGetJsonStringLength(opts) {\n  const {\n    payloadShell,\n    payloadValuesLength\n  } = getCipherObjectWrapper(opts); // Calculate the AES output length given the input length. \n\n  const cipherTextLength = utils_1.getAesCbcOutputLength(opts.contentLength); // Get the encoded string length of the cipherText. \n\n  let encodedCipherTextLength;\n\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = utils_1.getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    // Get the signed version of the JSON envelope\n    const {\n      signedPayloadShell,\n      signedPayloadValuesLength\n    } = getSignedCipherObjectWrapper(payloadShell); // Add length of the JSON envelope, ciphertext length, and length of the const values. \n\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\n\nexports.eciesGetJsonStringLength = eciesGetJsonStringLength;\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @private\n * @ignore\n */\n\nfunction encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n    const ephemeralSK = ecurve.genKeyPair();\n    const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n    const sharedSecret = ephemeralSK.derive(ecPK);\n    const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const initializationVector = cryptoRandom_1.randomBytes(16);\n    const cipherText = yield aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n    const macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n    const mac = yield hmacSha256(sharedKeys.hmacKey, macData);\n    let cipherTextString;\n\n    if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n      cipherTextString = cipherText.toString('hex');\n    } else if (cipherTextEncoding === 'base64') {\n      cipherTextString = cipherText.toString('base64');\n    } else {\n      throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n    }\n\n    const result = {\n      iv: initializationVector.toString('hex'),\n      ephemeralPK: ephemeralPK.toString('hex'),\n      cipherText: cipherTextString,\n      mac: mac.toString('hex'),\n      wasString: !!wasString\n    };\n\n    if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n      result.cipherTextEncoding = cipherTextEncoding;\n    }\n\n    return result;\n  });\n}\n\nexports.encryptECIES = encryptECIES;\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @private\n * @ignore\n */\n\nfunction decryptECIES(privateKey, cipherObject) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n    let ephemeralPK = null;\n\n    try {\n      ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n    } catch (error) {\n      throw new errors_1.FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n    }\n\n    const sharedSecret = ecSK.derive(ephemeralPK);\n    const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n    let cipherTextBuffer;\n\n    if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n      cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n    } else if (cipherObject.cipherTextEncoding === 'base64') {\n      cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n    } else {\n      throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n    }\n\n    const macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encodeCompressed()), cipherTextBuffer]);\n    const actualMac = yield hmacSha256(sharedKeys.hmacKey, macData);\n    const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n\n    if (!equalConstTime(expectedMac, actualMac)) {\n      throw new errors_1.FailedDecryptionError('Decryption failed: failure in MAC check');\n    }\n\n    const plainText = yield aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n    if (cipherObject.wasString) {\n      return plainText.toString();\n    } else {\n      return plainText;\n    }\n  });\n}\n\nexports.decryptECIES = decryptECIES;\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\n\nfunction signECDSA(privateKey, content) {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);\n  const signature = ecPrivate.sign(contentHash);\n  const signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey\n  };\n}\n\nexports.signECDSA = signECDSA;\n/**\n* @ignore\n*/\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\n\n\nfunction verifyECDSA(content, publicKey, signature) {\n  const contentBuffer = getBuffer(content);\n  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);\n  return ecPublic.verify(contentHash, signature);\n}\n\nexports.verifyECDSA = verifyECDSA;","map":{"version":3,"sources":["../../src/encryption/ec.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst elliptic_1 = require(\"elliptic\");\nconst cryptoRandom_1 = require(\"./cryptoRandom\");\nconst errors_1 = require(\"../errors\");\nconst keys_1 = require(\"../keys\");\nconst sha2Hash_1 = require(\"./sha2Hash\");\nconst hmacSha256_1 = require(\"./hmacSha256\");\nconst aesCipher_1 = require(\"./aesCipher\");\nconst utils_1 = require(\"../utils\");\nconst ecurve = new elliptic_1.ec('secp256k1');\n/**\n* @ignore\n*/\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const cipher = yield aesCipher_1.createCipher();\n        const result = yield cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n        return result;\n    });\n}\nexports.aes256CbcEncrypt = aes256CbcEncrypt;\n/**\n* @ignore\n*/\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const cipher = yield aesCipher_1.createCipher();\n        const result = yield cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n        return result;\n    });\n}\n/**\n* @ignore\n*/\nfunction hmacSha256(key, content) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const hmacSha256 = yield hmacSha256_1.createHmacSha256();\n        return hmacSha256.digest(key, content);\n    });\n}\n/**\n* @ignore\n*/\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for (let i = 0; i < b1.length; i++) {\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\n/**\n* @ignore\n*/\nfunction sharedSecretToKeys(sharedSecret) {\n    // generate mac and encryption key from shared secret\n    const hashedSecret = sha2Hash_1.hashSha512Sync(sharedSecret);\n    return {\n        encryptionKey: hashedSecret.slice(0, 32),\n        hmacKey: hashedSecret.slice(32)\n    };\n}\n/**\n * Hex encodes a 32-byte BN.js instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\nfunction getHexFromBN(bnInput) {\n    const hexOut = bnInput.toString('hex', 64);\n    if (hexOut.length === 64) {\n        return hexOut;\n    }\n    else if (hexOut.length < 64) {\n        // pad with leading zeros\n        // the padStart function would require node 9\n        const padding = '0'.repeat(64 - hexOut.length);\n        return `${padding}${hexOut}`;\n    }\n    else {\n        throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n    }\n}\nexports.getHexFromBN = getHexFromBN;\n/**\n * Returns a big-endian encoded 32-byte BN.js instance.\n * The result Buffer is zero padded and always 32 bytes in length.\n * @ignore\n */\nfunction getBufferFromBN(bnInput) {\n    const result = bnInput.toArrayLike(Buffer, 'be', 32);\n    if (result.byteLength !== 32) {\n        throw new Error('Generated a 32-byte BN for encryption. Failing.');\n    }\n    return result;\n}\nexports.getBufferFromBN = getBufferFromBN;\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\nfunction getCipherObjectWrapper(opts) {\n    // Placeholder structure of the ciphertext payload, used to determine the \n    // stringified JSON overhead length. \n    const shell = {\n        iv: '',\n        ephemeralPK: '',\n        mac: '',\n        cipherText: '',\n        wasString: !!opts.wasString,\n    };\n    if (opts.cipherTextEncoding === 'base64') {\n        shell.cipherTextEncoding = 'base64';\n    }\n    // Hex encoded 16 byte buffer.\n    const ivLength = 32;\n    // Hex encoded, compressed EC pubkey of 33 bytes.\n    const ephemeralPKLength = 66;\n    // Hex encoded 32 byte hmac-sha256.\n    const macLength = 64;\n    return {\n        payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n        payloadShell: JSON.stringify(shell)\n    };\n}\nexports.getCipherObjectWrapper = getCipherObjectWrapper;\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\nfunction getSignedCipherObjectWrapper(payloadShell) {\n    // Placeholder structure of the signed ciphertext payload, used to determine the \n    // stringified JSON overhead length. \n    const shell = {\n        signature: '',\n        publicKey: '',\n        cipherText: payloadShell\n    };\n    // Hex encoded DER signature, up to 72 byte length. \n    const signatureLength = 144;\n    // Hex encoded 33 byte public key.\n    const publicKeyLength = 66;\n    return {\n        signedPayloadValuesLength: signatureLength + publicKeyLength,\n        signedPayloadShell: JSON.stringify(shell)\n    };\n}\nexports.getSignedCipherObjectWrapper = getSignedCipherObjectWrapper;\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\nfunction eciesGetJsonStringLength(opts) {\n    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n    // Calculate the AES output length given the input length. \n    const cipherTextLength = utils_1.getAesCbcOutputLength(opts.contentLength);\n    // Get the encoded string length of the cipherText. \n    let encodedCipherTextLength;\n    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n        encodedCipherTextLength = (cipherTextLength * 2);\n    }\n    else if (opts.cipherTextEncoding === 'base64') {\n        encodedCipherTextLength = utils_1.getBase64OutputLength(cipherTextLength);\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n    }\n    if (!opts.sign) {\n        // Add the length of the JSON envelope, ciphertext length, and length of const values.\n        return payloadShell.length\n            + payloadValuesLength\n            + encodedCipherTextLength;\n    }\n    else {\n        // Get the signed version of the JSON envelope\n        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);\n        // Add length of the JSON envelope, ciphertext length, and length of the const values. \n        return signedPayloadShell.length\n            + signedPayloadValuesLength\n            + payloadValuesLength\n            + encodedCipherTextLength;\n    }\n}\nexports.eciesGetJsonStringLength = eciesGetJsonStringLength;\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @private\n * @ignore\n */\nfunction encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n        const ephemeralSK = ecurve.genKeyPair();\n        const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n        const sharedSecret = ephemeralSK.derive(ecPK);\n        const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n        const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n        const initializationVector = cryptoRandom_1.randomBytes(16);\n        const cipherText = yield aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n        const macData = Buffer.concat([initializationVector,\n            ephemeralPK,\n            cipherText]);\n        const mac = yield hmacSha256(sharedKeys.hmacKey, macData);\n        let cipherTextString;\n        if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n            cipherTextString = cipherText.toString('hex');\n        }\n        else if (cipherTextEncoding === 'base64') {\n            cipherTextString = cipherText.toString('base64');\n        }\n        else {\n            throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n        }\n        const result = {\n            iv: initializationVector.toString('hex'),\n            ephemeralPK: ephemeralPK.toString('hex'),\n            cipherText: cipherTextString,\n            mac: mac.toString('hex'),\n            wasString: !!wasString\n        };\n        if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n            result.cipherTextEncoding = cipherTextEncoding;\n        }\n        return result;\n    });\n}\nexports.encryptECIES = encryptECIES;\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @private\n * @ignore\n */\nfunction decryptECIES(privateKey, cipherObject) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n        let ephemeralPK = null;\n        try {\n            ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n        }\n        catch (error) {\n            throw new errors_1.FailedDecryptionError('Unable to get public key from cipher object. '\n                + 'You might be trying to decrypt an unencrypted object.');\n        }\n        const sharedSecret = ecSK.derive(ephemeralPK);\n        const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n        const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n        const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n        let cipherTextBuffer;\n        if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n            cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n        }\n        else if (cipherObject.cipherTextEncoding === 'base64') {\n            cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n        }\n        else {\n            throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n        }\n        const macData = Buffer.concat([ivBuffer,\n            Buffer.from(ephemeralPK.encodeCompressed()),\n            cipherTextBuffer]);\n        const actualMac = yield hmacSha256(sharedKeys.hmacKey, macData);\n        const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n        if (!equalConstTime(expectedMac, actualMac)) {\n            throw new errors_1.FailedDecryptionError('Decryption failed: failure in MAC check');\n        }\n        const plainText = yield aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n        if (cipherObject.wasString) {\n            return plainText.toString();\n        }\n        else {\n            return plainText;\n        }\n    });\n}\nexports.decryptECIES = decryptECIES;\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\nfunction signECDSA(privateKey, content) {\n    const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n    const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n    const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n    const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);\n    const signature = ecPrivate.sign(contentHash);\n    const signatureString = signature.toDER('hex');\n    return {\n        signature: signatureString,\n        publicKey\n    };\n}\nexports.signECDSA = signECDSA;\n/**\n* @ignore\n*/\nfunction getBuffer(content) {\n    if (content instanceof Buffer)\n        return content;\n    else if (content instanceof ArrayBuffer)\n        return Buffer.from(content);\n    else\n        return Buffer.from(content);\n}\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\nfunction verifyECDSA(content, publicKey, signature) {\n    const contentBuffer = getBuffer(content);\n    const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n    const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);\n    return ecPublic.verify(contentHash, signature);\n}\nexports.verifyECDSA = verifyECDSA;\n//# sourceMappingURL=ec.js.map"]},"metadata":{},"sourceType":"script"}