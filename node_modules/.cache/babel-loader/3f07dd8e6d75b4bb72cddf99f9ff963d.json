{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst cryptoUtils_1 = require(\"./cryptoUtils\");\n\nclass NodeCryptoPbkdf2 {\n  constructor(nodePbkdf2) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  derive(password, salt, iterations, keyLength, digest) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (digest !== 'sha512' && digest !== 'sha256') {\n        throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n      }\n\n      return new Promise((resolve, reject) => {\n        this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n          if (error) {\n            reject(error);\n          }\n\n          resolve(result);\n        });\n      });\n    });\n  }\n\n}\n\nexports.NodeCryptoPbkdf2 = NodeCryptoPbkdf2;\n\nclass WebCryptoPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  derive(password, salt, iterations, keyLength, digest) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      let algo;\n\n      if (digest === 'sha256') {\n        algo = 'SHA-256';\n      } else if (digest === 'sha512') {\n        algo = 'SHA-512';\n      } else {\n        throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n      }\n\n      let result;\n      const passwordBytes = Buffer.from(password, 'utf8');\n\n      try {\n        const key = yield this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);\n        result = yield this.subtleCrypto.deriveBits({\n          name: 'PBKDF2',\n          salt,\n          iterations,\n          hash: {\n            name: algo\n          }\n        }, key, keyLength * 8);\n      } catch (error) {\n        // Browser appears to support WebCrypto but missing pbkdf2 support.\n        const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n        return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n      }\n\n      return Buffer.from(result);\n    });\n  }\n\n}\n\nexports.WebCryptoPbkdf2 = WebCryptoPbkdf2;\n\nclass WebCryptoPartialPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  derive(password, salt, iterations, keyLength, digest) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (digest !== 'sha512' && digest !== 'sha256') {\n        throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n      }\n\n      const key = Buffer.from(password, 'utf8');\n      const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n      const algoOpts = {\n        name: 'HMAC',\n        hash: algo\n      };\n\n      const hmacDigest = (key, data) => this.subtleCrypto.importKey('raw', key, algoOpts, true, ['sign']).then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data)).then(result => new Uint8Array(result));\n\n      const DK = new Uint8Array(keyLength);\n      const saltLength = salt.length;\n      const block1 = new Uint8Array(saltLength + 4);\n      block1.set(salt);\n      let destPos = 0;\n      const hLen = digest === 'sha512' ? 64 : 32;\n      const l = Math.ceil(keyLength / hLen);\n\n      function writeUInt32BE(data, value, offset) {\n        value = +value;\n        offset >>>= 0;\n        data[offset] = value >>> 24;\n        data[offset + 1] = value >>> 16;\n        data[offset + 2] = value >>> 8;\n        data[offset + 3] = value & 0xff;\n        return offset + 4;\n      }\n\n      for (let i = 1; i <= l; i++) {\n        writeUInt32BE(block1, i, saltLength); // eslint-disable-next-line no-await-in-loop\n\n        const T = yield hmacDigest(key, block1);\n        let U = T;\n\n        for (let j = 1; j < iterations; j++) {\n          // eslint-disable-next-line no-await-in-loop\n          U = yield hmacDigest(key, U);\n\n          for (let k = 0; k < hLen; k++) {\n            T[k] ^= U[k];\n          }\n        }\n\n        DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n        destPos += hLen;\n      }\n\n      return Buffer.from(DK.buffer);\n    });\n  }\n\n}\n\nexports.WebCryptoPartialPbkdf2 = WebCryptoPartialPbkdf2;\n\nfunction createPbkdf2() {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cryptoLib = yield cryptoUtils_1.getCryptoLib();\n\n    if (cryptoLib.name === 'subtleCrypto') {\n      return new WebCryptoPbkdf2(cryptoLib.lib);\n    } else {\n      return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n    }\n  });\n}\n\nexports.createPbkdf2 = createPbkdf2;","map":{"version":3,"sources":["../../src/encryption/pbkdf2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst cryptoUtils_1 = require(\"./cryptoUtils\");\nclass NodeCryptoPbkdf2 {\n    constructor(nodePbkdf2) {\n        this.nodePbkdf2 = nodePbkdf2;\n    }\n    derive(password, salt, iterations, keyLength, digest) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (digest !== 'sha512' && digest !== 'sha256') {\n                throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n            }\n            return new Promise((resolve, reject) => {\n                this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n                    if (error) {\n                        reject(error);\n                    }\n                    resolve(result);\n                });\n            });\n        });\n    }\n}\nexports.NodeCryptoPbkdf2 = NodeCryptoPbkdf2;\nclass WebCryptoPbkdf2 {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    derive(password, salt, iterations, keyLength, digest) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            let algo;\n            if (digest === 'sha256') {\n                algo = 'SHA-256';\n            }\n            else if (digest === 'sha512') {\n                algo = 'SHA-512';\n            }\n            else {\n                throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n            }\n            let result;\n            const passwordBytes = Buffer.from(password, 'utf8');\n            try {\n                const key = yield this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);\n                result = yield this.subtleCrypto.deriveBits({\n                    name: 'PBKDF2', salt, iterations, hash: { name: algo }\n                }, key, keyLength * 8);\n            }\n            catch (error) {\n                // Browser appears to support WebCrypto but missing pbkdf2 support.\n                const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n                return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n            }\n            return Buffer.from(result);\n        });\n    }\n}\nexports.WebCryptoPbkdf2 = WebCryptoPbkdf2;\nclass WebCryptoPartialPbkdf2 {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    derive(password, salt, iterations, keyLength, digest) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (digest !== 'sha512' && digest !== 'sha256') {\n                throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n            }\n            const key = Buffer.from(password, 'utf8');\n            const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n            const algoOpts = { name: 'HMAC', hash: algo };\n            const hmacDigest = (key, data) => this.subtleCrypto\n                .importKey('raw', key, algoOpts, true, ['sign'])\n                .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))\n                .then(result => new Uint8Array(result));\n            const DK = new Uint8Array(keyLength);\n            const saltLength = salt.length;\n            const block1 = new Uint8Array(saltLength + 4);\n            block1.set(salt);\n            let destPos = 0;\n            const hLen = digest === 'sha512' ? 64 : 32;\n            const l = Math.ceil(keyLength / hLen);\n            function writeUInt32BE(data, value, offset) {\n                value = +value;\n                offset >>>= 0;\n                data[offset] = (value >>> 24);\n                data[offset + 1] = (value >>> 16);\n                data[offset + 2] = (value >>> 8);\n                data[offset + 3] = (value & 0xff);\n                return offset + 4;\n            }\n            for (let i = 1; i <= l; i++) {\n                writeUInt32BE(block1, i, saltLength);\n                // eslint-disable-next-line no-await-in-loop\n                const T = yield hmacDigest(key, block1);\n                let U = T;\n                for (let j = 1; j < iterations; j++) {\n                    // eslint-disable-next-line no-await-in-loop\n                    U = yield hmacDigest(key, U);\n                    for (let k = 0; k < hLen; k++) {\n                        T[k] ^= U[k];\n                    }\n                }\n                DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n                destPos += hLen;\n            }\n            return Buffer.from(DK.buffer);\n        });\n    }\n}\nexports.WebCryptoPartialPbkdf2 = WebCryptoPartialPbkdf2;\nfunction createPbkdf2() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const cryptoLib = yield cryptoUtils_1.getCryptoLib();\n        if (cryptoLib.name === 'subtleCrypto') {\n            return new WebCryptoPbkdf2(cryptoLib.lib);\n        }\n        else {\n            return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n        }\n    });\n}\nexports.createPbkdf2 = createPbkdf2;\n//# sourceMappingURL=pbkdf2.js.map"]},"metadata":{},"sourceType":"script"}