{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst bip39_1 = require(\"bip39\");\n\nconst cryptoRandom_1 = require(\"./cryptoRandom\");\n\nconst sha2Hash_1 = require(\"./sha2Hash\");\n\nconst hmacSha256_1 = require(\"./hmacSha256\");\n\nconst aesCipher_1 = require(\"./aesCipher\");\n\nconst pbkdf2_1 = require(\"./pbkdf2\");\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\n\n\nfunction encryptMnemonic(phrase, password, opts) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    // hex encoded mnemonic string\n    let mnemonicEntropy;\n\n    try {\n      // must be bip39 mnemonic\n      mnemonicEntropy = bip39_1.mnemonicToEntropy(phrase);\n    } catch (error) {\n      console.error('Invalid mnemonic phrase provided');\n      console.error(error);\n      throw new Error('Not a valid bip39 mnemonic');\n    } // normalize plaintext to fixed length byte string\n\n\n    const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex'); // AES-128-CBC with SHA256 HMAC\n\n    const pbkdf2 = yield pbkdf2_1.createPbkdf2();\n    let salt;\n\n    if (opts && opts.getRandomBytes) {\n      salt = opts.getRandomBytes(16);\n    } else {\n      salt = cryptoRandom_1.randomBytes(16);\n    }\n\n    const keysAndIV = yield pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const cipher = yield aesCipher_1.createCipher();\n    const cipherText = yield cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n    const hmacPayload = Buffer.concat([salt, cipherText]);\n    const hmacSha256 = yield hmacSha256_1.createHmacSha256();\n    const hmacDigest = yield hmacSha256.digest(macKey, hmacPayload);\n    const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n    return payload;\n  });\n}\n\nexports.encryptMnemonic = encryptMnemonic; // Used to distinguish bad password during decrypt vs invalid format\n\nclass PasswordError extends Error {}\n/**\n* @ignore\n*/\n\n\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const salt = dataBuffer.slice(0, 16);\n    const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n\n    const cipherText = dataBuffer.slice(48);\n    const hmacPayload = Buffer.concat([salt, cipherText]);\n    const pbkdf2 = yield pbkdf2_1.createPbkdf2();\n    const keysAndIV = yield pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const decipher = yield aesCipher_1.createCipher();\n    const decryptedResult = yield decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n    const hmacSha256 = yield hmacSha256_1.createHmacSha256();\n    const hmacDigest = yield hmacSha256.digest(macKey, hmacPayload); // hash both hmacSig and hmacDigest so string comparison time\n    // is uncorrelated to the ciphertext\n\n    const sha2Hash = yield sha2Hash_1.createSha2Hash();\n    const hmacSigHash = yield sha2Hash.digest(hmacSig);\n    const hmacDigestHash = yield sha2Hash.digest(hmacDigest);\n\n    if (!hmacSigHash.equals(hmacDigestHash)) {\n      // not authentic\n      throw new PasswordError('Wrong password (HMAC mismatch)');\n    }\n\n    let mnemonic;\n\n    try {\n      mnemonic = bip39_1.entropyToMnemonic(decryptedResult);\n    } catch (error) {\n      console.error('Error thrown by `entropyToMnemonic`');\n      console.error(error);\n      throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n\n    if (!bip39_1.validateMnemonic(mnemonic)) {\n      throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n\n    return mnemonic;\n  });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\n\n\nfunction decryptLegacy(dataBuffer, password, triplesecDecrypt) {\n  return new Promise((resolve, reject) => {\n    if (!triplesecDecrypt) {\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\n    }\n\n    triplesecDecrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, (err, plaintextBuffer) => {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n/**\n * Decrypt an encrypted mnemonic phrase with a password.\n * Legacy triplesec encrypted payloads are also supported.\n * @param data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param password - Password for data\n * @return the raw mnemonic phrase\n * @private\n * @ignore\n */\n\n\nfunction decryptMnemonic(data, password, triplesecDecrypt) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n\n    try {\n      return yield decryptMnemonicBuffer(dataBuffer, password);\n    } catch (err) {\n      // If it was a password error, don't even bother with legacy\n      if (err instanceof PasswordError) {\n        throw err;\n      }\n\n      const data = yield decryptLegacy(dataBuffer, password, triplesecDecrypt);\n      return data.toString();\n    }\n  });\n}\n\nexports.decryptMnemonic = decryptMnemonic;","map":{"version":3,"sources":["../../src/encryption/wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst bip39_1 = require(\"bip39\");\nconst cryptoRandom_1 = require(\"./cryptoRandom\");\nconst sha2Hash_1 = require(\"./sha2Hash\");\nconst hmacSha256_1 = require(\"./hmacSha256\");\nconst aesCipher_1 = require(\"./aesCipher\");\nconst pbkdf2_1 = require(\"./pbkdf2\");\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\nfunction encryptMnemonic(phrase, password, opts) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        // hex encoded mnemonic string\n        let mnemonicEntropy;\n        try {\n            // must be bip39 mnemonic\n            mnemonicEntropy = bip39_1.mnemonicToEntropy(phrase);\n        }\n        catch (error) {\n            console.error('Invalid mnemonic phrase provided');\n            console.error(error);\n            throw new Error('Not a valid bip39 mnemonic');\n        }\n        // normalize plaintext to fixed length byte string\n        const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');\n        // AES-128-CBC with SHA256 HMAC\n        const pbkdf2 = yield pbkdf2_1.createPbkdf2();\n        let salt;\n        if (opts && opts.getRandomBytes) {\n            salt = opts.getRandomBytes(16);\n        }\n        else {\n            salt = cryptoRandom_1.randomBytes(16);\n        }\n        const keysAndIV = yield pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n        const encKey = keysAndIV.slice(0, 16);\n        const macKey = keysAndIV.slice(16, 32);\n        const iv = keysAndIV.slice(32, 48);\n        const cipher = yield aesCipher_1.createCipher();\n        const cipherText = yield cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n        const hmacPayload = Buffer.concat([salt, cipherText]);\n        const hmacSha256 = yield hmacSha256_1.createHmacSha256();\n        const hmacDigest = yield hmacSha256.digest(macKey, hmacPayload);\n        const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n        return payload;\n    });\n}\nexports.encryptMnemonic = encryptMnemonic;\n// Used to distinguish bad password during decrypt vs invalid format\nclass PasswordError extends Error {\n}\n/**\n* @ignore\n*/\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const salt = dataBuffer.slice(0, 16);\n        const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n        const cipherText = dataBuffer.slice(48);\n        const hmacPayload = Buffer.concat([salt, cipherText]);\n        const pbkdf2 = yield pbkdf2_1.createPbkdf2();\n        const keysAndIV = yield pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n        const encKey = keysAndIV.slice(0, 16);\n        const macKey = keysAndIV.slice(16, 32);\n        const iv = keysAndIV.slice(32, 48);\n        const decipher = yield aesCipher_1.createCipher();\n        const decryptedResult = yield decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n        const hmacSha256 = yield hmacSha256_1.createHmacSha256();\n        const hmacDigest = yield hmacSha256.digest(macKey, hmacPayload);\n        // hash both hmacSig and hmacDigest so string comparison time\n        // is uncorrelated to the ciphertext\n        const sha2Hash = yield sha2Hash_1.createSha2Hash();\n        const hmacSigHash = yield sha2Hash.digest(hmacSig);\n        const hmacDigestHash = yield sha2Hash.digest(hmacDigest);\n        if (!hmacSigHash.equals(hmacDigestHash)) {\n            // not authentic\n            throw new PasswordError('Wrong password (HMAC mismatch)');\n        }\n        let mnemonic;\n        try {\n            mnemonic = bip39_1.entropyToMnemonic(decryptedResult);\n        }\n        catch (error) {\n            console.error('Error thrown by `entropyToMnemonic`');\n            console.error(error);\n            throw new PasswordError('Wrong password (invalid plaintext)');\n        }\n        if (!bip39_1.validateMnemonic(mnemonic)) {\n            throw new PasswordError('Wrong password (invalid plaintext)');\n        }\n        return mnemonic;\n    });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\nfunction decryptLegacy(dataBuffer, password, triplesecDecrypt) {\n    return new Promise((resolve, reject) => {\n        if (!triplesecDecrypt) {\n            reject(new Error('The `triplesec.decrypt` function must be provided'));\n        }\n        triplesecDecrypt({\n            key: Buffer.from(password),\n            data: dataBuffer\n        }, (err, plaintextBuffer) => {\n            if (!err) {\n                resolve(plaintextBuffer);\n            }\n            else {\n                reject(err);\n            }\n        });\n    });\n}\n/**\n * Decrypt an encrypted mnemonic phrase with a password.\n * Legacy triplesec encrypted payloads are also supported.\n * @param data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param password - Password for data\n * @return the raw mnemonic phrase\n * @private\n * @ignore\n */\nfunction decryptMnemonic(data, password, triplesecDecrypt) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n        try {\n            return yield decryptMnemonicBuffer(dataBuffer, password);\n        }\n        catch (err) {\n            // If it was a password error, don't even bother with legacy\n            if (err instanceof PasswordError) {\n                throw err;\n            }\n            const data = yield decryptLegacy(dataBuffer, password, triplesecDecrypt);\n            return data.toString();\n        }\n    });\n}\nexports.decryptMnemonic = decryptMnemonic;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}