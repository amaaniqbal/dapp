{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n\nconst bip39 = require(\"bip39\");\n\nconst triplesec = require(\"triplesec\");\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\n\n\nfunction encryptMnemonic(phrase, password) {\n  return Promise.resolve().then(() => {\n    // must be bip39 mnemonic\n    if (!bip39.validateMnemonic(phrase)) {\n      throw new Error('Not a valid bip39 nmemonic');\n    } // normalize plaintext to fixed length byte string\n\n\n    const plaintextNormalized = Buffer.from(bip39.mnemonicToEntropy(phrase), 'hex'); // AES-128-CBC with SHA256 HMAC\n\n    const salt = crypto.randomBytes(16);\n    const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const cipher = crypto.createCipheriv('aes-128-cbc', encKey, iv);\n    let cipherText = cipher.update(plaintextNormalized).toString('hex');\n    cipherText += cipher.final().toString('hex');\n    const hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')]);\n    const hmac = crypto.createHmac('sha256', macKey);\n    hmac.write(hmacPayload);\n    const hmacDigest = hmac.digest();\n    const payload = Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')]);\n    return payload;\n  });\n}\n\nexports.encryptMnemonic = encryptMnemonic; // Used to distinguish bad password during decrypt vs invalid format\n\nclass PasswordError extends Error {}\n/**\n* @ignore\n*/\n\n\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n  return Promise.resolve().then(() => {\n    const salt = dataBuffer.slice(0, 16);\n    const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n\n    const cipherText = dataBuffer.slice(48);\n    const hmacPayload = Buffer.concat([salt, cipherText]);\n    const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const decipher = crypto.createDecipheriv('aes-128-cbc', encKey, iv);\n    let plaintext = decipher.update(cipherText).toString('hex');\n    plaintext += decipher.final().toString('hex');\n    const hmac = crypto.createHmac('sha256', macKey);\n    hmac.write(hmacPayload);\n    const hmacDigest = hmac.digest(); // hash both hmacSig and hmacDigest so string comparison time\n    // is uncorrelated to the ciphertext\n\n    const hmacSigHash = crypto.createHash('sha256').update(hmacSig).digest().toString('hex');\n    const hmacDigestHash = crypto.createHash('sha256').update(hmacDigest).digest().toString('hex');\n\n    if (hmacSigHash !== hmacDigestHash) {\n      // not authentic\n      throw new PasswordError('Wrong password (HMAC mismatch)');\n    }\n\n    const mnemonic = bip39.entropyToMnemonic(plaintext);\n\n    if (!bip39.validateMnemonic(mnemonic)) {\n      throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n\n    return mnemonic;\n  });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\n\n\nfunction decryptLegacy(dataBuffer, password) {\n  return new Promise((resolve, reject) => {\n    triplesec.decrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, (err, plaintextBuffer) => {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n/**\n * Encrypt a raw mnemonic phrase with a password\n * @param {string | Buffer} data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param {string} password - Password for data\n * @return {Promise<string>} the raw mnemonic phrase\n * @private\n * @ignore\n */\n\n\nfunction decryptMnemonic(data, password) {\n  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n  return decryptMnemonicBuffer(dataBuffer, password).catch(err => {\n    // If it was a password error, don't even bother with legacy\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n\n    return decryptLegacy(dataBuffer, password).then(data => data.toString());\n  });\n}\n\nexports.decryptMnemonic = decryptMnemonic;","map":{"version":3,"sources":["../../src/encryption/wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"crypto\");\nconst bip39 = require(\"bip39\");\nconst triplesec = require(\"triplesec\");\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\nfunction encryptMnemonic(phrase, password) {\n    return Promise.resolve().then(() => {\n        // must be bip39 mnemonic\n        if (!bip39.validateMnemonic(phrase)) {\n            throw new Error('Not a valid bip39 nmemonic');\n        }\n        // normalize plaintext to fixed length byte string\n        const plaintextNormalized = Buffer.from(bip39.mnemonicToEntropy(phrase), 'hex');\n        // AES-128-CBC with SHA256 HMAC\n        const salt = crypto.randomBytes(16);\n        const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n        const encKey = keysAndIV.slice(0, 16);\n        const macKey = keysAndIV.slice(16, 32);\n        const iv = keysAndIV.slice(32, 48);\n        const cipher = crypto.createCipheriv('aes-128-cbc', encKey, iv);\n        let cipherText = cipher.update(plaintextNormalized).toString('hex');\n        cipherText += cipher.final().toString('hex');\n        const hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')]);\n        const hmac = crypto.createHmac('sha256', macKey);\n        hmac.write(hmacPayload);\n        const hmacDigest = hmac.digest();\n        const payload = Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')]);\n        return payload;\n    });\n}\nexports.encryptMnemonic = encryptMnemonic;\n// Used to distinguish bad password during decrypt vs invalid format\nclass PasswordError extends Error {\n}\n/**\n* @ignore\n*/\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n    return Promise.resolve().then(() => {\n        const salt = dataBuffer.slice(0, 16);\n        const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n        const cipherText = dataBuffer.slice(48);\n        const hmacPayload = Buffer.concat([salt, cipherText]);\n        const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n        const encKey = keysAndIV.slice(0, 16);\n        const macKey = keysAndIV.slice(16, 32);\n        const iv = keysAndIV.slice(32, 48);\n        const decipher = crypto.createDecipheriv('aes-128-cbc', encKey, iv);\n        let plaintext = decipher.update(cipherText).toString('hex');\n        plaintext += decipher.final().toString('hex');\n        const hmac = crypto.createHmac('sha256', macKey);\n        hmac.write(hmacPayload);\n        const hmacDigest = hmac.digest();\n        // hash both hmacSig and hmacDigest so string comparison time\n        // is uncorrelated to the ciphertext\n        const hmacSigHash = crypto.createHash('sha256')\n            .update(hmacSig)\n            .digest()\n            .toString('hex');\n        const hmacDigestHash = crypto.createHash('sha256')\n            .update(hmacDigest)\n            .digest()\n            .toString('hex');\n        if (hmacSigHash !== hmacDigestHash) {\n            // not authentic\n            throw new PasswordError('Wrong password (HMAC mismatch)');\n        }\n        const mnemonic = bip39.entropyToMnemonic(plaintext);\n        if (!bip39.validateMnemonic(mnemonic)) {\n            throw new PasswordError('Wrong password (invalid plaintext)');\n        }\n        return mnemonic;\n    });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\nfunction decryptLegacy(dataBuffer, password) {\n    return new Promise((resolve, reject) => {\n        triplesec.decrypt({\n            key: Buffer.from(password),\n            data: dataBuffer\n        }, (err, plaintextBuffer) => {\n            if (!err) {\n                resolve(plaintextBuffer);\n            }\n            else {\n                reject(err);\n            }\n        });\n    });\n}\n/**\n * Encrypt a raw mnemonic phrase with a password\n * @param {string | Buffer} data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param {string} password - Password for data\n * @return {Promise<string>} the raw mnemonic phrase\n * @private\n * @ignore\n */\nfunction decryptMnemonic(data, password) {\n    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n    return decryptMnemonicBuffer(dataBuffer, password).catch((err) => {\n        // If it was a password error, don't even bother with legacy\n        if (err instanceof PasswordError) {\n            throw err;\n        }\n        return decryptLegacy(dataBuffer, password).then(data => data.toString());\n    });\n}\nexports.decryptMnemonic = decryptMnemonic;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}