{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\n\nconst errors_1 = require(\"../errors\");\n\nclass SECP256K1Client {\n  constructor() {}\n\n  static loadPrivateKey(rawPrivateKey) {\n    if (rawPrivateKey.length === 66) {\n      rawPrivateKey = rawPrivateKey.slice(0, 64);\n    }\n\n    return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n  }\n\n  static loadPublicKey(rawPublicKey) {\n    return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n  }\n\n  static derivePublicKey(privateKey, compressed = true) {\n    if (typeof privateKey !== 'string') {\n      throw Error('private key must be a string');\n    }\n\n    if (!/^[0-9A-F]+$/i.test(privateKey)) {\n      throw Error('private key must be a hex string');\n    }\n\n    if (privateKey.length == 66) {\n      privateKey = privateKey.slice(0, 64);\n    } else if (privateKey.length <= 64) {// do nothing\n    } else {\n      throw Error('private key must be 66 characters or less');\n    }\n\n    const keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n    return keypair.getPublic(compressed, 'hex');\n  }\n\n  static signHash(signingInputHash, rawPrivateKey, format = 'jose') {\n    // make sure the required parameters are provided\n    if (!(signingInputHash && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n    } // prepare the private key\n\n\n    const privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey); // calculate the signature\n\n    const signatureObject = privateKeyObject.sign(signingInputHash);\n    const derSignature = Buffer.from(signatureObject.toDER());\n\n    if (format === 'der') {\n      return derSignature.toString('hex');\n    } else if (format === 'jose') {\n      // return the JOSE-formatted signature\n      return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n    } else {\n      throw Error('Invalid signature format');\n    }\n  }\n\n  static loadSignature(joseSignature) {\n    // create and return the DER-formatted signature buffer\n    return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n  }\n\n  static verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n    // make sure the required parameters are provided\n    if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n    } // prepare the public key\n\n\n    const publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey); // verify the token\n\n    return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n  }\n\n}\n\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';","map":{"version":3,"sources":["cryptoClients/secp256k1.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\nconst ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\nconst errors_1 = require(\"../errors\");\nclass SECP256K1Client {\n    constructor() {\n    }\n    static loadPrivateKey(rawPrivateKey) {\n        if (rawPrivateKey.length === 66) {\n            rawPrivateKey = rawPrivateKey.slice(0, 64);\n        }\n        return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n    }\n    static loadPublicKey(rawPublicKey) {\n        return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n    }\n    static derivePublicKey(privateKey, compressed = true) {\n        if (typeof privateKey !== 'string') {\n            throw Error('private key must be a string');\n        }\n        if (!(/^[0-9A-F]+$/i.test(privateKey))) {\n            throw Error('private key must be a hex string');\n        }\n        if (privateKey.length == 66) {\n            privateKey = privateKey.slice(0, 64);\n        }\n        else if (privateKey.length <= 64) {\n            // do nothing\n        }\n        else {\n            throw Error('private key must be 66 characters or less');\n        }\n        const keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n        return keypair.getPublic(compressed, 'hex');\n    }\n    static signHash(signingInputHash, rawPrivateKey, format = 'jose') {\n        // make sure the required parameters are provided\n        if (!(signingInputHash && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n        }\n        // prepare the private key\n        const privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey);\n        // calculate the signature\n        const signatureObject = privateKeyObject.sign(signingInputHash);\n        const derSignature = Buffer.from(signatureObject.toDER());\n        if (format === 'der') {\n            return derSignature.toString('hex');\n        }\n        else if (format === 'jose') {\n            // return the JOSE-formatted signature\n            return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n        }\n        else {\n            throw Error('Invalid signature format');\n        }\n    }\n    static loadSignature(joseSignature) {\n        // create and return the DER-formatted signature buffer\n        return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n    }\n    static verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n        // make sure the required parameters are provided\n        if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n        }\n        // prepare the public key\n        const publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey);\n        // verify the token\n        return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n    }\n}\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';\n//# sourceMappingURL=secp256k1.js.map"]},"metadata":{},"sourceType":"script"}