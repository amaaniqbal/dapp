{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n/**\n * Create an authentication token to be sent to the Core API server\n * in order to generate a Core session JWT.\n *\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\n * @param {Array} appMethods  The list of API methods this application will need.\n * @param {String} appPrivateKey  The application-specific private key\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\n * @param {String} thisDevice Identifier of the current device\n *\n * @return {String} a JWT signed by the app's private key\n * @deprecated\n * @private\n * @ignore\n */\n\n\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainID = null, thisDevice = null) {\n  if (thisDevice === null) {\n    thisDevice = '.default';\n  }\n\n  const appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);\n  const appPublicKeys = [{\n    public_key: appPublicKey,\n    device_id: thisDevice\n  }];\n  const authBody = {\n    version: 1,\n    blockchain_id: blockchainID,\n    app_private_key: appPrivateKey,\n    app_domain: appDomain,\n    methods: appMethods,\n    app_public_keys: appPublicKeys,\n    device_id: thisDevice\n  }; // make token\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);\n  const token = tokenSigner.sign(authBody);\n  return token;\n}\n\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\n/**\n * Send Core a request for a session token.\n *\n * @param {String} coreHost host name of the core node\n * @param {Number} corePort port number of the core node\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\n * @param {String} apiPassword the API password for Core\n *\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\n * that authorizes the bearer to carry out the requested operations and rejects\n * with an error message otherwise\n * @deprecated\n * @private\n * @ignore\n */\n\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n  return Promise.resolve().then(() => {\n    if (!apiPassword) {\n      throw new Error('Missing API password');\n    }\n  }).then(() => {\n    const options = {\n      headers: {\n        Authorization: `bearer ${apiPassword}`\n      }\n    };\n    const url = `http://${coreHost}:${corePort}/v1/auth?authRequest=${coreAuthRequest}`;\n    return fetchUtil_1.fetchPrivate(url, options);\n  }).then(response => {\n    if (!response.ok) {\n      throw new Error('HTTP status not OK');\n    }\n\n    return response.text();\n  }).then(responseText => {\n    const responseJson = JSON.parse(responseText);\n    const token = responseJson.token;\n\n    if (!token) {\n      throw new Error('Failed to get Core session token');\n    }\n\n    return token;\n  }).catch(error => {\n    console.error(error);\n    throw new Error('Invalid Core response: not JSON');\n  });\n}\n\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\n/**\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\n * and get back a session token.\n *\n * @param {String} coreHost Core API server's hostname\n * @param {Number} corePort Core API server's port number\n * @param {String} apiPassword core api password\n * @param  {String} appPrivateKey Application's private key\n * @param  {String} blockchainId blockchain ID of the user signing in.\n * `null` if user has no blockchain ID\n * @param {String} authRequest authentication request token\n * @param {String} deviceId identifier for the current device\n *\n * @return {Promise} a Promise that resolves to a Core session token or rejects\n * with an error message.\n * @deprecated\n * @private\n * @ignore\n */\n\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey, blockchainId = null, authRequest = null, deviceId = '0') {\n  if (!authRequest) {\n    return Promise.reject('No authRequest provided');\n  }\n\n  try {\n    const authRequestObject = jsontokens_1.decodeToken(authRequest);\n\n    if (!authRequestObject) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    if (!authRequestObject.payload) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    const payload = authRequestObject.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const appDomain = payload.domain_name;\n\n    if (!appDomain) {\n      return Promise.reject('No domain_name in authRequest');\n    }\n\n    const appMethods = payload.scopes;\n    const coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n    return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n  } catch (e) {\n    console.error(e.stack);\n    return Promise.reject('Failed to parse authRequest in URL');\n  }\n}\n\nexports.getCoreSession = getCoreSession;","map":{"version":3,"sources":["../../src/auth/authSession.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsontokens_1 = require(\"jsontokens\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\n/**\n * Create an authentication token to be sent to the Core API server\n * in order to generate a Core session JWT.\n *\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\n * @param {Array} appMethods  The list of API methods this application will need.\n * @param {String} appPrivateKey  The application-specific private key\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\n * @param {String} thisDevice Identifier of the current device\n *\n * @return {String} a JWT signed by the app's private key\n * @deprecated\n * @private\n * @ignore\n */\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainID = null, thisDevice = null) {\n    if (thisDevice === null) {\n        thisDevice = '.default';\n    }\n    const appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);\n    const appPublicKeys = [{\n            public_key: appPublicKey,\n            device_id: thisDevice\n        }];\n    const authBody = {\n        version: 1,\n        blockchain_id: blockchainID,\n        app_private_key: appPrivateKey,\n        app_domain: appDomain,\n        methods: appMethods,\n        app_public_keys: appPublicKeys,\n        device_id: thisDevice\n    };\n    // make token\n    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);\n    const token = tokenSigner.sign(authBody);\n    return token;\n}\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\n/**\n * Send Core a request for a session token.\n *\n * @param {String} coreHost host name of the core node\n * @param {Number} corePort port number of the core node\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\n * @param {String} apiPassword the API password for Core\n *\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\n * that authorizes the bearer to carry out the requested operations and rejects\n * with an error message otherwise\n * @deprecated\n * @private\n * @ignore\n */\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n    return Promise.resolve().then(() => {\n        if (!apiPassword) {\n            throw new Error('Missing API password');\n        }\n    })\n        .then(() => {\n        const options = {\n            headers: {\n                Authorization: `bearer ${apiPassword}`\n            }\n        };\n        const url = `http://${coreHost}:${corePort}/v1/auth?authRequest=${coreAuthRequest}`;\n        return fetchUtil_1.fetchPrivate(url, options);\n    })\n        .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP status not OK');\n        }\n        return response.text();\n    })\n        .then((responseText) => {\n        const responseJson = JSON.parse(responseText);\n        const token = responseJson.token;\n        if (!token) {\n            throw new Error('Failed to get Core session token');\n        }\n        return token;\n    })\n        .catch((error) => {\n        console.error(error);\n        throw new Error('Invalid Core response: not JSON');\n    });\n}\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\n/**\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\n * and get back a session token.\n *\n * @param {String} coreHost Core API server's hostname\n * @param {Number} corePort Core API server's port number\n * @param {String} apiPassword core api password\n * @param  {String} appPrivateKey Application's private key\n * @param  {String} blockchainId blockchain ID of the user signing in.\n * `null` if user has no blockchain ID\n * @param {String} authRequest authentication request token\n * @param {String} deviceId identifier for the current device\n *\n * @return {Promise} a Promise that resolves to a Core session token or rejects\n * with an error message.\n * @deprecated\n * @private\n * @ignore\n */\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey, blockchainId = null, authRequest = null, deviceId = '0') {\n    if (!authRequest) {\n        return Promise.reject('No authRequest provided');\n    }\n    try {\n        const authRequestObject = jsontokens_1.decodeToken(authRequest);\n        if (!authRequestObject) {\n            return Promise.reject('Invalid authRequest in URL query string');\n        }\n        if (!authRequestObject.payload) {\n            return Promise.reject('Invalid authRequest in URL query string');\n        }\n        const payload = authRequestObject.payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        const appDomain = payload.domain_name;\n        if (!appDomain) {\n            return Promise.reject('No domain_name in authRequest');\n        }\n        const appMethods = payload.scopes;\n        const coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n        return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n    }\n    catch (e) {\n        console.error(e.stack);\n        return Promise.reject('Failed to parse authRequest in URL');\n    }\n}\nexports.getCoreSession = getCoreSession;\n//# sourceMappingURL=authSession.js.map"]},"metadata":{},"sourceType":"script"}