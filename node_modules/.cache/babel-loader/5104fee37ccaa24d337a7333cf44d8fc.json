{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64url_1 = require(\"base64url\");\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nconst sha256_1 = require(\"./cryptoClients/sha256\");\n\nclass TokenVerifier {\n  constructor(signingAlgorithm, rawPublicKey) {\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n\n  verify(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token, false);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token, false);\n    } else {\n      false;\n    }\n  }\n\n  verifyAsync(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token, true);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token, true);\n    } else {\n      return Promise.resolve(false);\n    }\n  }\n\n  verifyCompact(token, async) {\n    // decompose the token into parts\n    const tokenParts = token.split('.'); // calculate the signing input hash\n\n    const signingInput = tokenParts[0] + '.' + tokenParts[1];\n\n    const performVerify = signingInputHash => {\n      // extract the signature as a DER array\n      const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]); // verify the signed hash\n\n      return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n    };\n\n    if (async) {\n      return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));\n    } else {\n      const signingInputHash = sha256_1.hashSha256(signingInput);\n      return performVerify(signingInputHash);\n    }\n  }\n\n  verifyExpanded(token, async) {\n    const signingInput = [token['header'].join('.'), base64url_1.default.encode(token['payload'])].join('.');\n    let verified = true;\n\n    const performVerify = signingInputHash => {\n      token['signature'].map(signature => {\n        const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n        const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n\n        if (!signatureVerified) {\n          verified = false;\n        }\n      });\n      return verified;\n    };\n\n    if (async) {\n      return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));\n    } else {\n      const signingInputHash = sha256_1.hashSha256(signingInput);\n      return performVerify(signingInputHash);\n    }\n  }\n\n}\n\nexports.TokenVerifier = TokenVerifier;","map":{"version":3,"sources":["verifier.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,WAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,MAAa,aAAb,CAA0B;AAMtB,EAAA,WAAA,CAAY,gBAAZ,EAAsC,YAAtC,EAA0D;AACtD,QAAI,EAAE,gBAAgB,IAAI,YAAtB,CAAJ,EAAyC;AACrC,YAAM,IAAI,QAAA,CAAA,sBAAJ,CACF,iDADE,CAAN;AAEH;;AACD,QAAI,OAAO,gBAAP,KAA4B,QAAhC,EAA0C;AACtC,YAAM,8CAAN;AACH;;AACD,IAAA,gBAAgB,GAAG,gBAAgB,CAAC,WAAjB,EAAnB;;AACA,QAAI,CAAC,eAAA,CAAA,aAAA,CAAc,cAAd,CAA6B,gBAA7B,CAAL,EAAqD;AACjD,YAAM,2BAAN;AACH;;AACD,SAAK,SAAL,GAAiB,KAAjB;AACA,SAAK,YAAL,GAAoB,eAAA,CAAA,aAAA,CAAc,gBAAd,CAApB;AACA,SAAK,YAAL,GAAoB,YAApB;AACH;;AAED,EAAA,MAAM,CAAC,KAAD,EAA4B;AAC9B,QAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,aAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,KAA1B,CAAP;AACH,KAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAClC,aAAO,KAAK,cAAL,CAAoB,KAApB,EAA2B,KAA3B,CAAP;AACH,KAFM,MAEA;AACH;AACH;AACJ;;AAED,EAAA,WAAW,CAAC,KAAD,EAA4B;AACnC,QAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,aAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAA1B,CAAP;AACH,KAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAClC,aAAO,KAAK,cAAL,CAAoB,KAApB,EAA2B,IAA3B,CAAP;AACH,KAFM,MAEA;AACH,aAAO,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAP;AACH;AACJ;;AAID,EAAA,aAAa,CAAC,KAAD,EAAgB,KAAhB,EAA8B;AACvC;AACA,UAAM,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,GAAZ,CAAnB,CAFuC,CAIvC;;AACA,UAAM,YAAY,GAAG,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAhB,GAAsB,UAAU,CAAC,CAAD,CAArD;;AAEA,UAAM,aAAa,GAAI,gBAAD,IAA6B;AAC/C;AACA,YAAM,kBAAkB,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,UAAU,CAAC,CAAD,CAA1C,CAA3B,CAF+C,CAI/C;;AACA,aAAO,KAAK,YAAL,CAAkB,UAAlB,CACH,gBADG,EACe,kBADf,EACmC,KAAK,YADxC,CAAP;AAEH,KAPD;;AASA,QAAI,KAAJ,EAAW;AACP,aAAO,QAAA,CAAA,eAAA,CAAgB,YAAhB,EAA8B,IAA9B,CAAmC,gBAAgB,IACtD,aAAa,CAAC,gBAAD,CADV,CAAP;AAEH,KAHD,MAGO;AACH,YAAM,gBAAgB,GAAG,QAAA,CAAA,UAAA,CAAW,YAAX,CAAzB;AACA,aAAO,aAAa,CAAC,gBAAD,CAApB;AACH;AACJ;;AAID,EAAA,cAAc,CAAC,KAAD,EAAqB,KAArB,EAAmC;AAC7C,UAAM,YAAY,GAAG,CACjB,KAAK,CAAC,QAAD,CAAL,CAAgB,IAAhB,CAAqB,GAArB,CADiB,EAEjB,WAAA,CAAA,OAAA,CAAU,MAAV,CAAiB,KAAK,CAAC,SAAD,CAAtB,CAFiB,EAGnB,IAHmB,CAGd,GAHc,CAArB;AAIA,QAAI,QAAQ,GAAG,IAAf;;AAEA,UAAM,aAAa,GAAI,gBAAD,IAA6B;AAC/C,MAAA,KAAK,CAAC,WAAD,CAAL,CAAmB,GAAnB,CAAwB,SAAD,IAAsB;AACzC,cAAM,kBAAkB,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,SAAhC,CAA3B;AACA,cAAM,iBAAiB,GAAG,KAAK,YAAL,CAAkB,UAAlB,CACtB,gBADsB,EACJ,kBADI,EACgB,KAAK,YADrB,CAA1B;;AAEA,YAAI,CAAC,iBAAL,EAAwB;AACpB,UAAA,QAAQ,GAAG,KAAX;AACH;AACJ,OAPD;AAQA,aAAO,QAAP;AACH,KAVD;;AAYA,QAAI,KAAJ,EAAW;AACP,aAAO,QAAA,CAAA,eAAA,CAAgB,YAAhB,EAA8B,IAA9B,CAAmC,gBAAgB,IACtD,aAAa,CAAC,gBAAD,CADV,CAAP;AAEH,KAHD,MAGO;AACH,YAAM,gBAAgB,GAAG,QAAA,CAAA,UAAA,CAAW,YAAX,CAAzB;AACA,aAAO,aAAa,CAAC,gBAAD,CAApB;AACH;AACJ;;AAlGqB;;AAA1B,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"./","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = require(\"base64url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nclass TokenVerifier {\n    constructor(signingAlgorithm, rawPublicKey) {\n        if (!(signingAlgorithm && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw 'signing algorithm parameter must be a string';\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw 'invalid signing algorithm';\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPublicKey = rawPublicKey;\n    }\n    verify(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token, false);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token, false);\n        }\n        else {\n            false;\n        }\n    }\n    verifyAsync(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token, true);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token, true);\n        }\n        else {\n            return Promise.resolve(false);\n        }\n    }\n    verifyCompact(token, async) {\n        // decompose the token into parts\n        const tokenParts = token.split('.');\n        // calculate the signing input hash\n        const signingInput = tokenParts[0] + '.' + tokenParts[1];\n        const performVerify = (signingInputHash) => {\n            // extract the signature as a DER array\n            const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]);\n            // verify the signed hash\n            return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n        };\n        if (async) {\n            return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));\n        }\n        else {\n            const signingInputHash = sha256_1.hashSha256(signingInput);\n            return performVerify(signingInputHash);\n        }\n    }\n    verifyExpanded(token, async) {\n        const signingInput = [\n            token['header'].join('.'),\n            base64url_1.default.encode(token['payload'])\n        ].join('.');\n        let verified = true;\n        const performVerify = (signingInputHash) => {\n            token['signature'].map((signature) => {\n                const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n                const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n                if (!signatureVerified) {\n                    verified = false;\n                }\n            });\n            return verified;\n        };\n        if (async) {\n            return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));\n        }\n        else {\n            const signingInputHash = sha256_1.hashSha256(signingInput);\n            return performVerify(signingInputHash);\n        }\n    }\n}\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map"]},"metadata":{},"sourceType":"script"}