{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst dids_1 = require(\"../dids\");\n\nconst keys_1 = require(\"../keys\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst authProvider_1 = require(\"./authProvider\");\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\n\n\nfunction doSignaturesMatchPublicKeys(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n\n    try {\n      const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);\n      const signatureVerified = tokenVerifier.verify(token);\n\n      if (signatureVerified) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\n\nfunction doPublicKeysMatchIssuer(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n  const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\n\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    try {\n      const payload = jsontokens_1.decodeToken(token).payload;\n\n      if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n      }\n\n      if (!payload.username) {\n        return true;\n      }\n\n      if (payload.username === null) {\n        return true;\n      }\n\n      if (nameLookupURL === null) {\n        return false;\n      }\n\n      const username = payload.username;\n      const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n      const response = yield fetchUtil_1.fetchPrivate(url);\n      const responseText = yield response.text();\n      const responseJSON = JSON.parse(responseText);\n\n      if (responseJSON.hasOwnProperty('address')) {\n        const nameOwningAddress = responseJSON.address;\n        const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n        if (nameOwningAddress === addressFromIssuer) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    } catch (error) {\n      console.log(error);\n      console.log('Error checking `doPublicKeysMatchUsername`');\n      return false;\n    }\n  });\n}\n\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\n\nfunction isIssuanceDateValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isIssuanceDateValid = isIssuanceDateValid;\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\n\nfunction isExpirationDateValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isExpirationDateValid = isExpirationDateValid;\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\n\nfunction isManifestUriValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\n\nexports.isManifestUriValid = isManifestUriValid;\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\n\nfunction isRedirectUriValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\n\nexports.isRedirectUriValid = isRedirectUriValid;\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\n\nfunction verifyAuthRequest(token) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    if (jsontokens_1.decodeToken(token).header.alg === 'none') {\n      throw new Error('Token must be signed in order to be verified');\n    }\n\n    const values = yield Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n    return values.every(val => val);\n  });\n}\n\nexports.verifyAuthRequest = verifyAuthRequest;\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\n\nfunction verifyAuthRequestAndLoadManifest(token) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const valid = yield verifyAuthRequest(token);\n\n    if (!valid) {\n      throw new Error('Token is an invalid auth request');\n    }\n\n    return authProvider_1.fetchAppManifest(token);\n  });\n}\n\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\n\nfunction verifyAuthResponse(token, nameLookupURL) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const values = yield Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]);\n    return values.every(val => val);\n  });\n}\n\nexports.verifyAuthResponse = verifyAuthResponse;","map":{"version":3,"sources":["../../src/auth/authVerification.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst jsontokens_1 = require(\"jsontokens\");\nconst dids_1 = require(\"../dids\");\nconst keys_1 = require(\"../keys\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst authProvider_1 = require(\"./authProvider\");\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\nfunction doSignaturesMatchPublicKeys(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    if (publicKeys.length === 1) {\n        const publicKey = publicKeys[0];\n        try {\n            const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);\n            const signatureVerified = tokenVerifier.verify(token);\n            if (signatureVerified) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n}\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\nfunction doPublicKeysMatchIssuer(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n    if (publicKeys.length === 1) {\n        const addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);\n        if (addressFromPublicKeys === addressFromIssuer) {\n            return true;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n    return false;\n}\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n            const payload = jsontokens_1.decodeToken(token).payload;\n            if (typeof payload === 'string') {\n                throw new Error('Unexpected token payload type of string');\n            }\n            if (!payload.username) {\n                return true;\n            }\n            if (payload.username === null) {\n                return true;\n            }\n            if (nameLookupURL === null) {\n                return false;\n            }\n            const username = payload.username;\n            const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n            const response = yield fetchUtil_1.fetchPrivate(url);\n            const responseText = yield response.text();\n            const responseJSON = JSON.parse(responseText);\n            if (responseJSON.hasOwnProperty('address')) {\n                const nameOwningAddress = responseJSON.address;\n                const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n                if (nameOwningAddress === addressFromIssuer) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        catch (error) {\n            console.log(error);\n            console.log('Error checking `doPublicKeysMatchUsername`');\n            return false;\n        }\n    });\n}\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\nfunction isIssuanceDateValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.iat) {\n        if (typeof payload.iat !== 'number') {\n            return false;\n        }\n        const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n        if (new Date().getTime() < issuedAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexports.isIssuanceDateValid = isIssuanceDateValid;\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\nfunction isExpirationDateValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.exp) {\n        if (typeof payload.exp !== 'number') {\n            return false;\n        }\n        const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n        if (new Date().getTime() > expiresAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexports.isExpirationDateValid = isExpirationDateValid;\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nfunction isManifestUriValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexports.isManifestUriValid = isManifestUriValid;\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nfunction isRedirectUriValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexports.isRedirectUriValid = isRedirectUriValid;\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\nfunction verifyAuthRequest(token) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        if (jsontokens_1.decodeToken(token).header.alg === 'none') {\n            throw new Error('Token must be signed in order to be verified');\n        }\n        const values = yield Promise.all([\n            isExpirationDateValid(token),\n            isIssuanceDateValid(token),\n            doSignaturesMatchPublicKeys(token),\n            doPublicKeysMatchIssuer(token),\n            isManifestUriValid(token),\n            isRedirectUriValid(token)\n        ]);\n        return values.every(val => val);\n    });\n}\nexports.verifyAuthRequest = verifyAuthRequest;\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\nfunction verifyAuthRequestAndLoadManifest(token) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const valid = yield verifyAuthRequest(token);\n        if (!valid) {\n            throw new Error('Token is an invalid auth request');\n        }\n        return authProvider_1.fetchAppManifest(token);\n    });\n}\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\nfunction verifyAuthResponse(token, nameLookupURL) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const values = yield Promise.all([\n            isExpirationDateValid(token),\n            isIssuanceDateValid(token),\n            doSignaturesMatchPublicKeys(token),\n            doPublicKeysMatchIssuer(token),\n            doPublicKeysMatchUsername(token, nameLookupURL)\n        ]);\n        return values.every(val => val);\n    });\n}\nexports.verifyAuthResponse = verifyAuthResponse;\n//# sourceMappingURL=authVerification.js.map"]},"metadata":{},"sourceType":"script"}