{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst sha_js_1 = require(\"sha.js\");\n\nconst cryptoUtils_1 = require(\"./cryptoUtils\");\n\nclass NodeCryptoSha2Hash {\n  constructor(createHash) {\n    this.createHash = createHash;\n  }\n\n  digest(data, algorithm = 'sha256') {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const result = this.createHash(algorithm).update(data).digest();\n        return Promise.resolve(result);\n      } catch (error) {\n        console.log(error);\n        console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);\n        return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n      }\n    });\n  }\n\n}\n\nexports.NodeCryptoSha2Hash = NodeCryptoSha2Hash;\n\nclass WebCryptoSha2Hash {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  digest(data, algorithm = 'sha256') {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      let algo;\n\n      if (algorithm === 'sha256') {\n        algo = 'SHA-256';\n      } else if (algorithm === 'sha512') {\n        algo = 'SHA-512';\n      } else {\n        throw new Error(`Unsupported hash algorithm ${algorithm}`);\n      }\n\n      try {\n        const hash = yield this.subtleCrypto.digest(algo, data);\n        return Buffer.from(hash);\n      } catch (error) {\n        console.log(error);\n        console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);\n        return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n      }\n    });\n  }\n\n}\n\nexports.WebCryptoSha2Hash = WebCryptoSha2Hash;\n\nfunction createSha2Hash() {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cryptoLib = yield cryptoUtils_1.getCryptoLib();\n\n    if (cryptoLib.name === 'subtleCrypto') {\n      return new WebCryptoSha2Hash(cryptoLib.lib);\n    } else {\n      return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n    }\n  });\n}\n\nexports.createSha2Hash = createSha2Hash;\n\nfunction hashSha256Sync(data) {\n  const hash = new sha_js_1.sha256();\n  hash.update(data);\n  return hash.digest();\n}\n\nexports.hashSha256Sync = hashSha256Sync;\n\nfunction hashSha512Sync(data) {\n  const hash = new sha_js_1.sha512();\n  hash.update(data);\n  return hash.digest();\n}\n\nexports.hashSha512Sync = hashSha512Sync;","map":{"version":3,"sources":["../../src/encryption/sha2Hash.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst sha_js_1 = require(\"sha.js\");\nconst cryptoUtils_1 = require(\"./cryptoUtils\");\nclass NodeCryptoSha2Hash {\n    constructor(createHash) {\n        this.createHash = createHash;\n    }\n    digest(data, algorithm = 'sha256') {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = this.createHash(algorithm)\n                    .update(data)\n                    .digest();\n                return Promise.resolve(result);\n            }\n            catch (error) {\n                console.log(error);\n                console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);\n                return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n            }\n        });\n    }\n}\nexports.NodeCryptoSha2Hash = NodeCryptoSha2Hash;\nclass WebCryptoSha2Hash {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    digest(data, algorithm = 'sha256') {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            let algo;\n            if (algorithm === 'sha256') {\n                algo = 'SHA-256';\n            }\n            else if (algorithm === 'sha512') {\n                algo = 'SHA-512';\n            }\n            else {\n                throw new Error(`Unsupported hash algorithm ${algorithm}`);\n            }\n            try {\n                const hash = yield this.subtleCrypto.digest(algo, data);\n                return Buffer.from(hash);\n            }\n            catch (error) {\n                console.log(error);\n                console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);\n                return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n            }\n        });\n    }\n}\nexports.WebCryptoSha2Hash = WebCryptoSha2Hash;\nfunction createSha2Hash() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const cryptoLib = yield cryptoUtils_1.getCryptoLib();\n        if (cryptoLib.name === 'subtleCrypto') {\n            return new WebCryptoSha2Hash(cryptoLib.lib);\n        }\n        else {\n            return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n        }\n    });\n}\nexports.createSha2Hash = createSha2Hash;\nfunction hashSha256Sync(data) {\n    const hash = new sha_js_1.sha256();\n    hash.update(data);\n    return hash.digest();\n}\nexports.hashSha256Sync = hashSha256Sync;\nfunction hashSha512Sync(data) {\n    const hash = new sha_js_1.sha512();\n    hash.update(data);\n    return hash.digest();\n}\nexports.hashSha512Sync = hashSha512Sync;\n//# sourceMappingURL=sha2Hash.js.map"]},"metadata":{},"sourceType":"script"}