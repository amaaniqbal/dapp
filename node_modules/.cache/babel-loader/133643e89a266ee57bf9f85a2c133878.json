{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto_1 = require(\"crypto\");\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n/**\n *\n * @param numberOfBytes\n *\n * @ignore\n */\n\n\nfunction getEntropy(arg) {\n  if (!arg) {\n    arg = 32;\n  }\n\n  if (typeof arg === 'number') {\n    return crypto_1.randomBytes(arg);\n  } else {\n    return crypto_1.randomFillSync(arg);\n  }\n}\n\nexports.getEntropy = getEntropy;\n/**\n* @ignore\n*/\n\nfunction makeECPrivateKey() {\n  const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({\n    rng: getEntropy\n  });\n  return keyPair.privateKey.toString('hex');\n}\n\nexports.makeECPrivateKey = makeECPrivateKey;\n/**\n* @ignore\n*/\n\nfunction publicKeyToAddress(publicKey) {\n  const publicKeyBuffer = Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = bitcoinjs_lib_1.crypto.hash160(publicKeyBuffer);\n  const address = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, 0x00);\n  return address;\n}\n\nexports.publicKeyToAddress = publicKeyToAddress;\n/**\n* @ignore\n*/\n\nfunction getPublicKeyFromPrivate(privateKey) {\n  const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(privateKey, 'hex'));\n  return keyPair.publicKey.toString('hex');\n}\n\nexports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;","map":{"version":3,"sources":["../src/keys.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA;;;;;;;;AAMA,SAAgB,UAAhB,CAA2B,GAA3B,EAA+C;AAC7C,MAAI,CAAC,GAAL,EAAU;AACR,IAAA,GAAG,GAAG,EAAN;AACD;;AACD,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAO,QAAA,CAAA,WAAA,CAAY,GAAZ,CAAP;AACD,GAFD,MAEO;AACL,WAAO,QAAA,CAAA,cAAA,CAAe,GAAf,CAAP;AACD;AACF;;AATD,OAAA,CAAA,UAAA,GAAA,UAAA;AAWA;;;;AAGA,SAAgB,gBAAhB,GAAgC;AAC9B,QAAM,OAAO,GAAG,eAAA,CAAA,MAAA,CAAO,UAAP,CAAkB;AAAE,IAAA,GAAG,EAAE;AAAP,GAAlB,CAAhB;AACA,SAAO,OAAO,CAAC,UAAR,CAAmB,QAAnB,CAA4B,KAA5B,CAAP;AACD;;AAHD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAKA;;;;AAGA,SAAgB,kBAAhB,CAAmC,SAAnC,EAAoD;AAClD,QAAM,eAAe,GAAG,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,KAAvB,CAAxB;AACA,QAAM,gBAAgB,GAAG,eAAA,CAAA,MAAA,CAAQ,OAAR,CAAgB,eAAhB,CAAzB;AACA,QAAM,OAAO,GAAG,eAAA,CAAA,OAAA,CAAS,aAAT,CAAuB,gBAAvB,EAAyC,IAAzC,CAAhB;AACA,SAAO,OAAP;AACD;;AALD,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAOA;;;;AAGA,SAAgB,uBAAhB,CAAwC,UAAxC,EAA0D;AACxD,QAAM,OAAO,GAAG,eAAA,CAAA,MAAA,CAAO,cAAP,CAAsB,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,KAAxB,CAAtB,CAAhB;AACA,SAAO,OAAO,CAAC,SAAR,CAAkB,QAAlB,CAA2B,KAA3B,CAAP;AACD;;AAHD,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n/**\n *\n * @param numberOfBytes\n *\n * @ignore\n */\nfunction getEntropy(arg) {\n    if (!arg) {\n        arg = 32;\n    }\n    if (typeof arg === 'number') {\n        return crypto_1.randomBytes(arg);\n    }\n    else {\n        return crypto_1.randomFillSync(arg);\n    }\n}\nexports.getEntropy = getEntropy;\n/**\n* @ignore\n*/\nfunction makeECPrivateKey() {\n    const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({ rng: getEntropy });\n    return keyPair.privateKey.toString('hex');\n}\nexports.makeECPrivateKey = makeECPrivateKey;\n/**\n* @ignore\n*/\nfunction publicKeyToAddress(publicKey) {\n    const publicKeyBuffer = Buffer.from(publicKey, 'hex');\n    const publicKeyHash160 = bitcoinjs_lib_1.crypto.hash160(publicKeyBuffer);\n    const address = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, 0x00);\n    return address;\n}\nexports.publicKeyToAddress = publicKeyToAddress;\n/**\n* @ignore\n*/\nfunction getPublicKeyFromPrivate(privateKey) {\n    const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(privateKey, 'hex'));\n    return keyPair.publicKey.toString('hex');\n}\nexports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;\n//# sourceMappingURL=keys.js.map"]},"metadata":{},"sourceType":"script"}