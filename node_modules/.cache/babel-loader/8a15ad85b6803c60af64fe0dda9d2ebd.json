{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bip174_1 = require('bip174');\n\nconst varuint = require('bip174/src/lib/converter/varint');\n\nconst utils_1 = require('bip174/src/lib/utils');\n\nconst address_1 = require('./address');\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst crypto_1 = require('./crypto');\n\nconst ecpair_1 = require('./ecpair');\n\nconst networks_1 = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\n\n\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\n\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data; // set defaults\n\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2); // Make data hidden when enumerating\n\n    const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {\n      enumerable,\n      writable\n    });\n\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n\n  set version(version) {\n    this.setVersion(version);\n  }\n\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence\n    }));\n  }\n\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address\n      };\n    });\n  }\n\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n\n  addInput(inputData) {\n    if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) {\n      throw new Error(`Invalid arguments for Psbt.addInput. ` + `Requires single object with at least [hash] and [index]`);\n    }\n\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n\n  addOutput(outputData) {\n    if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) {\n      throw new Error(`Invalid arguments for Psbt.addOutput. ` + `Requires single object with at least [script or address] and [value]`);\n    }\n\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const {\n      address\n    } = outputData;\n\n    if (typeof address === 'string') {\n      const {\n        network\n      } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, {\n        script\n      });\n    }\n\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n\n    const tx = c.__TX.clone();\n\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n\n  getFeeRate() {\n    return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);\n  }\n\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const {\n      script,\n      isP2SH,\n      isP2WSH,\n      isSegwit\n    } = getScriptFromInput(inputIndex, input, this.__CACHE);\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const {\n      finalScriptSig,\n      finalScriptWitness\n    } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH);\n    if (finalScriptSig) this.data.updateInput(inputIndex, {\n      finalScriptSig\n    });\n    if (finalScriptWitness) this.data.updateInput(inputIndex, {\n      finalScriptWitness\n    });\n    if (!finalScriptSig && !finalScriptWitness) throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n    const results = range(this.data.inputs.length).map(idx => this.validateSignaturesOfInput(idx));\n    return results.reduce((final, res) => res === true && final, true);\n  }\n\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');\n    const mySigs = pubkey ? partialSig.filter(sig => sig.pubkey.equals(pubkey)) : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const {\n        hash,\n        script\n      } = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {\n        sighashType: sig.hashType\n      }), this.__CACHE) : {\n        hash: hashCache,\n        script: scriptCache\n      };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n\n    return results.every(res => res === true);\n  }\n\n  signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n\n    const results = [];\n\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n\n    return this;\n  }\n\n  signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n\n      const results = [];\n      const promises = [];\n\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n\n  signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer => this.signInputAsync(inputIndex, signer, sighashTypes));\n      return Promise.all(promises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n\n  signAllInputs(keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input'); // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n\n    const results = [];\n\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n\n    return this;\n  }\n\n  signAllInputsAsync(keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input')); // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n\n      const results = [];\n      const promises = [];\n\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n    const {\n      hash,\n      sighashType\n    } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n    const partialSig = [{\n      pubkey: keyPair.publicKey,\n      signature: bscript.signature.encode(keyPair.sign(hash), sighashType)\n    }];\n    this.data.updateInput(inputIndex, {\n      partialSig\n    });\n    return this;\n  }\n\n  signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n      const {\n        hash,\n        sighashType\n      } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [{\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType)\n        }];\n        this.data.updateInput(inputIndex, {\n          partialSig\n        });\n      });\n    });\n  }\n\n  toBuffer() {\n    return this.data.toBuffer();\n  }\n\n  toHex() {\n    return this.data.toHex();\n  }\n\n  toBase64() {\n    return this.data.toBase64();\n  }\n\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n\n  updateInput(inputIndex, updateData) {\n    this.data.updateInput(inputIndex, updateData);\n\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);\n    }\n\n    return this;\n  }\n\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n\n}\n\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\n\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\n\n\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true\n    });\n  }\n\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length\n    };\n  }\n\n  addInput(input) {\n    if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== 'string' || typeof input.index !== 'number') {\n      throw new Error('Error adding input.');\n    }\n\n    const hash = typeof input.hash === 'string' ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex')) : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n\n  addOutput(output) {\n    if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== 'number') {\n      throw new Error('Error adding output.');\n    }\n\n    this.tx.addOutput(output.script, output.value);\n  }\n\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n\n}\n\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n\n    case 'multisig':\n      const p2ms = payments.p2ms({\n        output: script\n      });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n\n    default:\n      return false;\n  }\n}\n\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n\n  if (pubkeys) {\n    sigs = pubkeys.map(pkey => {\n      const pubkey = ecpair_1.fromPublicKey(pkey, {\n        compressed: true\n      }).publicKey;\n      return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n    }).filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\n\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\n\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({\n        output: script\n      });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\n\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\n\nfunction check32Bit(num) {\n  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\n\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n\n  const satoshis = feeRate * vsize;\n\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` + `fees, which is ${feeRate} satoshi per byte for a transaction ` + `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` + `byte). Use setMaximumFeeRate method to raise your threshold, or ` + `pass true to the first arg of extractTransaction.`);\n  }\n}\n\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n\n    pSigs.forEach(pSig => {\n      const {\n        hashType\n      } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\n\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const {\n    partialSig,\n    sighashType\n  } = input;\n  partialSig.forEach(pSig => {\n    const {\n      hashType\n    } = bscript.signature.decode(pSig.signature);\n\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\n\nfunction checkScriptForPubkey(pubkey, script, action) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  const hasKey = decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n\n  if (!hasKey) {\n    throw new Error(`Can not ${action} for this input with the key ${pubkey.toString('hex')}`);\n  }\n}\n\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(input => input.script && input.script.length === 0 && input.witness && input.witness.length === 0);\n\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\n\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\n\nfunction checkTxInputCache(cache, input) {\n  const key = bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\n\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript) => {\n    const redeemScriptOutput = payment({\n      redeem: {\n        output: redeemScript\n      }\n    }).output;\n\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(`${paymentScriptName} for input #${inputIndex} doesn't match the scriptPubKey in the prevout`);\n    }\n  };\n}\n\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');\n\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized)) throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;\n}\n\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType)) throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);\n}\n\nfunction prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {\n  let finalScriptSig;\n  let finalScriptWitness; // Wow, the payments API is very handy\n\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({\n    redeem: payment\n  });\n  const p2sh = !isP2SH ? null : payments.p2sh({\n    redeem: p2wsh || payment\n  });\n\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n\n  return {\n    finalScriptSig,\n    finalScriptWitness\n  };\n}\n\nfunction getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const {\n    hash,\n    sighashType,\n    script\n  } = getHashForSig(inputIndex, input, cache, sighashTypes);\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType\n  };\n}\n\nfunction getHashForSig(inputIndex, input, cache, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` + `sighashTypes array of whitelisted types. Sighash type: ${str}`);\n  }\n\n  let hash;\n  let script;\n\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash(); // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);\n    }\n\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    const prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, prevout.script, input.redeemScript);\n      script = input.redeemScript;\n    } else {\n      script = prevout.script;\n    }\n\n    if (isP2WSHScript(script)) {\n      if (!input.witnessScript) throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(inputIndex, input.witnessScript, prevout.value, sighashType);\n      script = input.witnessScript;\n    } else if (isP2WPKH(script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({\n        hash: script.slice(2)\n      }).output;\n      hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);\n    } else {\n      hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);\n    }\n  } else if (input.witnessUtxo) {\n    let _script; // so we don't shadow the `let script` above\n\n\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, input.witnessUtxo.script, input.redeemScript);\n      _script = input.redeemScript;\n    } else {\n      _script = input.witnessUtxo.script;\n    }\n\n    if (isP2WPKH(_script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({\n        hash: _script.slice(2)\n      }).output;\n      hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, input.witnessUtxo.value, sighashType);\n      script = _script;\n    } else if (isP2WSHScript(_script)) {\n      if (!input.witnessScript) throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, _script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(inputIndex, input.witnessScript, input.witnessUtxo.value, sighashType); // want to make sure the script we return is the actual meaningful script\n\n      script = input.witnessScript;\n    } else {\n      throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` + `${_script.toString('hex')}`);\n    }\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n\n  return {\n    script,\n    sighashType,\n    hash\n  };\n}\n\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs\n      });\n      break;\n\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n  }\n\n  return payment;\n}\n\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems.concat(witnessItems).filter(item => {\n    return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n  }).map(sig => ({\n    signature: sig\n  }));\n}\n\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n\n  return res;\n}\n\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n\n  const myDerivations = input.bip32Derivation.map(bipDv => {\n    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n      return bipDv;\n    } else {\n      return;\n    }\n  }).filter(v => !!v);\n\n  if (myDerivations.length === 0) {\n    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');\n  }\n\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n\n    return node;\n  });\n  return signers;\n}\n\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({\n    output: script\n  }); // for each pubkey in order of p2ms script\n\n  return p2ms.pubkeys.map(pk => {\n    // filter partialSig array by pubkey being equal\n    return (partialSig.filter(ps => {\n      return ps.pubkey.equals(pk);\n    })[0] || {}).signature; // Any pubkey without a match will return undefined\n    // this last filter removes all the undefined items in the array.\n  }).filter(v => !!v);\n}\n\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  return readVector();\n}\n\nfunction sighashTypeToString(sighashType) {\n  let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';\n  const sigMod = sighashType & 0x1f;\n\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n\n  return text;\n}\n\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeVector(witness);\n  return buffer;\n}\n\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    }\n\n  });\n}\n\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;\n\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);\n    }\n\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\n\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n\n  return c[inputIndex];\n}\n\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\n\nfunction range(n) {\n  return [...Array(n).keys()];\n}","map":{"version":3,"sources":["/home/os/Desktop/hello-world-tutorial/node_modules/bitcoinjs-lib/src/psbt.js"],"names":["Object","defineProperty","exports","value","bip174_1","require","varuint","utils_1","address_1","bufferutils_1","crypto_1","ecpair_1","networks_1","payments","bscript","transaction_1","DEFAULT_OPTS","network","bitcoin","maximumFeeRate","Psbt","constructor","opts","data","PsbtTransaction","assign","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","globalMap","unsignedTx","tx","inputs","length","setVersion","dpew","obj","attr","enumerable","writable","fromBase64","buffer","Buffer","from","fromBuffer","fromHex","psbtBase","transactionFromBuffer","psbt","checkTxForDupeIns","inputCount","version","locktime","setLocktime","txInputs","ins","map","input","hash","cloneBuffer","index","sequence","txOutputs","outs","output","address","fromOutputScript","script","_","combine","those","o","clone","res","toBuffer","JSON","parse","stringify","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","c","__EXTRACTED_TX","undefined","setInputSequence","inputIndex","Error","addInputs","inputDatas","forEach","inputData","addInput","arguments","txIn","checkTxInputCache","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","outputData","addOutput","toOutputScript","extractTransaction","disableFeeCheck","every","isFinalized","checkFees","inputFinalizeGetAmts","getFeeRate","getTxCacheValue","getFee","finalizeAllInputs","checkForInput","range","idx","finalizeInput","finalScriptsFunc","getFinalScripts","isP2SH","isP2WSH","isSegwit","getScriptFromInput","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","clearFinalizedInput","validateSignaturesOfAllInputs","results","validateSignaturesOfInput","reduce","final","pubkey","partialSig","mySigs","filter","sig","equals","hashCache","scriptCache","sighashCache","pSig","signature","decode","hashType","getHashForSig","sighashType","checkScriptForPubkey","keypair","fromPublicKey","push","verify","signAllInputsHD","hdKeyPair","sighashTypes","Transaction","SIGHASH_ALL","publicKey","fingerprint","i","signInputHD","err","v","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","then","all","signers","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","entries","getHashAndSighashType","encode","sign","toHex","toBase64","updateGlobal","updateData","updateOutput","outputIndex","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","outputCount","isBuffer","reverseBuffer","canFinalize","scriptType","hasSigs","p2ms","m","pubkeys","neededSigs","sigs","pkey","compressed","find","isPaymentFactory","payment","isP2MS","isP2PK","p2pk","isP2PKH","p2pkh","isP2WPKH","p2wpkh","isP2WSHScript","p2wsh","num","Math","floor","cache","feeRate","vsize","virtualSize","satoshis","toFixed","action","throws","pSigs","getPsigsFromInputFinalScripts","whitelist","isAnyoneCanPay","SIGHASH_ANYONECANPAY","hashMod","SIGHASH_SINGLE","SIGHASH_NONE","indexOf","pubkeyHash","hash160","decompiled","decompile","hasKey","some","element","toString","isEmpty","witness","key","scriptCheckerFactory","paymentScriptName","scriptPubKey","redeemScript","redeemScriptOutput","redeem","checkRedeemScript","p2sh","checkWitnessScript","name","mustFinalize","classifyScript","prepareFinalScripts","getPayment","witnessStackToScriptWitness","str","sighashTypeToString","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutHash","utxoHash","getHash","prevoutIndex","prevout","witnessScript","hashForWitnessV0","signingScript","slice","hashForSignature","witnessUtxo","_script","getSortedSigs","signatures","scriptItems","witnessItems","concat","item","isCanonicalScriptSignature","bip32Derivation","myDerivations","bipDv","masterFingerprint","node","derivePath","path","pk","ps","scriptWitnessToWitnessStack","offset","readSlice","n","readVarInt","vi","bytes","readVarSlice","readVector","count","vector","text","sigMod","allocUnsafe","writeSlice","writeVarInt","currentLen","varintLen","encodingLength","writeVarSlice","writeVector","self","selfIndex","get","buf","txCache","newBuf","set","inputAmount","nwTx","vout","out","outputAmount","total","fee","Array","keys"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n      });\n    });\n  }\n  toBuffer() {\n    return this.data.toBuffer();\n  }\n  toHex() {\n    return this.data.toHex();\n  }\n  toBase64() {\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  const hasKey = decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n  if (!hasKey) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for input #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let script;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    const prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, prevout.script, input.redeemScript);\n      script = input.redeemScript;\n    } else {\n      script = prevout.script;\n    }\n    if (isP2WSHScript(script)) {\n      if (!input.witnessScript)\n        throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        input.witnessScript,\n        prevout.value,\n        sighashType,\n      );\n      script = input.witnessScript;\n    } else if (isP2WPKH(script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({ hash: script.slice(2) }).output;\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        signingScript,\n        prevout.value,\n        sighashType,\n      );\n    } else {\n      hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);\n    }\n  } else if (input.witnessUtxo) {\n    let _script; // so we don't shadow the `let script` above\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(\n        inputIndex,\n        input.witnessUtxo.script,\n        input.redeemScript,\n      );\n      _script = input.redeemScript;\n    } else {\n      _script = input.witnessUtxo.script;\n    }\n    if (isP2WPKH(_script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({ hash: _script.slice(2) }).output;\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        signingScript,\n        input.witnessUtxo.value,\n        sighashType,\n      );\n      script = _script;\n    } else if (isP2WSHScript(_script)) {\n      if (!input.witnessScript)\n        throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, _script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(\n        inputIndex,\n        input.witnessScript,\n        input.witnessUtxo.value,\n        sighashType,\n      );\n      // want to make sure the script we return is the actual meaningful script\n      script = input.witnessScript;\n    } else {\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${_script.toString('hex')}`,\n      );\n    }\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  return {\n    script,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"]},"metadata":{},"sourceType":"script"}