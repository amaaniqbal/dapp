{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ripemd160_min_1 = require(\"ripemd160-min\");\n\nconst cryptoUtils_1 = require(\"./cryptoUtils\");\n\nclass Ripemd160PolyfillDigest {\n  digest(data) {\n    const instance = new ripemd160_min_1.default();\n    instance.update(data);\n    const hash = instance.digest();\n\n    if (Array.isArray(hash)) {\n      return Buffer.from(hash);\n    } else {\n      return Buffer.from(hash.buffer);\n    }\n  }\n\n}\n\nexports.Ripemd160PolyfillDigest = Ripemd160PolyfillDigest;\n\nclass NodeCryptoRipemd160Digest {\n  constructor(nodeCryptoCreateHash) {\n    this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n  }\n\n  digest(data) {\n    try {\n      return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n    } catch (error) {\n      try {\n        return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n      } catch (_err) {\n        console.log(error);\n        console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n        const polyfill = new Ripemd160PolyfillDigest();\n        return polyfill.digest(data);\n      }\n    }\n  }\n\n}\n\nexports.NodeCryptoRipemd160Digest = NodeCryptoRipemd160Digest;\n\nfunction createHashRipemd160() {\n  const nodeCryptoCreateHash = cryptoUtils_1.isNodeCryptoAvailable(nodeCrypto => {\n    if (typeof nodeCrypto.createHash === 'function') {\n      return nodeCrypto.createHash;\n    }\n\n    return false;\n  });\n\n  if (nodeCryptoCreateHash) {\n    return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n  } else {\n    return new Ripemd160PolyfillDigest();\n  }\n}\n\nexports.createHashRipemd160 = createHashRipemd160;\n\nfunction hashRipemd160(data) {\n  const hash = createHashRipemd160();\n  return hash.digest(data);\n}\n\nexports.hashRipemd160 = hashRipemd160;","map":{"version":3,"sources":["../../src/encryption/hashRipemd160.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAQA,MAAa,uBAAb,CAAoC;AAClC,EAAA,MAAM,CAAC,IAAD,EAAa;AACjB,UAAM,QAAQ,GAAG,IAAI,eAAA,CAAA,OAAJ,EAAjB;AACA,IAAA,QAAQ,CAAC,MAAT,CAAgB,IAAhB;AACA,UAAM,IAAI,GAAG,QAAQ,CAAC,MAAT,EAAb;;AACA,QAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,aAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAP;AACD,KAFD,MAEO;AACL,aAAO,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,MAAjB,CAAP;AACD;AACF;;AAViC;;AAApC,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAaA,MAAa,yBAAb,CAAsC;AAGpC,EAAA,WAAA,CAAY,oBAAZ,EAAsD;AACpD,SAAK,oBAAL,GAA4B,oBAA5B;AACD;;AAED,EAAA,MAAM,CAAC,IAAD,EAAa;AACjB,QAAI;AACF,aAAO,KAAK,oBAAL,CAA0B,QAA1B,EAAoC,MAApC,CAA2C,IAA3C,EAAiD,MAAjD,EAAP;AACD,KAFD,CAEE,OAAO,KAAP,EAAc;AACd,UAAI;AACF,eAAO,KAAK,oBAAL,CAA0B,WAA1B,EAAuC,MAAvC,CAA8C,IAA9C,EAAoD,MAApD,EAAP;AACD,OAFD,CAEE,OAAO,IAAP,EAAa;AACb,QAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,QAAA,OAAO,CAAC,GAAR,CAAY,2GAAZ;AACA,cAAM,QAAQ,GAAG,IAAI,uBAAJ,EAAjB;AACA,eAAO,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAP;AACD;AACF;AACF;;AApBmC;;AAAtC,OAAA,CAAA,yBAAA,GAAA,yBAAA;;AAuBA,SAAgB,mBAAhB,GAAmC;AACjC,QAAM,oBAAoB,GAAG,aAAA,CAAA,qBAAA,CAAsB,UAAU,IAAG;AAC9D,QAAI,OAAO,UAAU,CAAC,UAAlB,KAAiC,UAArC,EAAiD;AAC/C,aAAO,UAAU,CAAC,UAAlB;AACD;;AACD,WAAO,KAAP;AACD,GAL4B,CAA7B;;AAMA,MAAI,oBAAJ,EAA0B;AACxB,WAAO,IAAI,yBAAJ,CAA8B,oBAA9B,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI,uBAAJ,EAAP;AACD;AACF;;AAZD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAcA,SAAgB,aAAhB,CAA8B,IAA9B,EAA0C;AACxC,QAAM,IAAI,GAAG,mBAAmB,EAAhC;AACA,SAAO,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAP;AACD;;AAHD,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ripemd160_min_1 = require(\"ripemd160-min\");\nconst cryptoUtils_1 = require(\"./cryptoUtils\");\nclass Ripemd160PolyfillDigest {\n    digest(data) {\n        const instance = new ripemd160_min_1.default();\n        instance.update(data);\n        const hash = instance.digest();\n        if (Array.isArray(hash)) {\n            return Buffer.from(hash);\n        }\n        else {\n            return Buffer.from(hash.buffer);\n        }\n    }\n}\nexports.Ripemd160PolyfillDigest = Ripemd160PolyfillDigest;\nclass NodeCryptoRipemd160Digest {\n    constructor(nodeCryptoCreateHash) {\n        this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n    }\n    digest(data) {\n        try {\n            return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n        }\n        catch (error) {\n            try {\n                return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n            }\n            catch (_err) {\n                console.log(error);\n                console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n                const polyfill = new Ripemd160PolyfillDigest();\n                return polyfill.digest(data);\n            }\n        }\n    }\n}\nexports.NodeCryptoRipemd160Digest = NodeCryptoRipemd160Digest;\nfunction createHashRipemd160() {\n    const nodeCryptoCreateHash = cryptoUtils_1.isNodeCryptoAvailable(nodeCrypto => {\n        if (typeof nodeCrypto.createHash === 'function') {\n            return nodeCrypto.createHash;\n        }\n        return false;\n    });\n    if (nodeCryptoCreateHash) {\n        return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n    }\n    else {\n        return new Ripemd160PolyfillDigest();\n    }\n}\nexports.createHashRipemd160 = createHashRipemd160;\nfunction hashRipemd160(data) {\n    const hash = createHashRipemd160();\n    return hash.digest(data);\n}\nexports.hashRipemd160 = hashRipemd160;\n//# sourceMappingURL=hashRipemd160.js.map"]},"metadata":{},"sourceType":"script"}