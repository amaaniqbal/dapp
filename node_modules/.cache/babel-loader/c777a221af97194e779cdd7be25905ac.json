{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst keys_1 = require(\"../keys\");\n\nconst logger_1 = require(\"../logger\");\n\nconst cryptoRandom_1 = require(\"../encryption/cryptoRandom\");\n\nconst sha2Hash_1 = require(\"../encryption/sha2Hash\");\n/**\n * @ignore\n */\n\n\nexports.BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';\n/**\n *\n * @param filename\n * @param contents\n * @param hubConfig\n * @param contentType\n *\n * @ignore\n */\n\nfunction uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream', newFile = true, etag) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    logger_1.Logger.debug(`uploadToGaiaHub: uploading ${filename} to ${hubConfig.server}`);\n    const headers = {\n      'Content-Type': contentType,\n      Authorization: `bearer ${hubConfig.token}`\n    };\n\n    if (newFile) {\n      headers['If-None-Match'] = '*';\n    } else if (etag) {\n      headers['If-Match'] = etag;\n    }\n\n    const response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/store/${hubConfig.address}/${filename}`, {\n      method: 'POST',\n      headers,\n      body: contents\n    });\n\n    if (!response.ok) {\n      throw yield utils_1.getBlockstackErrorFromResponse(response, 'Error when uploading to Gaia hub.', hubConfig);\n    }\n\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    return responseJSON;\n  });\n}\n\nexports.uploadToGaiaHub = uploadToGaiaHub;\n\nfunction deleteFromGaiaHub(filename, hubConfig) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    logger_1.Logger.debug(`deleteFromGaiaHub: deleting ${filename} from ${hubConfig.server}`);\n    const response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/delete/${hubConfig.address}/${filename}`, {\n      method: 'DELETE',\n      headers: {\n        Authorization: `bearer ${hubConfig.token}`\n      }\n    });\n\n    if (!response.ok) {\n      throw yield utils_1.getBlockstackErrorFromResponse(response, 'Error deleting file from Gaia hub.', hubConfig);\n    }\n  });\n}\n\nexports.deleteFromGaiaHub = deleteFromGaiaHub;\n/**\n *\n * @param filename\n * @param hubConfig\n *\n * @ignore\n */\n\nfunction getFullReadUrl(filename, hubConfig) {\n  return Promise.resolve(`${hubConfig.url_prefix}${hubConfig.address}/${filename}`);\n}\n\nexports.getFullReadUrl = getFullReadUrl;\n/**\n *\n * @param challengeText\n * @param signerKeyHex\n *\n * @ignore\n */\n\nfunction makeLegacyAuthToken(challengeText, signerKeyHex) {\n  // only sign specific legacy auth challenges.\n  let parsedChallenge;\n\n  try {\n    parsedChallenge = JSON.parse(challengeText);\n  } catch (err) {\n    throw new Error('Failed in parsing legacy challenge text from the gaia hub.');\n  }\n\n  if (parsedChallenge[0] === 'gaiahub' && parsedChallenge[3] === 'blockstack_storage_please_sign') {\n    const signer = keys_1.hexStringToECPair(signerKeyHex + (signerKeyHex.length === 64 ? '01' : ''));\n    const digest = sha2Hash_1.hashSha256Sync(Buffer.from(challengeText));\n    const signatureBuffer = signer.sign(digest);\n    const signatureWithHash = bitcoinjs_lib_1.script.signature.encode(signatureBuffer, bitcoinjs_lib_1.Transaction.SIGHASH_NONE); // We only want the DER encoding so remove the sighash version byte at the end.\n    // See: https://github.com/bitcoinjs/bitcoinjs-lib/issues/1241#issuecomment-428062912\n\n    const signature = signatureWithHash.toString('hex').slice(0, -2);\n    const publickey = keys_1.getPublicKeyFromPrivate(signerKeyHex);\n    const token = Buffer.from(JSON.stringify({\n      publickey,\n      signature\n    })).toString('base64');\n    return token;\n  } else {\n    throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');\n  }\n}\n/**\n *\n * @param hubInfo\n * @param signerKeyHex\n * @param hubUrl\n * @param associationToken\n *\n * @ignore\n */\n\n\nfunction makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {\n  const challengeText = hubInfo.challenge_text;\n  const handlesV1Auth = hubInfo.latest_auth_version && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1;\n  const iss = keys_1.getPublicKeyFromPrivate(signerKeyHex);\n\n  if (!handlesV1Auth) {\n    return makeLegacyAuthToken(challengeText, signerKeyHex);\n  }\n\n  const salt = cryptoRandom_1.randomBytes(16).toString('hex');\n  const payload = {\n    gaiaChallenge: challengeText,\n    hubUrl,\n    iss,\n    salt,\n    associationToken\n  };\n  const token = new jsontokens_1.TokenSigner('ES256K', signerKeyHex).sign(payload);\n  return `v1:${token}`;\n}\n/**\n *\n * @ignore\n */\n\n\nfunction connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    logger_1.Logger.debug(`connectToGaiaHub: ${gaiaHubUrl}/hub_info`);\n    const response = yield fetchUtil_1.fetchPrivate(`${gaiaHubUrl}/hub_info`);\n    const hubInfo = yield response.json();\n    const readURL = hubInfo.read_url_prefix;\n    const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);\n    const address = keys_1.ecPairToAddress(keys_1.hexStringToECPair(challengeSignerHex + (challengeSignerHex.length === 64 ? '01' : '')));\n    return {\n      url_prefix: readURL,\n      max_file_upload_size_megabytes: hubInfo.max_file_upload_size_megabytes,\n      address,\n      token,\n      server: gaiaHubUrl\n    };\n  });\n}\n\nexports.connectToGaiaHub = connectToGaiaHub;\n/**\n *\n * @param gaiaHubUrl\n * @param appPrivateKey\n *\n * @ignore\n */\n\nfunction getBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const challengeSigner = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(appPrivateKey, 'hex'));\n    const response = yield fetchUtil_1.fetchPrivate(`${gaiaHubUrl}/hub_info`);\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    const readURL = responseJSON.read_url_prefix;\n    const address = keys_1.ecPairToAddress(challengeSigner);\n    const bucketUrl = `${readURL}${address}/`;\n    return bucketUrl;\n  });\n}\n\nexports.getBucketUrl = getBucketUrl;","map":{"version":3,"sources":["../../src/storage/hub.ts"],"names":[],"mappings":";;;;;;;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;AAEA;;;;;AAGa,OAAA,CAAA,yBAAA,GAA4B,4BAA5B;AAkBb;;;;;;;;;;AASA,SAAsB,eAAtB,CACE,QADF,EAEE,QAFF,EAGE,SAHF,EAIE,WAAA,GAAsB,0BAJxB,EAKE,OAAA,GAAmB,IALrB,EAME,IANF,EAMe;;AAEb,IAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,8BAA8B,QAAQ,OAAO,SAAS,CAAC,MAAM,EAA1E;AAEA,UAAM,OAAO,GAA+B;AAC1C,sBAAgB,WAD0B;AAE1C,MAAA,aAAa,EAAE,UAAU,SAAS,CAAC,KAAK;AAFE,KAA5C;;AAKA,QAAI,OAAJ,EAAa;AACX,MAAA,OAAO,CAAC,eAAD,CAAP,GAA2B,GAA3B;AACD,KAFD,MAEO,IAAI,IAAJ,EAAU;AACf,MAAA,OAAO,CAAC,UAAD,CAAP,GAAsB,IAAtB;AACD;;AAED,UAAM,QAAQ,GAAG,MAAM,WAAA,CAAA,YAAA,CACrB,GAAG,SAAS,CAAC,MAAM,UAAU,SAAS,CAAC,OAAO,IAAI,QAAQ,EADrC,EACyC;AAC5D,MAAA,MAAM,EAAE,MADoD;AAE5D,MAAA,OAF4D;AAG5D,MAAA,IAAI,EAAE;AAHsD,KADzC,CAAvB;;AAOA,QAAI,CAAC,QAAQ,CAAC,EAAd,EAAkB;AAChB,YAAM,MAAM,OAAA,CAAA,8BAAA,CAA+B,QAA/B,EAAyC,mCAAzC,EAA8E,SAA9E,CAAZ;AACD;;AACD,UAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,IAAT,EAA3B;AACA,UAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,CAArB;AAEA,WAAO,YAAP;AACD,G;AAAA;;AAnCD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAqCA,SAAsB,iBAAtB,CACE,QADF,EAEE,SAFF,EAE0B;;AAExB,IAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,+BAA+B,QAAQ,SAAS,SAAS,CAAC,MAAM,EAA7E;AACA,UAAM,QAAQ,GAAG,MAAM,WAAA,CAAA,YAAA,CACrB,GAAG,SAAS,CAAC,MAAM,WAAW,SAAS,CAAC,OAAO,IAAI,QAAQ,EADtC,EAC0C;AAC7D,MAAA,MAAM,EAAE,QADqD;AAE7D,MAAA,OAAO,EAAE;AACP,QAAA,aAAa,EAAE,UAAU,SAAS,CAAC,KAAK;AADjC;AAFoD,KAD1C,CAAvB;;AAQA,QAAI,CAAC,QAAQ,CAAC,EAAd,EAAkB;AAChB,YAAM,MAAM,OAAA,CAAA,8BAAA,CAA+B,QAA/B,EAAyC,oCAAzC,EAA+E,SAA/E,CAAZ;AACD;AACF,G;AAAA;;AAhBD,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAkBA;;;;;;;;AAOA,SAAgB,cAAhB,CAA+B,QAA/B,EAC+B,SAD/B,EACuD;AACrD,SAAO,OAAO,CAAC,OAAR,CAAgB,GAAG,SAAS,CAAC,UAAU,GAAG,SAAS,CAAC,OAAO,IAAI,QAAQ,EAAvE,CAAP;AACD;;AAHD,OAAA,CAAA,cAAA,GAAA,cAAA;AAKA;;;;;;;;AAOA,SAAS,mBAAT,CAA6B,aAA7B,EAAoD,YAApD,EAAwE;AACtE;AACA,MAAI,eAAJ;;AACA,MAAI;AACF,IAAA,eAAe,GAAG,IAAI,CAAC,KAAL,CAAW,aAAX,CAAlB;AACD,GAFD,CAEE,OAAO,GAAP,EAAY;AACZ,UAAM,IAAI,KAAJ,CAAU,4DAAV,CAAN;AACD;;AACD,MAAI,eAAe,CAAC,CAAD,CAAf,KAAuB,SAAvB,IACG,eAAe,CAAC,CAAD,CAAf,KAAuB,gCAD9B,EACgE;AAC9D,UAAM,MAAM,GAAG,MAAA,CAAA,iBAAA,CAAkB,YAAY,IACT,YAAY,CAAC,MAAb,KAAwB,EAAxB,GAA6B,IAA7B,GAAoC,EAD3B,CAA9B,CAAf;AAEA,UAAM,MAAM,GAAG,UAAA,CAAA,cAAA,CAAe,MAAM,CAAC,IAAP,CAAY,aAAZ,CAAf,CAAf;AAEA,UAAM,eAAe,GAAG,MAAM,CAAC,IAAP,CAAY,MAAZ,CAAxB;AACA,UAAM,iBAAiB,GAAG,eAAA,CAAA,MAAA,CAAO,SAAP,CAAiB,MAAjB,CACxB,eADwB,EACP,eAAA,CAAA,WAAA,CAAY,YADL,CAA1B,CAN8D,CAS9D;AACA;;AACA,UAAM,SAAS,GAAG,iBAAiB,CAAC,QAAlB,CAA2B,KAA3B,EAAkC,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAlB;AAEA,UAAM,SAAS,GAAG,MAAA,CAAA,uBAAA,CAAwB,YAAxB,CAAlB;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,SAAL,CACxB;AAAE,MAAA,SAAF;AAAa,MAAA;AAAb,KADwB,CAAZ,EAEX,QAFW,CAEF,QAFE,CAAd;AAGA,WAAO,KAAP;AACD,GAnBD,MAmBO;AACL,UAAM,IAAI,KAAJ,CAAU,+EAAV,CAAN;AACD;AACF;AAED;;;;;;;;;;;AASA,SAAS,mBAAT,CAA6B,OAA7B,EAC6B,YAD7B,EAE6B,MAF7B,EAG6B,gBAH7B,EAGsD;AACpD,QAAM,aAAa,GAAG,OAAO,CAAC,cAA9B;AACA,QAAM,aAAa,GAAI,OAAO,CAAC,mBAAR,IACG,QAAQ,CAAC,OAAO,CAAC,mBAAR,CAA4B,KAA5B,CAAkC,CAAlC,CAAD,EAAuC,EAAvC,CAAR,IAAsD,CADhF;AAEA,QAAM,GAAG,GAAG,MAAA,CAAA,uBAAA,CAAwB,YAAxB,CAAZ;;AAEA,MAAI,CAAC,aAAL,EAAoB;AAClB,WAAO,mBAAmB,CAAC,aAAD,EAAgB,YAAhB,CAA1B;AACD;;AAED,QAAM,IAAI,GAAG,cAAA,CAAA,WAAA,CAAY,EAAZ,EAAgB,QAAhB,CAAyB,KAAzB,CAAb;AACA,QAAM,OAAO,GAAG;AACd,IAAA,aAAa,EAAE,aADD;AAEd,IAAA,MAFc;AAGd,IAAA,GAHc;AAId,IAAA,IAJc;AAKd,IAAA;AALc,GAAhB;AAOA,QAAM,KAAK,GAAG,IAAI,YAAA,CAAA,WAAJ,CAAgB,QAAhB,EAA0B,YAA1B,EAAwC,IAAxC,CAA6C,OAA7C,CAAd;AACA,SAAO,MAAM,KAAK,EAAlB;AACD;AAED;;;;;;AAIA,SAAsB,gBAAtB,CACE,UADF,EAEE,kBAFF,EAGE,gBAHF,EAG2B;;AAEzB,IAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,qBAAqB,UAAU,WAA5C;AAEA,UAAM,QAAQ,GAAG,MAAM,WAAA,CAAA,YAAA,CAAa,GAAG,UAAU,WAA1B,CAAvB;AACA,UAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,IAAT,EAAtB;AACA,UAAM,OAAO,GAAG,OAAO,CAAC,eAAxB;AACA,UAAM,KAAK,GAAG,mBAAmB,CAAC,OAAD,EAAU,kBAAV,EAA8B,UAA9B,EAA0C,gBAA1C,CAAjC;AACA,UAAM,OAAO,GAAG,MAAA,CAAA,eAAA,CAAgB,MAAA,CAAA,iBAAA,CAAkB,kBAAkB,IAC/B,kBAAkB,CAAC,MAAnB,KAA8B,EAA9B,GAAmC,IAAnC,GAA0C,EADX,CAApC,CAAhB,CAAhB;AAEA,WAAO;AACL,MAAA,UAAU,EAAE,OADP;AAEL,MAAA,8BAA8B,EAAE,OAAO,CAAC,8BAFnC;AAGL,MAAA,OAHK;AAIL,MAAA,KAJK;AAKL,MAAA,MAAM,EAAE;AALH,KAAP;AAOD,G;AAAA;;AApBD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAsBA;;;;;;;;AAOA,SAAsB,YAAtB,CAAmC,UAAnC,EAAuD,aAAvD,EAA4E;;AAC1E,UAAM,eAAe,GAAG,eAAA,CAAA,MAAA,CAAO,cAAP,CAAsB,MAAM,CAAC,IAAP,CAAY,aAAZ,EAA2B,KAA3B,CAAtB,CAAxB;AACA,UAAM,QAAQ,GAAG,MAAM,WAAA,CAAA,YAAA,CAAa,GAAG,UAAU,WAA1B,CAAvB;AACA,UAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,IAAT,EAA3B;AACA,UAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,CAArB;AACA,UAAM,OAAO,GAAG,YAAY,CAAC,eAA7B;AACA,UAAM,OAAO,GAAG,MAAA,CAAA,eAAA,CAAgB,eAAhB,CAAhB;AACA,UAAM,SAAS,GAAG,GAAG,OAAO,GAAG,OAAO,GAAtC;AACA,WAAO,SAAP;AACD,G;AAAA;;AATD,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst jsontokens_1 = require(\"jsontokens\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst keys_1 = require(\"../keys\");\nconst logger_1 = require(\"../logger\");\nconst cryptoRandom_1 = require(\"../encryption/cryptoRandom\");\nconst sha2Hash_1 = require(\"../encryption/sha2Hash\");\n/**\n * @ignore\n */\nexports.BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';\n/**\n *\n * @param filename\n * @param contents\n * @param hubConfig\n * @param contentType\n *\n * @ignore\n */\nfunction uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream', newFile = true, etag) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        logger_1.Logger.debug(`uploadToGaiaHub: uploading ${filename} to ${hubConfig.server}`);\n        const headers = {\n            'Content-Type': contentType,\n            Authorization: `bearer ${hubConfig.token}`\n        };\n        if (newFile) {\n            headers['If-None-Match'] = '*';\n        }\n        else if (etag) {\n            headers['If-Match'] = etag;\n        }\n        const response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/store/${hubConfig.address}/${filename}`, {\n            method: 'POST',\n            headers,\n            body: contents\n        });\n        if (!response.ok) {\n            throw yield utils_1.getBlockstackErrorFromResponse(response, 'Error when uploading to Gaia hub.', hubConfig);\n        }\n        const responseText = yield response.text();\n        const responseJSON = JSON.parse(responseText);\n        return responseJSON;\n    });\n}\nexports.uploadToGaiaHub = uploadToGaiaHub;\nfunction deleteFromGaiaHub(filename, hubConfig) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        logger_1.Logger.debug(`deleteFromGaiaHub: deleting ${filename} from ${hubConfig.server}`);\n        const response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/delete/${hubConfig.address}/${filename}`, {\n            method: 'DELETE',\n            headers: {\n                Authorization: `bearer ${hubConfig.token}`\n            }\n        });\n        if (!response.ok) {\n            throw yield utils_1.getBlockstackErrorFromResponse(response, 'Error deleting file from Gaia hub.', hubConfig);\n        }\n    });\n}\nexports.deleteFromGaiaHub = deleteFromGaiaHub;\n/**\n *\n * @param filename\n * @param hubConfig\n *\n * @ignore\n */\nfunction getFullReadUrl(filename, hubConfig) {\n    return Promise.resolve(`${hubConfig.url_prefix}${hubConfig.address}/${filename}`);\n}\nexports.getFullReadUrl = getFullReadUrl;\n/**\n *\n * @param challengeText\n * @param signerKeyHex\n *\n * @ignore\n */\nfunction makeLegacyAuthToken(challengeText, signerKeyHex) {\n    // only sign specific legacy auth challenges.\n    let parsedChallenge;\n    try {\n        parsedChallenge = JSON.parse(challengeText);\n    }\n    catch (err) {\n        throw new Error('Failed in parsing legacy challenge text from the gaia hub.');\n    }\n    if (parsedChallenge[0] === 'gaiahub'\n        && parsedChallenge[3] === 'blockstack_storage_please_sign') {\n        const signer = keys_1.hexStringToECPair(signerKeyHex\n            + (signerKeyHex.length === 64 ? '01' : ''));\n        const digest = sha2Hash_1.hashSha256Sync(Buffer.from(challengeText));\n        const signatureBuffer = signer.sign(digest);\n        const signatureWithHash = bitcoinjs_lib_1.script.signature.encode(signatureBuffer, bitcoinjs_lib_1.Transaction.SIGHASH_NONE);\n        // We only want the DER encoding so remove the sighash version byte at the end.\n        // See: https://github.com/bitcoinjs/bitcoinjs-lib/issues/1241#issuecomment-428062912\n        const signature = signatureWithHash.toString('hex').slice(0, -2);\n        const publickey = keys_1.getPublicKeyFromPrivate(signerKeyHex);\n        const token = Buffer.from(JSON.stringify({ publickey, signature })).toString('base64');\n        return token;\n    }\n    else {\n        throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');\n    }\n}\n/**\n *\n * @param hubInfo\n * @param signerKeyHex\n * @param hubUrl\n * @param associationToken\n *\n * @ignore\n */\nfunction makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {\n    const challengeText = hubInfo.challenge_text;\n    const handlesV1Auth = (hubInfo.latest_auth_version\n        && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1);\n    const iss = keys_1.getPublicKeyFromPrivate(signerKeyHex);\n    if (!handlesV1Auth) {\n        return makeLegacyAuthToken(challengeText, signerKeyHex);\n    }\n    const salt = cryptoRandom_1.randomBytes(16).toString('hex');\n    const payload = {\n        gaiaChallenge: challengeText,\n        hubUrl,\n        iss,\n        salt,\n        associationToken\n    };\n    const token = new jsontokens_1.TokenSigner('ES256K', signerKeyHex).sign(payload);\n    return `v1:${token}`;\n}\n/**\n *\n * @ignore\n */\nfunction connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        logger_1.Logger.debug(`connectToGaiaHub: ${gaiaHubUrl}/hub_info`);\n        const response = yield fetchUtil_1.fetchPrivate(`${gaiaHubUrl}/hub_info`);\n        const hubInfo = yield response.json();\n        const readURL = hubInfo.read_url_prefix;\n        const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);\n        const address = keys_1.ecPairToAddress(keys_1.hexStringToECPair(challengeSignerHex\n            + (challengeSignerHex.length === 64 ? '01' : '')));\n        return {\n            url_prefix: readURL,\n            max_file_upload_size_megabytes: hubInfo.max_file_upload_size_megabytes,\n            address,\n            token,\n            server: gaiaHubUrl\n        };\n    });\n}\nexports.connectToGaiaHub = connectToGaiaHub;\n/**\n *\n * @param gaiaHubUrl\n * @param appPrivateKey\n *\n * @ignore\n */\nfunction getBucketUrl(gaiaHubUrl, appPrivateKey) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const challengeSigner = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(appPrivateKey, 'hex'));\n        const response = yield fetchUtil_1.fetchPrivate(`${gaiaHubUrl}/hub_info`);\n        const responseText = yield response.text();\n        const responseJSON = JSON.parse(responseText);\n        const readURL = responseJSON.read_url_prefix;\n        const address = keys_1.ecPairToAddress(challengeSigner);\n        const bucketUrl = `${readURL}${address}/`;\n        return bucketUrl;\n    });\n}\nexports.getBucketUrl = getBucketUrl;\n//# sourceMappingURL=hub.js.map"]},"metadata":{},"sourceType":"script"}