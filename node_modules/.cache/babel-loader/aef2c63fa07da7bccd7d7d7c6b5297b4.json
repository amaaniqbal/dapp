{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst elliptic_1 = require(\"elliptic\"); // @ts-ignore\n\n\nconst asn1 = require(\"asn1.js\");\n\nconst BN = require('bn.js');\n\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n  // @ts-ignore\n  const self = this;\n  self.seq().obj(self.key('version').int(), self.key('privateKey').octstr(), self.key('parameters').explicit(0).objid().optional(), self.key('publicKey').explicit(1).bitstr().optional());\n});\nconst SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {\n  // @ts-ignore\n  const self = this;\n  self.seq().obj(self.key('algorithm').seq().obj(self.key(\"id\").objid(), self.key(\"curve\").objid()), self.key('pub').bitstr());\n});\nconst curves = {\n  secp256k1: {\n    curveParameters: [1, 3, 132, 0, 10],\n    privatePEMOptions: {\n      label: 'EC PRIVATE KEY'\n    },\n    publicPEMOptions: {\n      label: 'PUBLIC KEY'\n    },\n    curve: new elliptic_1.ec('secp256k1')\n  }\n};\n\nclass KeyEncoder {\n  constructor(options) {\n    if (typeof options === 'string') {\n      if (options !== 'secp256k1') {\n        throw new Error('Unknown curve ' + options);\n      }\n\n      options = curves[options];\n    }\n\n    this.options = options;\n    this.algorithmID = [1, 2, 840, 10045, 2, 1];\n  }\n\n  privateKeyObject(rawPrivateKey, rawPublicKey) {\n    const privateKeyObject = {\n      version: new BN(1),\n      privateKey: Buffer.from(rawPrivateKey, 'hex'),\n      parameters: this.options.curveParameters\n    };\n\n    if (rawPublicKey) {\n      privateKeyObject.publicKey = {\n        unused: 0,\n        data: Buffer.from(rawPublicKey, 'hex')\n      };\n    }\n\n    return privateKeyObject;\n  }\n\n  publicKeyObject(rawPublicKey) {\n    return {\n      algorithm: {\n        id: this.algorithmID,\n        curve: this.options.curveParameters\n      },\n      pub: {\n        unused: 0,\n        data: Buffer.from(rawPublicKey, 'hex')\n      }\n    };\n  }\n\n  encodePrivate(privateKey, originalFormat, destinationFormat) {\n    let privateKeyObject;\n    /* Parse the incoming private key and convert it to a private key object */\n\n    if (originalFormat === 'raw') {\n      if (typeof privateKey !== 'string') {\n        throw 'private key must be a string';\n      }\n\n      let keyPair = this.options.curve.keyFromPrivate(privateKey, 'hex');\n      let rawPublicKey = keyPair.getPublic('hex');\n      privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);\n    } else if (originalFormat === 'der') {\n      if (typeof privateKey !== 'string') {// do nothing\n      } else if (typeof privateKey === 'string') {\n        privateKey = Buffer.from(privateKey, 'hex');\n      } else {\n        throw 'private key must be a buffer or a string';\n      }\n\n      privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');\n    } else if (originalFormat === 'pem') {\n      if (typeof privateKey !== 'string') {\n        throw 'private key must be a string';\n      }\n\n      privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions);\n    } else {\n      throw 'invalid private key format';\n    }\n    /* Export the private key object to the desired format */\n\n\n    if (destinationFormat === 'raw') {\n      return privateKeyObject.privateKey.toString('hex');\n    } else if (destinationFormat === 'der') {\n      return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex');\n    } else if (destinationFormat === 'pem') {\n      return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions);\n    } else {\n      throw 'invalid destination format for private key';\n    }\n  }\n\n  encodePublic(publicKey, originalFormat, destinationFormat) {\n    let publicKeyObject;\n    /* Parse the incoming public key and convert it to a public key object */\n\n    if (originalFormat === 'raw') {\n      if (typeof publicKey !== 'string') {\n        throw 'public key must be a string';\n      }\n\n      publicKeyObject = this.publicKeyObject(publicKey);\n    } else if (originalFormat === 'der') {\n      if (typeof publicKey !== 'string') {// do nothing\n      } else if (typeof publicKey === 'string') {\n        publicKey = Buffer.from(publicKey, 'hex');\n      } else {\n        throw 'public key must be a buffer or a string';\n      }\n\n      publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der');\n    } else if (originalFormat === 'pem') {\n      if (typeof publicKey !== 'string') {\n        throw 'public key must be a string';\n      }\n\n      publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions);\n    } else {\n      throw 'invalid public key format';\n    }\n    /* Export the private key object to the desired format */\n\n\n    if (destinationFormat === 'raw') {\n      return publicKeyObject.pub.data.toString('hex');\n    } else if (destinationFormat === 'der') {\n      return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex');\n    } else if (destinationFormat === 'pem') {\n      return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions);\n    } else {\n      throw 'invalid destination format for public key';\n    }\n  }\n\n}\n\nexports.default = KeyEncoder;\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;","map":{"version":3,"sources":["key-encoder.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\n// @ts-ignore\nconst asn1 = require(\"asn1.js\");\nconst BN = require('bn.js');\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n    // @ts-ignore\n    const self = this;\n    self.seq().obj(self.key('version').int(), self.key('privateKey').octstr(), self.key('parameters').explicit(0).objid().optional(), self.key('publicKey').explicit(1).bitstr().optional());\n});\nconst SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {\n    // @ts-ignore\n    const self = this;\n    self.seq().obj(self.key('algorithm').seq().obj(self.key(\"id\").objid(), self.key(\"curve\").objid()), self.key('pub').bitstr());\n});\nconst curves = {\n    secp256k1: {\n        curveParameters: [1, 3, 132, 0, 10],\n        privatePEMOptions: { label: 'EC PRIVATE KEY' },\n        publicPEMOptions: { label: 'PUBLIC KEY' },\n        curve: new elliptic_1.ec('secp256k1')\n    }\n};\nclass KeyEncoder {\n    constructor(options) {\n        if (typeof options === 'string') {\n            if (options !== 'secp256k1') {\n                throw new Error('Unknown curve ' + options);\n            }\n            options = curves[options];\n        }\n        this.options = options;\n        this.algorithmID = [1, 2, 840, 10045, 2, 1];\n    }\n    privateKeyObject(rawPrivateKey, rawPublicKey) {\n        const privateKeyObject = {\n            version: new BN(1),\n            privateKey: Buffer.from(rawPrivateKey, 'hex'),\n            parameters: this.options.curveParameters\n        };\n        if (rawPublicKey) {\n            privateKeyObject.publicKey = {\n                unused: 0,\n                data: Buffer.from(rawPublicKey, 'hex')\n            };\n        }\n        return privateKeyObject;\n    }\n    publicKeyObject(rawPublicKey) {\n        return {\n            algorithm: {\n                id: this.algorithmID,\n                curve: this.options.curveParameters\n            },\n            pub: {\n                unused: 0,\n                data: Buffer.from(rawPublicKey, 'hex')\n            }\n        };\n    }\n    encodePrivate(privateKey, originalFormat, destinationFormat) {\n        let privateKeyObject;\n        /* Parse the incoming private key and convert it to a private key object */\n        if (originalFormat === 'raw') {\n            if (typeof privateKey !== 'string') {\n                throw 'private key must be a string';\n            }\n            let keyPair = this.options.curve.keyFromPrivate(privateKey, 'hex');\n            let rawPublicKey = keyPair.getPublic('hex');\n            privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);\n        }\n        else if (originalFormat === 'der') {\n            if (typeof privateKey !== 'string') {\n                // do nothing\n            }\n            else if (typeof privateKey === 'string') {\n                privateKey = Buffer.from(privateKey, 'hex');\n            }\n            else {\n                throw 'private key must be a buffer or a string';\n            }\n            privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');\n        }\n        else if (originalFormat === 'pem') {\n            if (typeof privateKey !== 'string') {\n                throw 'private key must be a string';\n            }\n            privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions);\n        }\n        else {\n            throw 'invalid private key format';\n        }\n        /* Export the private key object to the desired format */\n        if (destinationFormat === 'raw') {\n            return privateKeyObject.privateKey.toString('hex');\n        }\n        else if (destinationFormat === 'der') {\n            return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex');\n        }\n        else if (destinationFormat === 'pem') {\n            return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions);\n        }\n        else {\n            throw 'invalid destination format for private key';\n        }\n    }\n    encodePublic(publicKey, originalFormat, destinationFormat) {\n        let publicKeyObject;\n        /* Parse the incoming public key and convert it to a public key object */\n        if (originalFormat === 'raw') {\n            if (typeof publicKey !== 'string') {\n                throw 'public key must be a string';\n            }\n            publicKeyObject = this.publicKeyObject(publicKey);\n        }\n        else if (originalFormat === 'der') {\n            if (typeof publicKey !== 'string') {\n                // do nothing\n            }\n            else if (typeof publicKey === 'string') {\n                publicKey = Buffer.from(publicKey, 'hex');\n            }\n            else {\n                throw 'public key must be a buffer or a string';\n            }\n            publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der');\n        }\n        else if (originalFormat === 'pem') {\n            if (typeof publicKey !== 'string') {\n                throw 'public key must be a string';\n            }\n            publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions);\n        }\n        else {\n            throw 'invalid public key format';\n        }\n        /* Export the private key object to the desired format */\n        if (destinationFormat === 'raw') {\n            return publicKeyObject.pub.data.toString('hex');\n        }\n        else if (destinationFormat === 'der') {\n            return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex');\n        }\n        else if (destinationFormat === 'pem') {\n            return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions);\n        }\n        else {\n            throw 'invalid destination format for public key';\n        }\n    }\n}\nexports.default = KeyEncoder;\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;\n//# sourceMappingURL=key-encoder.js.map"]},"metadata":{},"sourceType":"script"}