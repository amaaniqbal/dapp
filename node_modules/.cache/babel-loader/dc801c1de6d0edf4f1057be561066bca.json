{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst queryString = require(\"query-string\");\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst logger_1 = require(\"../logger\");\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\n\n\nfunction getAuthRequestFromURL() {\n  const location = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthRequestFromURL'\n  });\n  const queryDict = queryString.parse(location.search);\n\n  if (queryDict.authRequest) {\n    return queryDict.authRequest.split(`${utils_1.BLOCKSTACK_HANDLER}:`).join('');\n  } else {\n    return null;\n  }\n}\n\nexports.getAuthRequestFromURL = getAuthRequestFromURL;\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\n\nfunction fetchAppManifest(authRequest) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    if (!authRequest) {\n      throw new Error('Invalid auth request');\n    }\n\n    const payload = jsontokens_1.decodeToken(authRequest).payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const manifestURI = payload.manifest_uri;\n\n    try {\n      logger_1.Logger.debug(`Fetching manifest from ${manifestURI}`);\n      const response = yield fetchUtil_1.fetchPrivate(manifestURI);\n      const responseText = yield response.text();\n      const responseJSON = JSON.parse(responseText);\n      return Object.assign(Object.assign({}, responseJSON), {\n        manifestURI\n      });\n    } catch (error) {\n      console.log(error);\n      throw new Error('Could not fetch manifest.json');\n    }\n  });\n}\n\nexports.fetchAppManifest = fetchAppManifest;\n/**\n * Redirect the user's browser to the app using the `redirect_uri`\n * specified in the authentication request, passing the authentication\n * response token as a query parameter.\n *\n * @param {String} authRequest  encoded and signed authentication request token\n * @param {String} authResponse encoded and signed authentication response token\n * @return {void}\n * @throws {Error} if there is no redirect uri\n * @private\n * @ignore\n */\n\nfunction redirectUserToApp(authRequest, authResponse) {\n  const payload = jsontokens_1.decodeToken(authRequest).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  let redirectURI = payload.redirect_uri;\n  logger_1.Logger.debug(redirectURI);\n\n  if (redirectURI) {\n    redirectURI = utils_1.updateQueryStringParameter(redirectURI, 'authResponse', authResponse);\n  } else {\n    throw new Error('Invalid redirect URI');\n  }\n\n  const location = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'redirectUserToApp'\n  });\n  location.href = redirectURI;\n}\n\nexports.redirectUserToApp = redirectUserToApp;","map":{"version":3,"sources":["../../src/auth/authProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst queryString = require(\"query-string\");\nconst jsontokens_1 = require(\"jsontokens\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst logger_1 = require(\"../logger\");\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\nfunction getAuthRequestFromURL() {\n    const location = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'getAuthRequestFromURL' });\n    const queryDict = queryString.parse(location.search);\n    if (queryDict.authRequest) {\n        return queryDict.authRequest.split(`${utils_1.BLOCKSTACK_HANDLER}:`).join('');\n    }\n    else {\n        return null;\n    }\n}\nexports.getAuthRequestFromURL = getAuthRequestFromURL;\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\nfunction fetchAppManifest(authRequest) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        if (!authRequest) {\n            throw new Error('Invalid auth request');\n        }\n        const payload = jsontokens_1.decodeToken(authRequest).payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        const manifestURI = payload.manifest_uri;\n        try {\n            logger_1.Logger.debug(`Fetching manifest from ${manifestURI}`);\n            const response = yield fetchUtil_1.fetchPrivate(manifestURI);\n            const responseText = yield response.text();\n            const responseJSON = JSON.parse(responseText);\n            return Object.assign(Object.assign({}, responseJSON), { manifestURI });\n        }\n        catch (error) {\n            console.log(error);\n            throw new Error('Could not fetch manifest.json');\n        }\n    });\n}\nexports.fetchAppManifest = fetchAppManifest;\n/**\n * Redirect the user's browser to the app using the `redirect_uri`\n * specified in the authentication request, passing the authentication\n * response token as a query parameter.\n *\n * @param {String} authRequest  encoded and signed authentication request token\n * @param {String} authResponse encoded and signed authentication response token\n * @return {void}\n * @throws {Error} if there is no redirect uri\n * @private\n * @ignore\n */\nfunction redirectUserToApp(authRequest, authResponse) {\n    const payload = jsontokens_1.decodeToken(authRequest).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    let redirectURI = payload.redirect_uri;\n    logger_1.Logger.debug(redirectURI);\n    if (redirectURI) {\n        redirectURI = utils_1.updateQueryStringParameter(redirectURI, 'authResponse', authResponse);\n    }\n    else {\n        throw new Error('Invalid redirect URI');\n    }\n    const location = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'redirectUserToApp' });\n    location.href = redirectURI;\n}\nexports.redirectUserToApp = redirectUserToApp;\n//# sourceMappingURL=authProvider.js.map"]},"metadata":{},"sourceType":"script"}