{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore: Could not find a declaration file for module\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst dids_1 = require(\"../dids\");\n\nconst keys_1 = require(\"../keys\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst authProvider_1 = require(\"./authProvider\");\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\n\n\nfunction doSignaturesMatchPublicKeys(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n\n    try {\n      const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);\n      const signatureVerified = tokenVerifier.verify(token);\n\n      if (signatureVerified) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\n\nfunction doPublicKeysMatchIssuer(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n  const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\n\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n  return Promise.resolve().then(() => {\n    const payload = jsontokens_1.decodeToken(token).payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    const username = payload.username;\n    const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n    return fetchUtil_1.fetchPrivate(url).then(response => response.text()).then(responseText => {\n      const responseJSON = JSON.parse(responseText);\n\n      if (responseJSON.hasOwnProperty('address')) {\n        const nameOwningAddress = responseJSON.address;\n        const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n        if (nameOwningAddress === addressFromIssuer) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    });\n  }).catch(() => false);\n}\n\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\n\nfunction isIssuanceDateValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isIssuanceDateValid = isIssuanceDateValid;\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\n\nfunction isExpirationDateValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isExpirationDateValid = isExpirationDateValid;\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\n\nfunction isManifestUriValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\n\nexports.isManifestUriValid = isManifestUriValid;\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\n\nfunction isRedirectUriValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\n\nexports.isRedirectUriValid = isRedirectUriValid;\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\n\nfunction verifyAuthRequest(token) {\n  return Promise.resolve().then(() => {\n    if (jsontokens_1.decodeToken(token).header.alg === 'none') {\n      throw new Error('Token must be signed in order to be verified');\n    }\n  }).then(() => Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)])).then(values => {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexports.verifyAuthRequest = verifyAuthRequest;\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\n\nfunction verifyAuthRequestAndLoadManifest(token) {\n  return Promise.resolve().then(() => verifyAuthRequest(token).then(valid => {\n    if (valid) {\n      return authProvider_1.fetchAppManifest(token);\n    } else {\n      return Promise.reject();\n    }\n  }));\n}\n\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\n\nfunction verifyAuthResponse(token, nameLookupURL) {\n  return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]).then(values => {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexports.verifyAuthResponse = verifyAuthResponse;","map":{"version":3,"sources":["../../src/auth/authVerification.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore: Could not find a declaration file for module\nconst jsontokens_1 = require(\"jsontokens\");\nconst dids_1 = require(\"../dids\");\nconst keys_1 = require(\"../keys\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst authProvider_1 = require(\"./authProvider\");\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\nfunction doSignaturesMatchPublicKeys(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    if (publicKeys.length === 1) {\n        const publicKey = publicKeys[0];\n        try {\n            const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);\n            const signatureVerified = tokenVerifier.verify(token);\n            if (signatureVerified) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n}\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\nfunction doPublicKeysMatchIssuer(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n    if (publicKeys.length === 1) {\n        const addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);\n        if (addressFromPublicKeys === addressFromIssuer) {\n            return true;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n    return false;\n}\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n    return Promise.resolve().then(() => {\n        const payload = jsontokens_1.decodeToken(token).payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        if (!payload.username) {\n            return true;\n        }\n        if (payload.username === null) {\n            return true;\n        }\n        if (nameLookupURL === null) {\n            return false;\n        }\n        const username = payload.username;\n        const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n        return fetchUtil_1.fetchPrivate(url)\n            .then(response => response.text())\n            .then((responseText) => {\n            const responseJSON = JSON.parse(responseText);\n            if (responseJSON.hasOwnProperty('address')) {\n                const nameOwningAddress = responseJSON.address;\n                const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n                if (nameOwningAddress === addressFromIssuer) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return false;\n            }\n        });\n    }).catch(() => false);\n}\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\nfunction isIssuanceDateValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.iat) {\n        if (typeof payload.iat !== 'number') {\n            return false;\n        }\n        const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n        if (new Date().getTime() < issuedAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexports.isIssuanceDateValid = isIssuanceDateValid;\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\nfunction isExpirationDateValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.exp) {\n        if (typeof payload.exp !== 'number') {\n            return false;\n        }\n        const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n        if (new Date().getTime() > expiresAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexports.isExpirationDateValid = isExpirationDateValid;\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nfunction isManifestUriValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexports.isManifestUriValid = isManifestUriValid;\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nfunction isRedirectUriValid(token) {\n    const payload = jsontokens_1.decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexports.isRedirectUriValid = isRedirectUriValid;\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\nfunction verifyAuthRequest(token) {\n    return Promise.resolve().then(() => {\n        if (jsontokens_1.decodeToken(token).header.alg === 'none') {\n            throw new Error('Token must be signed in order to be verified');\n        }\n    }).then(() => Promise.all([\n        isExpirationDateValid(token),\n        isIssuanceDateValid(token),\n        doSignaturesMatchPublicKeys(token),\n        doPublicKeysMatchIssuer(token),\n        isManifestUriValid(token),\n        isRedirectUriValid(token)\n    ])).then((values) => {\n        if (values.every(Boolean)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n}\nexports.verifyAuthRequest = verifyAuthRequest;\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\nfunction verifyAuthRequestAndLoadManifest(token) {\n    return Promise.resolve().then(() => verifyAuthRequest(token)\n        .then((valid) => {\n        if (valid) {\n            return authProvider_1.fetchAppManifest(token);\n        }\n        else {\n            return Promise.reject();\n        }\n    }));\n}\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\nfunction verifyAuthResponse(token, nameLookupURL) {\n    return Promise.all([\n        isExpirationDateValid(token),\n        isIssuanceDateValid(token),\n        doSignaturesMatchPublicKeys(token),\n        doPublicKeysMatchIssuer(token),\n        doPublicKeysMatchUsername(token, nameLookupURL)\n    ]).then((values) => {\n        if (values.every(Boolean)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    });\n}\nexports.verifyAuthResponse = verifyAuthResponse;\n//# sourceMappingURL=authVerification.js.map"]},"metadata":{},"sourceType":"script"}