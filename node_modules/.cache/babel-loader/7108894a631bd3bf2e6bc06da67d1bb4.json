{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64url_1 = __importDefault(require(\"base64url\"));\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nfunction createSigningInput(payload, header) {\n  const tokenParts = []; // add in the header\n\n  const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader); // add in the payload\n\n  const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload); // prepare the message\n\n  const signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  const header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nclass TokenSigner {\n  constructor(signingAlgorithm, rawPrivateKey) {\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  header(header = {}) {\n    const defaultHeader = {\n      typ: this.tokenType,\n      alg: this.cryptoClient.algorithmName\n    };\n    return Object.assign({}, defaultHeader, header);\n  }\n\n  sign(payload, expanded = false, customHeader = {}) {\n    // generate the token header\n    const header = this.header(customHeader); // prepare the message to be signed\n\n    const signingInput = createSigningInput(payload, header);\n    const signingInputHash = this.cryptoClient.createHash(signingInput); // sign the message and add in the signature\n\n    const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n    if (expanded) {\n      return {\n        'header': [base64url_1.default.encode(JSON.stringify(header))],\n        'payload': JSON.stringify(payload),\n        'signature': [signature]\n      };\n    } else {\n      return [signingInput, signature].join('.');\n    }\n  }\n\n}\n\nexports.TokenSigner = TokenSigner;","map":{"version":3,"sources":["signer.ts"],"names":[],"mappings":"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","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = __importDefault(require(\"base64url\"));\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nfunction createSigningInput(payload, header) {\n    const tokenParts = [];\n    // add in the header\n    const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n    tokenParts.push(encodedHeader);\n    // add in the payload\n    const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n    tokenParts.push(encodedPayload);\n    // prepare the message\n    const signingInput = tokenParts.join('.');\n    // return the signing input\n    return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n    const header = { typ: 'JWT', alg: 'none' };\n    return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n    constructor(signingAlgorithm, rawPrivateKey) {\n        if (!(signingAlgorithm && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw new Error('signing algorithm parameter must be a string');\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw new Error('invalid signing algorithm');\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPrivateKey = rawPrivateKey;\n    }\n    header(header = {}) {\n        const defaultHeader = { typ: this.tokenType,\n            alg: this.cryptoClient.algorithmName };\n        return Object.assign({}, defaultHeader, header);\n    }\n    sign(payload, expanded = false, customHeader = {}) {\n        // generate the token header\n        const header = this.header(customHeader);\n        // prepare the message to be signed\n        const signingInput = createSigningInput(payload, header);\n        const signingInputHash = this.cryptoClient.createHash(signingInput);\n        // sign the message and add in the signature\n        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n        if (expanded) {\n            return {\n                'header': [\n                    base64url_1.default.encode(JSON.stringify(header))\n                ],\n                'payload': JSON.stringify(payload),\n                'signature': [\n                    signature\n                ]\n            };\n        }\n        else {\n            return [signingInput, signature].join('.');\n        }\n    }\n}\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}