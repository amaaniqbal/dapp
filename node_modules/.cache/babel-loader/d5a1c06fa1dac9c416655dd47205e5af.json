{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst cryptoRandom_1 = require(\"./encryption/cryptoRandom\");\n\nconst sha2Hash_1 = require(\"./encryption/sha2Hash\");\n\nconst hashRipemd160_1 = require(\"./encryption/hashRipemd160\");\n\nconst config_1 = require(\"./config\");\n/**\n *\n * @param numberOfBytes\n *\n * @ignore\n */\n\n\nfunction getEntropy(arg) {\n  if (!arg) {\n    arg = 32;\n  }\n\n  return cryptoRandom_1.randomBytes(arg);\n}\n\nexports.getEntropy = getEntropy;\n/**\n* @ignore\n*/\n\nfunction makeECPrivateKey() {\n  const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({\n    rng: getEntropy\n  });\n  return keyPair.privateKey.toString('hex');\n}\n\nexports.makeECPrivateKey = makeECPrivateKey;\n/**\n* @ignore\n*/\n\nfunction publicKeyToAddress(publicKey) {\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160_1.hashRipemd160(sha2Hash_1.hashSha256Sync(publicKeyBuffer));\n  const result = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, bitcoinjs_lib_1.networks.bitcoin.pubKeyHash);\n  return result;\n}\n\nexports.publicKeyToAddress = publicKeyToAddress;\n/**\n* @ignore\n*/\n\nfunction getPublicKeyFromPrivate(privateKey) {\n  const privateKeyBuffer = Buffer.isBuffer(privateKey) ? privateKey : Buffer.from(privateKey, 'hex');\n  const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(privateKeyBuffer);\n  return keyPair.publicKey.toString('hex');\n}\n\nexports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;\n/**\n * Time\n * @private\n * @ignore\n */\n\nfunction hexStringToECPair(skHex) {\n  const ecPairOptions = {\n    network: config_1.config.network.layer1,\n    compressed: true\n  };\n\n  if (skHex.length === 66) {\n    if (skHex.slice(64) !== '01') {\n      throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' + 'indicates compressed key, but last byte must be == 1');\n    }\n\n    return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);\n  } else if (skHex.length === 64) {\n    ecPairOptions.compressed = false;\n    return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);\n  } else {\n    throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');\n  }\n}\n\nexports.hexStringToECPair = hexStringToECPair;\n/**\n *\n * @ignore\n */\n\nfunction ecPairToHexString(secretKey) {\n  const ecPointHex = secretKey.privateKey.toString('hex');\n\n  if (secretKey.compressed) {\n    return `${ecPointHex}01`;\n  } else {\n    return ecPointHex;\n  }\n}\n\nexports.ecPairToHexString = ecPairToHexString;\n/**\n * Creates a bitcoin address string from an ECPair\n * @private\n * @ignore\n */\n\nfunction ecPairToAddress(keyPair) {\n  const sha256 = sha2Hash_1.hashSha256Sync(keyPair.publicKey);\n  const hash160 = hashRipemd160_1.hashRipemd160(sha256);\n  return bitcoinjs_lib_1.address.toBase58Check(hash160, keyPair.network.pubKeyHash);\n}\n\nexports.ecPairToAddress = ecPairToAddress;","map":{"version":3,"sources":["../src/keys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst cryptoRandom_1 = require(\"./encryption/cryptoRandom\");\nconst sha2Hash_1 = require(\"./encryption/sha2Hash\");\nconst hashRipemd160_1 = require(\"./encryption/hashRipemd160\");\nconst config_1 = require(\"./config\");\n/**\n *\n * @param numberOfBytes\n *\n * @ignore\n */\nfunction getEntropy(arg) {\n    if (!arg) {\n        arg = 32;\n    }\n    return cryptoRandom_1.randomBytes(arg);\n}\nexports.getEntropy = getEntropy;\n/**\n* @ignore\n*/\nfunction makeECPrivateKey() {\n    const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({ rng: getEntropy });\n    return keyPair.privateKey.toString('hex');\n}\nexports.makeECPrivateKey = makeECPrivateKey;\n/**\n* @ignore\n*/\nfunction publicKeyToAddress(publicKey) {\n    const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n    const publicKeyHash160 = hashRipemd160_1.hashRipemd160(sha2Hash_1.hashSha256Sync(publicKeyBuffer));\n    const result = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, bitcoinjs_lib_1.networks.bitcoin.pubKeyHash);\n    return result;\n}\nexports.publicKeyToAddress = publicKeyToAddress;\n/**\n* @ignore\n*/\nfunction getPublicKeyFromPrivate(privateKey) {\n    const privateKeyBuffer = Buffer.isBuffer(privateKey) ? privateKey : Buffer.from(privateKey, 'hex');\n    const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(privateKeyBuffer);\n    return keyPair.publicKey.toString('hex');\n}\nexports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;\n/**\n * Time\n * @private\n * @ignore\n */\nfunction hexStringToECPair(skHex) {\n    const ecPairOptions = {\n        network: config_1.config.network.layer1,\n        compressed: true\n    };\n    if (skHex.length === 66) {\n        if (skHex.slice(64) !== '01') {\n            throw new Error('Improperly formatted private-key hex string. 66-length hex usually '\n                + 'indicates compressed key, but last byte must be == 1');\n        }\n        return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);\n    }\n    else if (skHex.length === 64) {\n        ecPairOptions.compressed = false;\n        return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);\n    }\n    else {\n        throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');\n    }\n}\nexports.hexStringToECPair = hexStringToECPair;\n/**\n *\n * @ignore\n */\nfunction ecPairToHexString(secretKey) {\n    const ecPointHex = secretKey.privateKey.toString('hex');\n    if (secretKey.compressed) {\n        return `${ecPointHex}01`;\n    }\n    else {\n        return ecPointHex;\n    }\n}\nexports.ecPairToHexString = ecPairToHexString;\n/**\n * Creates a bitcoin address string from an ECPair\n * @private\n * @ignore\n */\nfunction ecPairToAddress(keyPair) {\n    const sha256 = sha2Hash_1.hashSha256Sync(keyPair.publicKey);\n    const hash160 = hashRipemd160_1.hashRipemd160(sha256);\n    return bitcoinjs_lib_1.address.toBase58Check(hash160, keyPair.network.pubKeyHash);\n}\nexports.ecPairToAddress = ecPairToAddress;\n//# sourceMappingURL=keys.js.map"]},"metadata":{},"sourceType":"script"}