{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n/**\n  * Signs a profile token\n  * @param {Object} profile - the JSON of the profile to be signed\n  * @param {String} privateKey - the signing private key\n  * @param {Object} subject - the entity that the information is about\n  * @param {Object} issuer - the entity that is issuing the token\n  * @param {String} signingAlgorithm - the signing algorithm to use\n  * @param {Date} issuedAt - the time of issuance of the token\n  * @param {Date} expiresAt - the time of expiration of the token\n  * @returns {Object} - the signed profile token\n  *\n  */\n\n\nfunction signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = utils_1.nextYear()) {\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = {\n      publicKey\n    };\n  }\n\n  if (!issuer) {\n    issuer = {\n      publicKey\n    };\n  }\n\n  const tokenSigner = new jsontokens_1.TokenSigner(signingAlgorithm, privateKey);\n  const payload = {\n    jti: utils_1.makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\n\nexports.signProfileToken = signProfileToken;\n/**\n  * Wraps a token for a profile token file\n  * @param {String} token - the token to be wrapped\n  * @returns {Object} - including `token` and `decodedToken`\n  */\n\nfunction wrapProfileToken(token) {\n  return {\n    token,\n    decodedToken: jsontokens_1.decodeToken(token)\n  };\n}\n\nexports.wrapProfileToken = wrapProfileToken;\n/**\n  * Verifies a profile token\n  * @param {String} token - the token to be verified\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the verified, decoded profile token\n  * @throws {Error} - throws an error if token verification fails\n  */\n\nfunction verifyProfileToken(token, publicKeyOrAddress) {\n  const decodedToken = jsontokens_1.decodeToken(token);\n  const payload = decodedToken.payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  } // Inspect and verify the subject\n\n\n  if (payload.hasOwnProperty('subject')) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have a subject public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have a subject');\n  } // Inspect and verify the issuer\n\n\n  if (payload.hasOwnProperty('issuer')) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have an issuer public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have an issuer');\n  } // Inspect and verify the claim\n\n\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error('Token doesn\\'t have a claim');\n  }\n\n  const issuerPublicKey = payload.issuer.publicKey;\n  const publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');\n  const compressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: true\n  });\n  const compressedAddress = utils_1.ecPairToAddress(compressedKeyPair);\n  const uncompressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: false\n  });\n  const uncompressedAddress = utils_1.ecPairToAddress(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {// pass\n  } else if (publicKeyOrAddress === compressedAddress) {// pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {// pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new jsontokens_1.TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\nexports.verifyProfileToken = verifyProfileToken;\n/**\n  * Extracts a profile from an encoded token and optionally verifies it,\n  * if `publicKeyOrAddress` is provided.\n  * @param {String} token - the token to be extracted\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the profile extracted from the encoded token\n  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n  */\n\nfunction extractProfile(token, publicKeyOrAddress = null) {\n  let decodedToken;\n\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = jsontokens_1.decodeToken(token);\n  }\n\n  let profile = {};\n\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim;\n    }\n  }\n\n  return profile;\n}\n\nexports.extractProfile = extractProfile;","map":{"version":3,"sources":["../../src/profiles/profileTokens.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n// @ts-ignore: Could not find a declaration file for module\nconst jsontokens_1 = require(\"jsontokens\");\nconst utils_1 = require(\"../utils\");\n/**\n  * Signs a profile token\n  * @param {Object} profile - the JSON of the profile to be signed\n  * @param {String} privateKey - the signing private key\n  * @param {Object} subject - the entity that the information is about\n  * @param {Object} issuer - the entity that is issuing the token\n  * @param {String} signingAlgorithm - the signing algorithm to use\n  * @param {Date} issuedAt - the time of issuance of the token\n  * @param {Date} expiresAt - the time of expiration of the token\n  * @returns {Object} - the signed profile token\n  *\n  */\nfunction signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = utils_1.nextYear()) {\n    if (signingAlgorithm !== 'ES256K') {\n        throw new Error('Signing algorithm not supported');\n    }\n    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n    if (!subject) {\n        subject = { publicKey };\n    }\n    if (!issuer) {\n        issuer = { publicKey };\n    }\n    const tokenSigner = new jsontokens_1.TokenSigner(signingAlgorithm, privateKey);\n    const payload = {\n        jti: utils_1.makeUUID4(),\n        iat: issuedAt.toISOString(),\n        exp: expiresAt.toISOString(),\n        subject,\n        issuer,\n        claim: profile\n    };\n    return tokenSigner.sign(payload);\n}\nexports.signProfileToken = signProfileToken;\n/**\n  * Wraps a token for a profile token file\n  * @param {String} token - the token to be wrapped\n  * @returns {Object} - including `token` and `decodedToken`\n  */\nfunction wrapProfileToken(token) {\n    return {\n        token,\n        decodedToken: jsontokens_1.decodeToken(token)\n    };\n}\nexports.wrapProfileToken = wrapProfileToken;\n/**\n  * Verifies a profile token\n  * @param {String} token - the token to be verified\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the verified, decoded profile token\n  * @throws {Error} - throws an error if token verification fails\n  */\nfunction verifyProfileToken(token, publicKeyOrAddress) {\n    const decodedToken = jsontokens_1.decodeToken(token);\n    const payload = decodedToken.payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    // Inspect and verify the subject\n    if (payload.hasOwnProperty('subject')) {\n        if (!payload.subject.hasOwnProperty('publicKey')) {\n            throw new Error('Token doesn\\'t have a subject public key');\n        }\n    }\n    else {\n        throw new Error('Token doesn\\'t have a subject');\n    }\n    // Inspect and verify the issuer\n    if (payload.hasOwnProperty('issuer')) {\n        if (!payload.issuer.hasOwnProperty('publicKey')) {\n            throw new Error('Token doesn\\'t have an issuer public key');\n        }\n    }\n    else {\n        throw new Error('Token doesn\\'t have an issuer');\n    }\n    // Inspect and verify the claim\n    if (!payload.hasOwnProperty('claim')) {\n        throw new Error('Token doesn\\'t have a claim');\n    }\n    const issuerPublicKey = payload.issuer.publicKey;\n    const publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');\n    const compressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, { compressed: true });\n    const compressedAddress = utils_1.ecPairToAddress(compressedKeyPair);\n    const uncompressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, { compressed: false });\n    const uncompressedAddress = utils_1.ecPairToAddress(uncompressedKeyPair);\n    if (publicKeyOrAddress === issuerPublicKey) {\n        // pass\n    }\n    else if (publicKeyOrAddress === compressedAddress) {\n        // pass\n    }\n    else if (publicKeyOrAddress === uncompressedAddress) {\n        // pass\n    }\n    else {\n        throw new Error('Token issuer public key does not match the verifying value');\n    }\n    const tokenVerifier = new jsontokens_1.TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n    if (!tokenVerifier) {\n        throw new Error('Invalid token verifier');\n    }\n    const tokenVerified = tokenVerifier.verify(token);\n    if (!tokenVerified) {\n        throw new Error('Token verification failed');\n    }\n    return decodedToken;\n}\nexports.verifyProfileToken = verifyProfileToken;\n/**\n  * Extracts a profile from an encoded token and optionally verifies it,\n  * if `publicKeyOrAddress` is provided.\n  * @param {String} token - the token to be extracted\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the profile extracted from the encoded token\n  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n  */\nfunction extractProfile(token, publicKeyOrAddress = null) {\n    let decodedToken;\n    if (publicKeyOrAddress) {\n        decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n    }\n    else {\n        decodedToken = jsontokens_1.decodeToken(token);\n    }\n    let profile = {};\n    if (decodedToken.hasOwnProperty('payload')) {\n        const payload = decodedToken.payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        if (payload.hasOwnProperty('claim')) {\n            profile = payload.claim;\n        }\n    }\n    return profile;\n}\nexports.extractProfile = extractProfile;\n//# sourceMappingURL=profileTokens.js.map"]},"metadata":{},"sourceType":"script"}