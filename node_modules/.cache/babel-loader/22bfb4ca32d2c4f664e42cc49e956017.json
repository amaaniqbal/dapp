{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst queryString = require(\"query-string\");\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst authVerification_1 = require(\"./authVerification\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst dids_1 = require(\"../dids\");\n\nconst errors_1 = require(\"../errors\");\n\nconst authMessages_1 = require(\"./authMessages\");\n\nconst authConstants_1 = require(\"./authConstants\");\n\nconst profileTokens_1 = require(\"../profiles/profileTokens\");\n\nconst userSession_1 = require(\"./userSession\");\n\nconst config_1 = require(\"../config\");\n\nconst logger_1 = require(\"../logger\");\n\nconst protocolEchoDetection_1 = require(\"./protocolEchoDetection\");\n\nconst protocolLaunch_1 = require(\"./protocolLaunch\");\n\nconst keys_1 = require(\"../keys\");\n\nconst DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org'\n};\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Check if a user is currently signed in.\n * @return {Boolean} `true` if the user is signed in, `false` if not.\n */\n\nfunction isUserSignedIn() {\n  console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isUserSignedIn().');\n  const userSession = new userSession_1.UserSession();\n  return userSession.isUserSignedIn();\n}\n\nexports.isUserSignedIn = isUserSignedIn;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\n\nfunction redirectToSignIn(redirectURI, manifestURI, scopes) {\n  console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method redirectToSignIn().');\n  const authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);\n  return redirectToSignInWithAuthRequest(authRequest);\n}\n\nexports.redirectToSignIn = redirectToSignIn;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isSignInPending]] instead.\n *\n * Check if there is a authentication request that hasn't been handled.\n *\n * Also checks for a protocol echo reply (which if detected then the page\n * will be automatically redirected after this call).\n *\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\n\nfunction isSignInPending() {\n  try {\n    const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n    if (isProtocolEcho) {\n      logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n      return true;\n    }\n  } catch (error) {\n    logger_1.Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n  }\n\n  return !!getAuthResponseToken();\n}\n\nexports.isSignInPending = isSignInPending;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getAuthResponseToken]] instead.\n *\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\n\nfunction getAuthResponseToken() {\n  const search = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthResponseToken'\n  }).search;\n  const queryDict = queryString.parse(search);\n  return queryDict.authResponse ? queryDict.authResponse : '';\n}\n\nexports.getAuthResponseToken = getAuthResponseToken;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.loadUserData]] instead.\n *\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n*/\n\nfunction loadUserData() {\n  console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method loadUserData().');\n  const userSession = new userSession_1.UserSession();\n  return userSession.loadUserData();\n}\n\nexports.loadUserData = loadUserData;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.signUserOut]] instead.\n *\n * Sign the user out and optionally redirect to given location.\n * @param  redirectURL\n * Location to redirect user to after sign out.\n * Only used in environments with `window` available\n */\n\nfunction signUserOut(redirectURL, caller) {\n  const userSession = caller || new userSession_1.UserSession();\n  userSession.store.deleteSessionData();\n\n  if (redirectURL) {\n    utils_1.getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'signUserOut'\n    }).href = redirectURL;\n  }\n}\n\nexports.signUserOut = signUserOut;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.redirectToSignInWithAuthRequest]] instead.\n *\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\n\nfunction redirectToSignInWithAuthRequest(authRequest, blockstackIDHost = authConstants_1.DEFAULT_BLOCKSTACK_HOST) {\n  authRequest = authRequest || authMessages_1.makeAuthRequest();\n  const httpsURI = `${blockstackIDHost}?authRequest=${authRequest}`;\n  const {\n    navigator,\n    location\n  } = utils_1.getGlobalObjects(['navigator', 'location'], {\n    throwIfUnavailable: true,\n    usageDesc: 'redirectToSignInWithAuthRequest'\n  }); // If they're on a mobile OS, always redirect them to HTTPS site\n\n  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {\n    logger_1.Logger.info('detected mobile OS, sending to https');\n    location.href = httpsURI;\n    return;\n  }\n\n  function successCallback() {\n    logger_1.Logger.info('protocol handler detected'); // The detection function should open the link for us\n  }\n\n  function failCallback() {\n    logger_1.Logger.warn('protocol handler not detected');\n    location.href = httpsURI;\n  }\n\n  protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);\n}\n\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.handlePendingSignIn]] instead.\n *\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\n\nfunction handlePendingSignIn(nameLookupURL = '', authResponseToken = getAuthResponseToken(), transitKey, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    try {\n      const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n      if (isProtocolEcho) {\n        const msg = 'handlePendingSignIn called while protocolEchoReply was detected, and ' + 'the page is about to redirect. This function will resolve with an error after ' + 'several seconds, if the page was not redirected for some reason.';\n        logger_1.Logger.info(msg);\n        return new Promise((_resolve, reject) => {\n          setTimeout(() => {\n            logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');\n            reject(msg);\n          }, 3000);\n        });\n      }\n    } catch (error) {\n      logger_1.Logger.error(`Error checking for protocol echo reply handlePendingSignIn: ${error}`);\n    }\n\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    }\n\n    const sessionData = caller.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new errors_1.LoginFailedError('Existing user session found.');\n    }\n\n    if (!transitKey) {\n      transitKey = caller.store.getSessionData().transitKey;\n    }\n\n    if (!nameLookupURL) {\n      let coreNode = caller.appConfig && caller.appConfig.coreNode;\n\n      if (!coreNode) {\n        coreNode = config_1.config.network.blockstackAPIUrl;\n      }\n\n      const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n      if (typeof tokenPayload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n      }\n\n      if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n        // override globally\n        logger_1.Logger.info(`Overriding ${config_1.config.network.blockstackAPIUrl} ` + `with ${tokenPayload.blockstackAPIUrl}`); // TODO: this config is never saved so the user node preference \n        // is not respected in later sessions..\n\n        config_1.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;\n        coreNode = tokenPayload.blockstackAPIUrl;\n      }\n\n      nameLookupURL = `${coreNode}${authConstants_1.NAME_LOOKUP_PATH}`;\n    }\n\n    const isValid = yield authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);\n\n    if (!isValid) {\n      throw new errors_1.LoginFailedError('Invalid authentication response.');\n    }\n\n    const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    } // TODO: real version handling\n\n\n    let appPrivateKey = tokenPayload.private_key;\n    let coreSessionToken = tokenPayload.core_token;\n\n    if (utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = yield authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);\n          } catch (e) {\n            logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n\n            try {\n              keys_1.hexStringToECPair(tokenPayload.private_key);\n            } catch (ecPairError) {\n              throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            }\n          }\n        }\n\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = yield authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);\n          } catch (e) {\n            logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n      }\n    }\n\n    let hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken;\n\n    if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n      hubUrl = tokenPayload.hubUrl;\n    }\n\n    if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n      gaiaAssociationToken = tokenPayload.associationToken;\n    }\n\n    const userData = {\n      username: tokenPayload.username,\n      profile: tokenPayload.profile,\n      email: tokenPayload.email,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      coreNode: tokenPayload.blockstackAPIUrl,\n      gaiaAssociationToken\n    };\n    const profileURL = tokenPayload.profile_url;\n\n    if (!userData.profile && profileURL) {\n      const response = yield fetchUtil_1.fetchPrivate(profileURL);\n\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = yield response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        const profile = profileTokens_1.extractProfile(wrappedProfile[0].token);\n        userData.profile = profile;\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    caller.store.setSessionData(sessionData);\n    return userData;\n  });\n}\n\nexports.handlePendingSignIn = handlePendingSignIn;","map":{"version":3,"sources":["../../src/auth/authApp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst queryString = require(\"query-string\");\nconst jsontokens_1 = require(\"jsontokens\");\nconst authVerification_1 = require(\"./authVerification\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst dids_1 = require(\"../dids\");\nconst errors_1 = require(\"../errors\");\nconst authMessages_1 = require(\"./authMessages\");\nconst authConstants_1 = require(\"./authConstants\");\nconst profileTokens_1 = require(\"../profiles/profileTokens\");\nconst userSession_1 = require(\"./userSession\");\nconst config_1 = require(\"../config\");\nconst logger_1 = require(\"../logger\");\nconst protocolEchoDetection_1 = require(\"./protocolEchoDetection\");\nconst protocolLaunch_1 = require(\"./protocolLaunch\");\nconst keys_1 = require(\"../keys\");\nconst DEFAULT_PROFILE = {\n    '@type': 'Person',\n    '@context': 'http://schema.org'\n};\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Check if a user is currently signed in.\n * @return {Boolean} `true` if the user is signed in, `false` if not.\n */\nfunction isUserSignedIn() {\n    console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in '\n        + 'the next major release of blockstack.js. Create an instance of UserSession and call the '\n        + 'instance method isUserSignedIn().');\n    const userSession = new userSession_1.UserSession();\n    return userSession.isUserSignedIn();\n}\nexports.isUserSignedIn = isUserSignedIn;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\nfunction redirectToSignIn(redirectURI, manifestURI, scopes) {\n    console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the '\n        + 'next major release of blockstack.js. Create an instance of UserSession and call the '\n        + 'instance method redirectToSignIn().');\n    const authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);\n    return redirectToSignInWithAuthRequest(authRequest);\n}\nexports.redirectToSignIn = redirectToSignIn;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isSignInPending]] instead.\n *\n * Check if there is a authentication request that hasn't been handled.\n *\n * Also checks for a protocol echo reply (which if detected then the page\n * will be automatically redirected after this call).\n *\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\nfunction isSignInPending() {\n    try {\n        const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n        if (isProtocolEcho) {\n            logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n            return true;\n        }\n    }\n    catch (error) {\n        logger_1.Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n    return !!getAuthResponseToken();\n}\nexports.isSignInPending = isSignInPending;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getAuthResponseToken]] instead.\n *\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\nfunction getAuthResponseToken() {\n    const search = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'getAuthResponseToken' }).search;\n    const queryDict = queryString.parse(search);\n    return queryDict.authResponse ? queryDict.authResponse : '';\n}\nexports.getAuthResponseToken = getAuthResponseToken;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.loadUserData]] instead.\n *\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n*/\nfunction loadUserData() {\n    console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the '\n        + 'next major release of blockstack.js. Create an instance of UserSession and call the '\n        + 'instance method loadUserData().');\n    const userSession = new userSession_1.UserSession();\n    return userSession.loadUserData();\n}\nexports.loadUserData = loadUserData;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.signUserOut]] instead.\n *\n * Sign the user out and optionally redirect to given location.\n * @param  redirectURL\n * Location to redirect user to after sign out.\n * Only used in environments with `window` available\n */\nfunction signUserOut(redirectURL, caller) {\n    const userSession = caller || new userSession_1.UserSession();\n    userSession.store.deleteSessionData();\n    if (redirectURL) {\n        utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'signUserOut' }).href = redirectURL;\n    }\n}\nexports.signUserOut = signUserOut;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.redirectToSignInWithAuthRequest]] instead.\n *\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\nfunction redirectToSignInWithAuthRequest(authRequest, blockstackIDHost = authConstants_1.DEFAULT_BLOCKSTACK_HOST) {\n    authRequest = authRequest || authMessages_1.makeAuthRequest();\n    const httpsURI = `${blockstackIDHost}?authRequest=${authRequest}`;\n    const { navigator, location } = utils_1.getGlobalObjects(['navigator', 'location'], { throwIfUnavailable: true, usageDesc: 'redirectToSignInWithAuthRequest' });\n    // If they're on a mobile OS, always redirect them to HTTPS site\n    if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {\n        logger_1.Logger.info('detected mobile OS, sending to https');\n        location.href = httpsURI;\n        return;\n    }\n    function successCallback() {\n        logger_1.Logger.info('protocol handler detected');\n        // The detection function should open the link for us\n    }\n    function failCallback() {\n        logger_1.Logger.warn('protocol handler not detected');\n        location.href = httpsURI;\n    }\n    protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);\n}\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.handlePendingSignIn]] instead.\n *\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\nfunction handlePendingSignIn(nameLookupURL = '', authResponseToken = getAuthResponseToken(), transitKey, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n            const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n            if (isProtocolEcho) {\n                const msg = 'handlePendingSignIn called while protocolEchoReply was detected, and '\n                    + 'the page is about to redirect. This function will resolve with an error after '\n                    + 'several seconds, if the page was not redirected for some reason.';\n                logger_1.Logger.info(msg);\n                return new Promise((_resolve, reject) => {\n                    setTimeout(() => {\n                        logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');\n                        reject(msg);\n                    }, 3000);\n                });\n            }\n        }\n        catch (error) {\n            logger_1.Logger.error(`Error checking for protocol echo reply handlePendingSignIn: ${error}`);\n        }\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        const sessionData = caller.store.getSessionData();\n        if (sessionData.userData) {\n            throw new errors_1.LoginFailedError('Existing user session found.');\n        }\n        if (!transitKey) {\n            transitKey = caller.store.getSessionData().transitKey;\n        }\n        if (!nameLookupURL) {\n            let coreNode = caller.appConfig && caller.appConfig.coreNode;\n            if (!coreNode) {\n                coreNode = config_1.config.network.blockstackAPIUrl;\n            }\n            const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n            if (typeof tokenPayload === 'string') {\n                throw new Error('Unexpected token payload type of string');\n            }\n            if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0')\n                && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n                // override globally\n                logger_1.Logger.info(`Overriding ${config_1.config.network.blockstackAPIUrl} `\n                    + `with ${tokenPayload.blockstackAPIUrl}`);\n                // TODO: this config is never saved so the user node preference \n                // is not respected in later sessions..\n                config_1.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;\n                coreNode = tokenPayload.blockstackAPIUrl;\n            }\n            nameLookupURL = `${coreNode}${authConstants_1.NAME_LOOKUP_PATH}`;\n        }\n        const isValid = yield authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);\n        if (!isValid) {\n            throw new errors_1.LoginFailedError('Invalid authentication response.');\n        }\n        const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n        if (typeof tokenPayload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        // TODO: real version handling\n        let appPrivateKey = tokenPayload.private_key;\n        let coreSessionToken = tokenPayload.core_token;\n        if (utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {\n            if (transitKey !== undefined && transitKey != null) {\n                if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n                    try {\n                        appPrivateKey = yield authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);\n                    }\n                    catch (e) {\n                        logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n                        try {\n                            keys_1.hexStringToECPair(tokenPayload.private_key);\n                        }\n                        catch (ecPairError) {\n                            throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means'\n                                + ' that the transit key has changed during login.');\n                        }\n                    }\n                }\n                if (coreSessionToken !== undefined && coreSessionToken !== null) {\n                    try {\n                        coreSessionToken = yield authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);\n                    }\n                    catch (e) {\n                        logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n                    }\n                }\n            }\n            else {\n                throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit'\n                    + ' key, and none found.');\n            }\n        }\n        let hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n        let gaiaAssociationToken;\n        if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0')\n            && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n            hubUrl = tokenPayload.hubUrl;\n        }\n        if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0')\n            && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n            gaiaAssociationToken = tokenPayload.associationToken;\n        }\n        const userData = {\n            username: tokenPayload.username,\n            profile: tokenPayload.profile,\n            email: tokenPayload.email,\n            decentralizedID: tokenPayload.iss,\n            identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),\n            appPrivateKey,\n            coreSessionToken,\n            authResponseToken,\n            hubUrl,\n            coreNode: tokenPayload.blockstackAPIUrl,\n            gaiaAssociationToken\n        };\n        const profileURL = tokenPayload.profile_url;\n        if (!userData.profile && profileURL) {\n            const response = yield fetchUtil_1.fetchPrivate(profileURL);\n            if (!response.ok) { // return blank profile if we fail to fetch\n                userData.profile = Object.assign({}, DEFAULT_PROFILE);\n            }\n            else {\n                const responseText = yield response.text();\n                const wrappedProfile = JSON.parse(responseText);\n                const profile = profileTokens_1.extractProfile(wrappedProfile[0].token);\n                userData.profile = profile;\n            }\n        }\n        else {\n            userData.profile = tokenPayload.profile;\n        }\n        sessionData.userData = userData;\n        caller.store.setSessionData(sessionData);\n        return userData;\n    });\n}\nexports.handlePendingSignIn = handlePendingSignIn;\n//# sourceMappingURL=authApp.js.map"]},"metadata":{},"sourceType":"script"}