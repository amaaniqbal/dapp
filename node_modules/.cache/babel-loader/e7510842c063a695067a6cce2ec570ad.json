{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst utils_1 = require(\"./utils\");\n\nconst skeletons_1 = require(\"./skeletons\");\n\nconst config_1 = require(\"../config\");\n\nconst errors_1 = require(\"../errors\");\n\nconst signers_1 = require(\"./signers\");\n\nconst dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\nconst dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';\n/**\n* @ignore\n*/\n\nfunction addOwnerInput(utxos, ownerAddress, txB, addChangeOut = true) {\n  // add an owner UTXO and a change out.\n  if (utxos.length <= 0) {\n    throw new Error('Owner has no UTXOs for UPDATE.');\n  }\n\n  utxos.sort((a, b) => a.value - b.value);\n  const ownerUTXO = utxos[0];\n  const ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);\n\n  if (addChangeOut) {\n    txB.addOutput(ownerAddress, ownerUTXO.value);\n  }\n\n  return {\n    index: ownerInput,\n    value: ownerUTXO.value\n  };\n}\n/**\n* @ignore\n*/\n\n\nfunction fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts, changeIndex = null) {\n  // change index for the payer.\n  if (changeIndex === null) {\n    changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);\n  } // fund the transaction fee.\n\n\n  const txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;\n  const outAmounts = utils_1.sumOutputValues(txB);\n  const change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);\n  const txInner = utils_1.getTransactionInsideBuilder(txB);\n  const txOut = txInner.outs[changeIndex];\n  txOut.value += change;\n  return txB;\n}\n/**\n* @ignore\n*/\n\n\nfunction returnTransactionHex(txB, buildIncomplete = false) {\n  if (buildIncomplete) {\n    return txB.buildIncomplete().toHex();\n  } else {\n    return txB.build().toHex();\n  }\n}\n/**\n* @ignore\n*/\n\n\nfunction getTransactionSigner(input) {\n  if (typeof input === 'string') {\n    return signers_1.PubkeyHashSigner.fromHexString(input);\n  } else {\n    return input;\n  }\n}\n/**\n * Estimates cost of a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to preorder\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const preorderPromise = network.getNamePrice(fullyQualifiedName).then(namePrice => skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress));\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(([feeRate, preorderTX]) => {\n    const outputsValue = utils_1.sumOutputValues(preorderTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name\n * @param {String} paymentAddress - the address funding the register\n * @param {Boolean} includingZonefile - whether or not we will broadcast\n *    a zonefile hash as part  of the register\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the register.\n * @private\n */\n\n\nfunction estimateRegister(fullyQualifiedName, registerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  let valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  const registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(registerTX); // 1 additional output for payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String} ownerAddress - the owner of the name\n * @param {String} paymentAddress - the address funding the update\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the update.\n * @private\n */\n\n\nfunction estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(updateTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\n\n\nfunction estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(transferTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to renew\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash\n      in the renewal operation\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\n\n\nfunction estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  let valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  const renewalPromise = network.getNamePrice(fullyQualifiedName).then(namePrice => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash));\n  return Promise.all([network.getFeeRate(), renewalPromise]).then(([feeRate, renewalTX]) => {\n    const outputsValue = utils_1.sumOutputValues(renewalTX); // 1 additional input for the owner\n    // and renewal skeleton includes all outputs for owner change, but not for payer change.\n\n    const txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);\n    return txFee + outputsValue - 5500; // don't count the dust change for old owner.\n  });\n}\n/**\n * Estimates cost of a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress  the address funding the revoke\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund the\n *    revoke.\n * @private\n */\n\n\nfunction estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n  return Promise.all([network.getFeeRate()]).then(([feeRate]) => {\n    const outputsValue = utils_1.sumOutputValues(revokeTX); // 1 additional input for owner\n    // 1 additional output for payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to preorder\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const preorderPromise = network.getNamespacePrice(namespaceID).then(namespacePrice => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice));\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(([feeRate, preorderTX]) => {\n    const outputsValue = utils_1.sumOutputValues(preorderTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a namesapce reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace\n *    (this must have been passed as 'revealAddress' to a prior namespace\n *    preorder)\n * @param {String} paymentAddress - the address that pays for this transaction\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *    fund the reveal.  This includes a 5500 satoshi dust output for the\n *    preorder.  Even though this is a change output, the payer must have\n *    enough funds to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimateNamespaceReveal(namespace, revealAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(revealTX); // 1 additional output for payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a namespace-ready transaction for a namespace\n * @param {String} namespaceID - the namespace to ready\n * @param {Number} revealUtxos - the number of UTXOs we expect will\n *  be required from the reveal address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this namespacey-ready transaction.\n * @private\n */\n\n\nfunction estimateNamespaceReady(namespaceID, revealUtxos = 1) {\n  const network = config_1.config.network;\n  const readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(readyTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a name-import transaction\n * @param {String} name - the fully-qualified name\n * @param {String} recipientAddr - the recipient\n * @param {String} zonefileHash - the zone file hash\n * @param {Number} importUtxos - the number of UTXOs we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this name-import transaction\n * @private\n */\n\n\nfunction estimateNameImport(name, recipientAddr, zonefileHash, importUtxos = 1) {\n  const network = config_1.config.network;\n  const importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(importTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of an announce transaction\n * @param {String} messageHash - the hash of the message\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this announce transaction\n * @private\n */\n\n\nfunction estimateAnnounce(messageHash, senderUtxos = 1) {\n  const network = config_1.config.network;\n  const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(announceTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a token-transfer transaction\n * @param {String} recipientAddress - the recipient of the tokens\n * @param {String} tokenType - the type of token to spend\n * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens\n *   to spend\n * @param {String} scratchArea - an arbitrary string to store with the transaction\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @param {Number} additionalOutputs - the number of outputs we expect to add beyond\n *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this token-transfer transaction\n * @private\n */\n\n\nfunction estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderUtxos = 1, additionalOutputs = 1) {\n  const network = config_1.config.network;\n  const tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(tokenTransferTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Generates a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to pre-order\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction or a transaction signer object\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const namespace = fullyQualifiedName.split('.').pop();\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(preorderAddress => {\n    const preorderPromise = Promise.all([network.getConsensusHash(), network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(([consensusHash, namePrice, burnAddress]) => skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress));\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(([utxos, feeRate, preorderSkeleton]) => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n  });\n}\n/**\n * Generates an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of the\n *    owner key, or a transaction signer object. This will provide one\n *    UTXO input, and also recieve a dust output.\n * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a\n *    transaction signer object, of the private key used to fund the\n *    transaction's txfees\n * @param {String} zonefile - the zonefile data to update (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - if given, this is the hash to store (instead of\n *    zonefile).  zonefile will be ignored if this is given.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile, valueHash = '', buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!valueHash && !zonefile) {\n    return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n  }\n\n  if (valueHash.length === 0) {\n    if (!zonefile) {\n      return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n    }\n\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (valueHash.length !== 40) {\n    return Promise.reject(new Error(`Invalid valueHash ${valueHash}`));\n  }\n\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const txPromise = network.getConsensusHash().then(consensusHash => skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash)).then(updateTX => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(updateTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name (this\n *    must have been passed as the 'destinationAddress' in the preorder transaction)\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key (or a TransactionSigner object) used to fund the\n *    transaction (this *must* be the same as the payment address used\n *    to fund the preorder)\n * @param {String} zonefile - the zonefile data to include (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - the hash of the zone file data to include.\n *    It will be used instead of zonefile, if given\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (!!valueHash && valueHash.length !== 40) {\n    return Promise.reject(new Error(`Invalid zonefile hash ${valueHash}`));\n  }\n\n  const registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);\n  txB.setVersion(1);\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, paymentKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name.\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {Boolean} keepZonefile - if true, then preserve the name's zone file\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, keepZonefile = false, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const txPromise = network.getConsensusHash().then(consensusHash => skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile)).then(transferTX => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(transferTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n    const txPromise = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(revokeTX, network.layer1);\n    txPromise.setVersion(1);\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a renewal transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name after renewal\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the renewal (or a TransactionSigner\n *    object)\n * @param {String} zonefile - the zonefile data to include, if given (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the RENEWAL propagates.\n * @param {String} valueHash - the raw zone file hash to include (this will be used\n *    instead of zonefile, if given).\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  }\n\n  const namespace = fullyQualifiedName.split('.').pop();\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const txPromise = Promise.all([network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(([namePrice, burnAddress]) => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash)).then(tx => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tx, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);\n      const txInner = utils_1.getTransactionInsideBuilder(txB);\n      const ownerOutput = txInner.outs[2];\n      const ownerOutputAddr = bitcoinjs_lib_1.address.fromOutputScript(ownerOutput.script, network.layer1);\n\n      if (ownerOutputAddr !== ownerAddress) {\n        return Promise.reject(new Error(`Original owner ${ownerAddress} should have an output at ` + `index 2 in transaction was ${ownerOutputAddr}`));\n      }\n\n      ownerOutput.value = ownerInput.value;\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to pre-order\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n *\n * @ignore\n */\n\n\nfunction makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(preorderAddress => {\n    const preorderPromise = Promise.all([network.getConsensusHash(), network.getNamespacePrice(namespaceID)]).then(([consensusHash, namespacePrice]) => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice));\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(([utxos, feeRate, preorderSkeleton]) => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n  });\n}\n/**\n * Generates a namespace reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace (this\n *   must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string (or\n *   a TransactionSigner object) of the private key used to fund the\n *   transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *   this function *does not* perform the requisite safety checks -- please see\n *   the safety module for those.\n * @private\n */\n\n\nfunction makeNamespaceReveal(namespace, revealAddress, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!namespace.check()) {\n    return Promise.reject(new Error('Invalid namespace'));\n  }\n\n  const namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(preorderAddress => Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceRevealTX, network.layer1);\n    txB.setVersion(1);\n    const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, paymentKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace ready transaction for a namespace\n * @param {String} namespaceID - the namespace to launch\n * @param {String | TransactionSigner} revealKeyIn - the private key\n *  of the 'revealAddress' used to reveal the namespace\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *  indicating whether the function should attempt to return an unsigned (or not fully signed)\n *  transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *  this function *does not* perform the requisite safety checks -- please see\n *  the safety module for those.\n * @private\n */\n\n\nfunction makeNamespaceReady(namespaceID, revealKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  const revealKey = getTransactionSigner(revealKeyIn);\n  return revealKey.getAddress().then(revealAddress => Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);\n    txB.setVersion(1);\n    const signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, revealKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a name import transaction for a namespace\n * @param {String} name - the name to import\n * @param {String} recipientAddr - the address to receive the name\n * @param {String} zonefileHash - the hash of the zonefile to give this name\n * @param {String | TransactionSigner} importerKeyIn - the private key\n * that pays for the import\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see\n * the safety module for those.\n * @private\n */\n\n\nfunction makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  const importerKey = getTransactionSigner(importerKeyIn);\n  return importerKey.getAddress().then(importerAddress => Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);\n    const signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, importerKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates an announce transaction\n * @param {String} messageHash - the hash of the message to send.  Should be\n *  an already-announced zone file hash\n * @param {String | TransactionSigner} senderKeyIn - the private key\n *  that pays for the transaction.  Should be the key that owns the\n *  name that the message recipients subscribe to\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\n\n\nfunction makeAnnounce(messageHash, senderKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  const senderKey = getTransactionSigner(senderKeyIn);\n  return senderKey.getAddress().then(senderAddress => Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(announceTX, network.layer1);\n    const signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, senderKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a token-transfer transaction\n * @param {String} recipientAddress - the address to receive the tokens\n * @param {String} tokenType - the type of tokens to send\n * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of\n *  tokens to send\n * @param {String} scratchArea - an arbitrary string to include with the transaction\n * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send\n *   the tokens\n * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund\n *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to\n *   fund with sender key.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * This function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\n\n\nfunction makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const separateFunder = !!btcFunderKeyIn;\n  const senderKey = getTransactionSigner(senderKeyIn);\n  const btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;\n  const txPromise = network.getConsensusHash().then(consensusHash => skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea));\n  return Promise.all([senderKey.getAddress(), btcKey.getAddress()]).then(([senderAddress, btcAddress]) => {\n    const btcUTXOsPromise = separateFunder ? network.getUTXOs(btcAddress) : Promise.resolve([]);\n    return Promise.all([network.getUTXOs(senderAddress), btcUTXOsPromise, network.getFeeRate(), txPromise]).then(([senderUTXOs, btcUTXOs, feeRate, tokenTransferTX]) => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);\n\n      if (separateFunder) {\n        const payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);\n        const signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);\n        return utils_1.signInputs(signingTxB, btcKey, [{\n          index: payerInput.index,\n          signer: senderKey\n        }]);\n      } else {\n        const signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);\n        return utils_1.signInputs(signingTxB, senderKey);\n      }\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a bitcoin spend to a specified address. This will fund up to `amount`\n *   of satoshis from the payer's UTXOs. It will generate a change output if and only\n *   if the amount of leftover change is *greater* than the additional fees associated\n *   with the extra output. If the requested amount is not enough to fund the transaction's\n *   associated fees, then this will reject with a InvalidAmountError\n *\n * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated\n *   with their own input will not be included.\n *\n * If you specify an amount > the total balance of the payer address, then this will\n *   generate a maximum spend transaction\n *\n * @param {String} destinationAddress - the address to receive the bitcoin payment\n * @param {String | TransactionSigner} paymentKeyIn - the private key\n *    used to fund the bitcoin spend\n * @param {number} amount - the amount in satoshis for the payment address to\n *    spend in this transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * @private\n */\n\n\nfunction makeBitcoinSpend(destinationAddress, paymentKeyIn, amount, buildIncomplete = false) {\n  if (amount <= 0) {\n    return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));\n  }\n\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = new bitcoinjs_lib_1.TransactionBuilder(network.layer1);\n    txB.setVersion(1);\n    const destinationIndex = txB.addOutput(destinationAddress, 0); // will add utxos up to _amount_ and return the amount of leftover _change_\n\n    let change;\n\n    try {\n      change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);\n    } catch (err) {\n      if (err.name === 'NotEnoughFundsError') {\n        // actual amount funded = amount requested - remainder\n        amount -= err.leftToFund;\n        change = 0;\n      } else {\n        throw err;\n      }\n    }\n\n    let feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);\n    const feeForChange = feeRate * utils_1.estimateTXBytes(txB, 0, 1) - feesToPay; // it's worthwhile to add a change output\n\n    if (change > feeForChange) {\n      feesToPay += feeForChange;\n      txB.addOutput(paymentAddress, change);\n    } // now let's compute how much output is leftover once we pay the fees.\n\n\n    const outputAmount = amount - feesToPay;\n\n    if (outputAmount < utils_1.DUST_MINIMUM) {\n      throw new errors_1.InvalidAmountError(feesToPay, amount);\n    } // we need to manually set the output values now\n\n\n    const txInner = utils_1.getTransactionInsideBuilder(txB);\n    const txOut = txInner.outs[destinationIndex];\n    txOut.value = outputAmount; // ready to sign.\n\n    return utils_1.signInputs(txB, paymentKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n\nexports.transactions = {\n  makeRenewal,\n  makeUpdate,\n  makePreorder,\n  makeRegister,\n  makeTransfer,\n  makeRevoke,\n  makeNamespacePreorder,\n  makeNamespaceReveal,\n  makeNamespaceReady,\n  makeBitcoinSpend,\n  makeNameImport,\n  makeAnnounce,\n  makeTokenTransfer,\n  BlockstackNamespace: skeletons_1.BlockstackNamespace,\n  estimatePreorder,\n  estimateRegister,\n  estimateTransfer,\n  estimateUpdate,\n  estimateRenewal,\n  estimateRevoke,\n  estimateNamespacePreorder,\n  estimateNamespaceReveal,\n  estimateNamespaceReady,\n  estimateNameImport,\n  estimateAnnounce,\n  estimateTokenTransfer\n};","map":{"version":3,"sources":["../../src/operations/txbuild.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst utils_1 = require(\"./utils\");\nconst skeletons_1 = require(\"./skeletons\");\nconst config_1 = require(\"../config\");\nconst errors_1 = require(\"../errors\");\nconst signers_1 = require(\"./signers\");\nconst dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\nconst dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';\n/**\n* @ignore\n*/\nfunction addOwnerInput(utxos, ownerAddress, txB, addChangeOut = true) {\n    // add an owner UTXO and a change out.\n    if (utxos.length <= 0) {\n        throw new Error('Owner has no UTXOs for UPDATE.');\n    }\n    utxos.sort((a, b) => a.value - b.value);\n    const ownerUTXO = utxos[0];\n    const ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);\n    if (addChangeOut) {\n        txB.addOutput(ownerAddress, ownerUTXO.value);\n    }\n    return { index: ownerInput, value: ownerUTXO.value };\n}\n/**\n* @ignore\n*/\nfunction fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts, changeIndex = null) {\n    // change index for the payer.\n    if (changeIndex === null) {\n        changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);\n    }\n    // fund the transaction fee.\n    const txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;\n    const outAmounts = utils_1.sumOutputValues(txB);\n    const change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);\n    const txInner = utils_1.getTransactionInsideBuilder(txB);\n    const txOut = txInner.outs[changeIndex];\n    txOut.value += change;\n    return txB;\n}\n/**\n* @ignore\n*/\nfunction returnTransactionHex(txB, buildIncomplete = false) {\n    if (buildIncomplete) {\n        return txB.buildIncomplete().toHex();\n    }\n    else {\n        return txB.build().toHex();\n    }\n}\n/**\n* @ignore\n*/\nfunction getTransactionSigner(input) {\n    if (typeof input === 'string') {\n        return signers_1.PubkeyHashSigner.fromHexString(input);\n    }\n    else {\n        return input;\n    }\n}\n/**\n * Estimates cost of a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to preorder\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\nfunction estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const preorderPromise = network.getNamePrice(fullyQualifiedName)\n        .then(namePrice => skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress));\n    return Promise.all([network.getFeeRate(), preorderPromise])\n        .then(([feeRate, preorderTX]) => {\n        const outputsValue = utils_1.sumOutputValues(preorderTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name\n * @param {String} paymentAddress - the address funding the register\n * @param {Boolean} includingZonefile - whether or not we will broadcast\n *    a zonefile hash as part  of the register\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the register.\n * @private\n */\nfunction estimateRegister(fullyQualifiedName, registerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    let valueHash;\n    if (includingZonefile) {\n        valueHash = dummyZonefileHash;\n    }\n    const registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(registerTX);\n        // 1 additional output for payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String} ownerAddress - the owner of the name\n * @param {String} paymentAddress - the address funding the update\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the update.\n * @private\n */\nfunction estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(updateTX);\n        // 1 additional input for the owner\n        // 2 additional outputs for owner / payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\nfunction estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(transferTX);\n        // 1 additional input for the owner\n        // 2 additional outputs for owner / payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to renew\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash\n      in the renewal operation\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\nfunction estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    let valueHash;\n    if (includingZonefile) {\n        valueHash = dummyZonefileHash;\n    }\n    const renewalPromise = network.getNamePrice(fullyQualifiedName)\n        .then(namePrice => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash));\n    return Promise.all([network.getFeeRate(), renewalPromise])\n        .then(([feeRate, renewalTX]) => {\n        const outputsValue = utils_1.sumOutputValues(renewalTX);\n        // 1 additional input for the owner\n        // and renewal skeleton includes all outputs for owner change, but not for payer change.\n        const txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);\n        return txFee + outputsValue - 5500; // don't count the dust change for old owner.\n    });\n}\n/**\n * Estimates cost of a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress  the address funding the revoke\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund the\n *    revoke.\n * @private\n */\nfunction estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n    return Promise.all([network.getFeeRate()])\n        .then(([feeRate]) => {\n        const outputsValue = utils_1.sumOutputValues(revokeTX);\n        // 1 additional input for owner\n        // 1 additional output for payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to preorder\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\nfunction estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const preorderPromise = network.getNamespacePrice(namespaceID)\n        .then(namespacePrice => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice));\n    return Promise.all([network.getFeeRate(), preorderPromise])\n        .then(([feeRate, preorderTX]) => {\n        const outputsValue = utils_1.sumOutputValues(preorderTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates cost of a namesapce reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace\n *    (this must have been passed as 'revealAddress' to a prior namespace\n *    preorder)\n * @param {String} paymentAddress - the address that pays for this transaction\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *    fund the reveal.  This includes a 5500 satoshi dust output for the\n *    preorder.  Even though this is a change output, the payer must have\n *    enough funds to generate this output, so we include it in the cost.\n * @private\n */\nfunction estimateNamespaceReveal(namespace, revealAddress, paymentAddress, paymentUtxos = 1) {\n    const network = config_1.config.network;\n    const revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(revealTX);\n        // 1 additional output for payer change\n        const txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of a namespace-ready transaction for a namespace\n * @param {String} namespaceID - the namespace to ready\n * @param {Number} revealUtxos - the number of UTXOs we expect will\n *  be required from the reveal address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this namespacey-ready transaction.\n * @private\n */\nfunction estimateNamespaceReady(namespaceID, revealUtxos = 1) {\n    const network = config_1.config.network;\n    const readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(readyTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of a name-import transaction\n * @param {String} name - the fully-qualified name\n * @param {String} recipientAddr - the recipient\n * @param {String} zonefileHash - the zone file hash\n * @param {Number} importUtxos - the number of UTXOs we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this name-import transaction\n * @private\n */\nfunction estimateNameImport(name, recipientAddr, zonefileHash, importUtxos = 1) {\n    const network = config_1.config.network;\n    const importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(importTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of an announce transaction\n * @param {String} messageHash - the hash of the message\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this announce transaction\n * @private\n */\nfunction estimateAnnounce(messageHash, senderUtxos = 1) {\n    const network = config_1.config.network;\n    const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(announceTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Estimates the cost of a token-transfer transaction\n * @param {String} recipientAddress - the recipient of the tokens\n * @param {String} tokenType - the type of token to spend\n * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens\n *   to spend\n * @param {String} scratchArea - an arbitrary string to store with the transaction\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @param {Number} additionalOutputs - the number of outputs we expect to add beyond\n *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this token-transfer transaction\n * @private\n */\nfunction estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderUtxos = 1, additionalOutputs = 1) {\n    const network = config_1.config.network;\n    const tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);\n    return network.getFeeRate()\n        .then((feeRate) => {\n        const outputsValue = utils_1.sumOutputValues(tokenTransferTX);\n        const txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);\n        return txFee + outputsValue;\n    });\n}\n/**\n * Generates a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to pre-order\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction or a transaction signer object\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const namespace = fullyQualifiedName.split('.').pop();\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then((preorderAddress) => {\n        const preorderPromise = Promise.all([network.getConsensusHash(),\n            network.getNamePrice(fullyQualifiedName),\n            network.getNamespaceBurnAddress(namespace)])\n            .then(([consensusHash, namePrice, burnAddress]) => skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress));\n        return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise])\n            .then(([utxos, feeRate, preorderSkeleton]) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n            txB.setVersion(1);\n            const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n            const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n            return utils_1.signInputs(signingTxB, paymentKey);\n        })\n            .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n    });\n}\n/**\n * Generates an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of the\n *    owner key, or a transaction signer object. This will provide one\n *    UTXO input, and also recieve a dust output.\n * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a\n *    transaction signer object, of the private key used to fund the\n *    transaction's txfees\n * @param {String} zonefile - the zonefile data to update (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - if given, this is the hash to store (instead of\n *    zonefile).  zonefile will be ignored if this is given.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile, valueHash = '', buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!valueHash && !zonefile) {\n        return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n    }\n    if (valueHash.length === 0) {\n        if (!zonefile) {\n            return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n        }\n        valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n    }\n    else if (valueHash.length !== 40) {\n        return Promise.reject(new Error(`Invalid valueHash ${valueHash}`));\n    }\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const txPromise = network.getConsensusHash()\n            .then(consensusHash => skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash))\n            .then((updateTX) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(updateTX, network.layer1);\n            txB.setVersion(1);\n            return txB;\n        });\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name (this\n *    must have been passed as the 'destinationAddress' in the preorder transaction)\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key (or a TransactionSigner object) used to fund the\n *    transaction (this *must* be the same as the payment address used\n *    to fund the preorder)\n * @param {String} zonefile - the zonefile data to include (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - the hash of the zone file data to include.\n *    It will be used instead of zonefile, if given\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!valueHash && !!zonefile) {\n        valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n    }\n    else if (!!valueHash && valueHash.length !== 40) {\n        return Promise.reject(new Error(`Invalid zonefile hash ${valueHash}`));\n    }\n    const registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);\n    txB.setVersion(1);\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, paymentKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name.\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {Boolean} keepZonefile - if true, then preserve the name's zone file\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, keepZonefile = false, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const txPromise = network.getConsensusHash()\n            .then(consensusHash => skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile))\n            .then((transferTX) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder\n                .fromTransaction(transferTX, network.layer1);\n            txB.setVersion(1);\n            return txB;\n        });\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n        const txPromise = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(revokeTX, network.layer1);\n        txPromise.setVersion(1);\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a renewal transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name after renewal\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the renewal (or a TransactionSigner\n *    object)\n * @param {String} zonefile - the zonefile data to include, if given (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the RENEWAL propagates.\n * @param {String} valueHash - the raw zone file hash to include (this will be used\n *    instead of zonefile, if given).\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\nfunction makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!valueHash && !!zonefile) {\n        valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n    }\n    const namespace = fullyQualifiedName.split('.').pop();\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    const ownerKey = getTransactionSigner(ownerKeyIn);\n    return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])\n        .then(([ownerAddress, paymentAddress]) => {\n        const txPromise = Promise.all([network.getNamePrice(fullyQualifiedName),\n            network.getNamespaceBurnAddress(namespace)])\n            .then(([namePrice, burnAddress]) => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash))\n            .then((tx) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tx, network.layer1);\n            txB.setVersion(1);\n            return txB;\n        });\n        return Promise.all([txPromise, network.getUTXOs(paymentAddress),\n            network.getUTXOs(ownerAddress), network.getFeeRate()])\n            .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n            const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);\n            const txInner = utils_1.getTransactionInsideBuilder(txB);\n            const ownerOutput = txInner.outs[2];\n            const ownerOutputAddr = bitcoinjs_lib_1.address.fromOutputScript(ownerOutput.script, network.layer1);\n            if (ownerOutputAddr !== ownerAddress) {\n                return Promise.reject(new Error(`Original owner ${ownerAddress} should have an output at `\n                    + `index 2 in transaction was ${ownerOutputAddr}`));\n            }\n            ownerOutput.value = ownerInput.value;\n            const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n            return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to pre-order\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n *\n * @ignore\n */\nfunction makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then((preorderAddress) => {\n        const preorderPromise = Promise.all([network.getConsensusHash(),\n            network.getNamespacePrice(namespaceID)])\n            .then(([consensusHash, namespacePrice]) => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice));\n        return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise])\n            .then(([utxos, feeRate, preorderSkeleton]) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n            txB.setVersion(1);\n            const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n            const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n            return utils_1.signInputs(signingTxB, paymentKey);\n        })\n            .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n    });\n}\n/**\n * Generates a namespace reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace (this\n *   must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string (or\n *   a TransactionSigner object) of the private key used to fund the\n *   transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *   this function *does not* perform the requisite safety checks -- please see\n *   the safety module for those.\n * @private\n */\nfunction makeNamespaceReveal(namespace, revealAddress, paymentKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    if (!namespace.check()) {\n        return Promise.reject(new Error('Invalid namespace'));\n    }\n    const namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then(preorderAddress => Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder\n            .fromTransaction(namespaceRevealTX, network.layer1);\n        txB.setVersion(1);\n        const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, paymentKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace ready transaction for a namespace\n * @param {String} namespaceID - the namespace to launch\n * @param {String | TransactionSigner} revealKeyIn - the private key\n *  of the 'revealAddress' used to reveal the namespace\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *  indicating whether the function should attempt to return an unsigned (or not fully signed)\n *  transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *  this function *does not* perform the requisite safety checks -- please see\n *  the safety module for those.\n * @private\n */\nfunction makeNamespaceReady(namespaceID, revealKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n    const revealKey = getTransactionSigner(revealKeyIn);\n    return revealKey.getAddress().then(revealAddress => Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);\n        txB.setVersion(1);\n        const signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, revealKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a name import transaction for a namespace\n * @param {String} name - the name to import\n * @param {String} recipientAddr - the address to receive the name\n * @param {String} zonefileHash - the hash of the zonefile to give this name\n * @param {String | TransactionSigner} importerKeyIn - the private key\n * that pays for the import\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see\n * the safety module for those.\n * @private\n */\nfunction makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n    const importerKey = getTransactionSigner(importerKeyIn);\n    return importerKey.getAddress().then(importerAddress => Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);\n        const signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, importerKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates an announce transaction\n * @param {String} messageHash - the hash of the message to send.  Should be\n *  an already-announced zone file hash\n * @param {String | TransactionSigner} senderKeyIn - the private key\n *  that pays for the transaction.  Should be the key that owns the\n *  name that the message recipients subscribe to\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\nfunction makeAnnounce(messageHash, senderKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n    const senderKey = getTransactionSigner(senderKeyIn);\n    return senderKey.getAddress().then(senderAddress => Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(announceTX, network.layer1);\n        const signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);\n        return utils_1.signInputs(signingTxB, senderKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a token-transfer transaction\n * @param {String} recipientAddress - the address to receive the tokens\n * @param {String} tokenType - the type of tokens to send\n * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of\n *  tokens to send\n * @param {String} scratchArea - an arbitrary string to include with the transaction\n * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send\n *   the tokens\n * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund\n *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to\n *   fund with sender key.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * This function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\nfunction makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn, buildIncomplete = false) {\n    const network = config_1.config.network;\n    const separateFunder = !!btcFunderKeyIn;\n    const senderKey = getTransactionSigner(senderKeyIn);\n    const btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;\n    const txPromise = network.getConsensusHash()\n        .then(consensusHash => skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea));\n    return Promise.all([senderKey.getAddress(), btcKey.getAddress()])\n        .then(([senderAddress, btcAddress]) => {\n        const btcUTXOsPromise = separateFunder\n            ? network.getUTXOs(btcAddress) : Promise.resolve([]);\n        return Promise.all([\n            network.getUTXOs(senderAddress),\n            btcUTXOsPromise,\n            network.getFeeRate(),\n            txPromise\n        ]).then(([senderUTXOs, btcUTXOs, feeRate, tokenTransferTX]) => {\n            const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);\n            if (separateFunder) {\n                const payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);\n                const signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);\n                return utils_1.signInputs(signingTxB, btcKey, [{ index: payerInput.index, signer: senderKey }]);\n            }\n            else {\n                const signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);\n                return utils_1.signInputs(signingTxB, senderKey);\n            }\n        });\n    })\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a bitcoin spend to a specified address. This will fund up to `amount`\n *   of satoshis from the payer's UTXOs. It will generate a change output if and only\n *   if the amount of leftover change is *greater* than the additional fees associated\n *   with the extra output. If the requested amount is not enough to fund the transaction's\n *   associated fees, then this will reject with a InvalidAmountError\n *\n * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated\n *   with their own input will not be included.\n *\n * If you specify an amount > the total balance of the payer address, then this will\n *   generate a maximum spend transaction\n *\n * @param {String} destinationAddress - the address to receive the bitcoin payment\n * @param {String | TransactionSigner} paymentKeyIn - the private key\n *    used to fund the bitcoin spend\n * @param {number} amount - the amount in satoshis for the payment address to\n *    spend in this transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * @private\n */\nfunction makeBitcoinSpend(destinationAddress, paymentKeyIn, amount, buildIncomplete = false) {\n    if (amount <= 0) {\n        return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));\n    }\n    const network = config_1.config.network;\n    const paymentKey = getTransactionSigner(paymentKeyIn);\n    return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()])\n        .then(([utxos, feeRate]) => {\n        const txB = new bitcoinjs_lib_1.TransactionBuilder(network.layer1);\n        txB.setVersion(1);\n        const destinationIndex = txB.addOutput(destinationAddress, 0);\n        // will add utxos up to _amount_ and return the amount of leftover _change_\n        let change;\n        try {\n            change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);\n        }\n        catch (err) {\n            if (err.name === 'NotEnoughFundsError') {\n                // actual amount funded = amount requested - remainder\n                amount -= err.leftToFund;\n                change = 0;\n            }\n            else {\n                throw err;\n            }\n        }\n        let feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);\n        const feeForChange = feeRate * (utils_1.estimateTXBytes(txB, 0, 1)) - feesToPay;\n        // it's worthwhile to add a change output\n        if (change > feeForChange) {\n            feesToPay += feeForChange;\n            txB.addOutput(paymentAddress, change);\n        }\n        // now let's compute how much output is leftover once we pay the fees.\n        const outputAmount = amount - feesToPay;\n        if (outputAmount < utils_1.DUST_MINIMUM) {\n            throw new errors_1.InvalidAmountError(feesToPay, amount);\n        }\n        // we need to manually set the output values now\n        const txInner = utils_1.getTransactionInsideBuilder(txB);\n        const txOut = txInner.outs[destinationIndex];\n        txOut.value = outputAmount;\n        // ready to sign.\n        return utils_1.signInputs(txB, paymentKey);\n    }))\n        .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\nexports.transactions = {\n    makeRenewal,\n    makeUpdate,\n    makePreorder,\n    makeRegister,\n    makeTransfer,\n    makeRevoke,\n    makeNamespacePreorder,\n    makeNamespaceReveal,\n    makeNamespaceReady,\n    makeBitcoinSpend,\n    makeNameImport,\n    makeAnnounce,\n    makeTokenTransfer,\n    BlockstackNamespace: skeletons_1.BlockstackNamespace,\n    estimatePreorder,\n    estimateRegister,\n    estimateTransfer,\n    estimateUpdate,\n    estimateRenewal,\n    estimateRevoke,\n    estimateNamespacePreorder,\n    estimateNamespaceReveal,\n    estimateNamespaceReady,\n    estimateNameImport,\n    estimateAnnounce,\n    estimateTokenTransfer\n};\n//# sourceMappingURL=txbuild.js.map"]},"metadata":{},"sourceType":"script"}