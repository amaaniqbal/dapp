{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\"); // eslint-disable-next-line import/no-unassigned-import\n\n\nrequire(\"cross-fetch/polyfill\");\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst keys_1 = require(\"../keys\");\n\nconst utils_1 = require(\"../utils\");\n\nconst dids_1 = require(\"../dids\");\n\nconst ec_1 = require(\"../encryption/ec\");\n\nconst logger_1 = require(\"../logger\");\n\nconst authConstants_1 = require(\"./authConstants\");\n\nconst userSession_1 = require(\"./userSession\");\n\nconst VERSION = '1.3.1';\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\n\nfunction generateTransitKey() {\n  const transitKey = keys_1.makeECPrivateKey();\n  return transitKey;\n}\n\nexports.generateTransitKey = generateTransitKey;\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\n\nfunction makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = utils_1.nextMonth().getTime(), extraParams = {}) {\n  if (!transitPrivateKey) {\n    transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();\n  }\n\n  const getWindowOrigin = paramName => {\n    const location = utils_1.getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  /* Create the payload */\n\n\n  const payload = Object.assign({}, extraParams, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth request`);\n  /* Convert the private key to a public key to an issuer */\n\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = keys_1.publicKeyToAddress(publicKey);\n  payload.iss = dids_1.makeDIDFromAddress(address);\n  /* Sign and return the token */\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\n\nexports.makeAuthRequest = makeAuthRequest;\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\n\nfunction encryptPrivateKey(publicKey, privateKey) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const encryptedObj = yield ec_1.encryptECIES(publicKey, Buffer.from(privateKey), true);\n    const encryptedJSON = JSON.stringify(encryptedObj);\n    return Buffer.from(encryptedJSON).toString('hex');\n  });\n}\n\nexports.encryptPrivateKey = encryptPrivateKey;\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\n\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n    const encryptedObj = JSON.parse(unhexedString);\n    const decrypted = yield ec_1.decryptECIES(privateKey, encryptedObj);\n\n    if (typeof decrypted !== 'string') {\n      throw new Error('Unable to correctly decrypt private key');\n    } else {\n      return decrypted;\n    }\n  });\n}\n\nexports.decryptPrivateKey = decryptPrivateKey;\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\n\nfunction makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = utils_1.nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    /* Convert the private key to a public key to an issuer */\n    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n    const address = keys_1.publicKeyToAddress(publicKey);\n    /* See if we should encrypt with the transit key */\n\n    let privateKeyPayload = appPrivateKey;\n    let coreTokenPayload = coreToken;\n    let additionalProperties = {};\n\n    if (appPrivateKey !== undefined && appPrivateKey !== null) {\n      logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth response`);\n\n      if (transitPublicKey !== undefined && transitPublicKey !== null) {\n        privateKeyPayload = yield encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n        if (coreToken !== undefined && coreToken !== null) {\n          coreTokenPayload = yield encryptPrivateKey(transitPublicKey, coreToken);\n        }\n      }\n\n      additionalProperties = {\n        email: metadata.email ? metadata.email : null,\n        profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n        hubUrl,\n        blockstackAPIUrl,\n        associationToken,\n        version: VERSION\n      };\n    } else {\n      logger_1.Logger.info('blockstack.js: generating legacy auth response');\n    }\n    /* Create the payload */\n\n\n    const payload = Object.assign({}, {\n      jti: utils_1.makeUUID4(),\n      iat: Math.floor(new Date().getTime() / 1000),\n      exp: Math.floor(expiresAt / 1000),\n      iss: dids_1.makeDIDFromAddress(address),\n      private_key: privateKeyPayload,\n      public_keys: [publicKey],\n      profile,\n      username,\n      core_token: coreTokenPayload\n    }, additionalProperties);\n    /* Sign and return the token */\n\n    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);\n    return tokenSigner.sign(payload);\n  });\n}\n\nexports.makeAuthResponse = makeAuthResponse;","map":{"version":3,"sources":["../../src/auth/authMessages.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\n// eslint-disable-next-line import/no-unassigned-import\nrequire(\"cross-fetch/polyfill\");\nconst jsontokens_1 = require(\"jsontokens\");\nconst keys_1 = require(\"../keys\");\nconst utils_1 = require(\"../utils\");\nconst dids_1 = require(\"../dids\");\nconst ec_1 = require(\"../encryption/ec\");\nconst logger_1 = require(\"../logger\");\nconst authConstants_1 = require(\"./authConstants\");\nconst userSession_1 = require(\"./userSession\");\nconst VERSION = '1.3.1';\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nfunction generateTransitKey() {\n    const transitKey = keys_1.makeECPrivateKey();\n    return transitKey;\n}\nexports.generateTransitKey = generateTransitKey;\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nfunction makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = utils_1.nextMonth().getTime(), extraParams = {}) {\n    if (!transitPrivateKey) {\n        transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();\n    }\n    const getWindowOrigin = (paramName) => {\n        const location = utils_1.getGlobalObject('location', {\n            throwIfUnavailable: true,\n            usageDesc: `makeAuthRequest([${paramName}=undefined])`\n        });\n        return location.origin;\n    };\n    if (!redirectURI) {\n        redirectURI = `${getWindowOrigin('redirectURI')}/`;\n    }\n    if (!manifestURI) {\n        manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n    }\n    if (!appDomain) {\n        appDomain = getWindowOrigin('appDomain');\n    }\n    /* Create the payload */\n    const payload = Object.assign({}, extraParams, {\n        jti: utils_1.makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: null,\n        public_keys: [],\n        domain_name: appDomain,\n        manifest_uri: manifestURI,\n        redirect_uri: redirectURI,\n        version: VERSION,\n        do_not_include_profile: true,\n        supports_hub_url: true,\n        scopes\n    });\n    logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth request`);\n    /* Convert the private key to a public key to an issuer */\n    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);\n    payload.public_keys = [publicKey];\n    const address = keys_1.publicKeyToAddress(publicKey);\n    payload.iss = dids_1.makeDIDFromAddress(address);\n    /* Sign and return the token */\n    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);\n    const token = tokenSigner.sign(payload);\n    return token;\n}\nexports.makeAuthRequest = makeAuthRequest;\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nfunction encryptPrivateKey(publicKey, privateKey) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const encryptedObj = yield ec_1.encryptECIES(publicKey, Buffer.from(privateKey), true);\n        const encryptedJSON = JSON.stringify(encryptedObj);\n        return Buffer.from(encryptedJSON).toString('hex');\n    });\n}\nexports.encryptPrivateKey = encryptPrivateKey;\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n        const encryptedObj = JSON.parse(unhexedString);\n        const decrypted = yield ec_1.decryptECIES(privateKey, encryptedObj);\n        if (typeof decrypted !== 'string') {\n            throw new Error('Unable to correctly decrypt private key');\n        }\n        else {\n            return decrypted;\n        }\n    });\n}\nexports.decryptPrivateKey = decryptPrivateKey;\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nfunction makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = utils_1.nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        /* Convert the private key to a public key to an issuer */\n        const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n        const address = keys_1.publicKeyToAddress(publicKey);\n        /* See if we should encrypt with the transit key */\n        let privateKeyPayload = appPrivateKey;\n        let coreTokenPayload = coreToken;\n        let additionalProperties = {};\n        if (appPrivateKey !== undefined && appPrivateKey !== null) {\n            logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth response`);\n            if (transitPublicKey !== undefined && transitPublicKey !== null) {\n                privateKeyPayload = yield encryptPrivateKey(transitPublicKey, appPrivateKey);\n                if (coreToken !== undefined && coreToken !== null) {\n                    coreTokenPayload = yield encryptPrivateKey(transitPublicKey, coreToken);\n                }\n            }\n            additionalProperties = {\n                email: metadata.email ? metadata.email : null,\n                profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n                hubUrl,\n                blockstackAPIUrl,\n                associationToken,\n                version: VERSION\n            };\n        }\n        else {\n            logger_1.Logger.info('blockstack.js: generating legacy auth response');\n        }\n        /* Create the payload */\n        const payload = Object.assign({}, {\n            jti: utils_1.makeUUID4(),\n            iat: Math.floor(new Date().getTime() / 1000),\n            exp: Math.floor(expiresAt / 1000),\n            iss: dids_1.makeDIDFromAddress(address),\n            private_key: privateKeyPayload,\n            public_keys: [publicKey],\n            profile,\n            username,\n            core_token: coreTokenPayload\n        }, additionalProperties);\n        /* Sign and return the token */\n        const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);\n        return tokenSigner.sign(payload);\n    });\n}\nexports.makeAuthResponse = makeAuthResponse;\n//# sourceMappingURL=authMessages.js.map"]},"metadata":{},"sourceType":"script"}