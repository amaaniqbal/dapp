{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst keys_1 = require(\"../keys\");\n\nconst utils_1 = require(\"../utils\");\n\nconst dids_1 = require(\"../dids\");\n\nconst ec_1 = require(\"../encryption/ec\");\n\nconst logger_1 = require(\"../logger\");\n\nconst authConstants_1 = require(\"./authConstants\");\n\nconst userSession_1 = require(\"./userSession\");\n\nconst VERSION = '1.3.1';\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\n\nfunction generateTransitKey() {\n  const transitKey = keys_1.makeECPrivateKey();\n  return transitKey;\n}\n\nexports.generateTransitKey = generateTransitKey;\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\n\nfunction makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = utils_1.nextMonth().getTime(), extraParams = {}) {\n  if (!transitPrivateKey) {\n    transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();\n  }\n\n  const getWindowOrigin = paramName => {\n    const location = utils_1.getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  /* Create the payload */\n\n\n  const payload = Object.assign({}, extraParams, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth request`);\n  /* Convert the private key to a public key to an issuer */\n\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = keys_1.publicKeyToAddress(publicKey);\n  payload.iss = dids_1.makeDIDFromAddress(address);\n  /* Sign and return the token */\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\n\nexports.makeAuthRequest = makeAuthRequest;\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\n\nfunction encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = ec_1.encryptECIES(publicKey, privateKey);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\n\nexports.encryptPrivateKey = encryptPrivateKey;\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\n\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = ec_1.decryptECIES(privateKey, encryptedObj);\n\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\nexports.decryptPrivateKey = decryptPrivateKey;\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\n\nfunction makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = utils_1.nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n  const address = keys_1.publicKeyToAddress(publicKey);\n  /* See if we should encrypt with the transit key */\n\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth response`);\n\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n\n    additionalProperties = {\n      email: metadata.email ? metadata.email : null,\n      profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {\n    logger_1.Logger.info('blockstack.js: generating legacy auth response');\n  }\n  /* Create the payload */\n\n\n  const payload = Object.assign({}, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: dids_1.makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    profile,\n    username,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  /* Sign and return the token */\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n\nexports.makeAuthResponse = makeAuthResponse;","map":{"version":3,"sources":["../../src/auth/authMessages.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"cross-fetch/polyfill\");\n// @ts-ignore: Could not find a declaration file for module\nconst jsontokens_1 = require(\"jsontokens\");\nconst keys_1 = require(\"../keys\");\nconst utils_1 = require(\"../utils\");\nconst dids_1 = require(\"../dids\");\nconst ec_1 = require(\"../encryption/ec\");\nconst logger_1 = require(\"../logger\");\nconst authConstants_1 = require(\"./authConstants\");\nconst userSession_1 = require(\"./userSession\");\nconst VERSION = '1.3.1';\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nfunction generateTransitKey() {\n    const transitKey = keys_1.makeECPrivateKey();\n    return transitKey;\n}\nexports.generateTransitKey = generateTransitKey;\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nfunction makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = utils_1.nextMonth().getTime(), extraParams = {}) {\n    if (!transitPrivateKey) {\n        transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();\n    }\n    const getWindowOrigin = (paramName) => {\n        const location = utils_1.getGlobalObject('location', {\n            throwIfUnavailable: true,\n            usageDesc: `makeAuthRequest([${paramName}=undefined])`\n        });\n        return location.origin;\n    };\n    if (!redirectURI) {\n        redirectURI = `${getWindowOrigin('redirectURI')}/`;\n    }\n    if (!manifestURI) {\n        manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n    }\n    if (!appDomain) {\n        appDomain = getWindowOrigin('appDomain');\n    }\n    /* Create the payload */\n    const payload = Object.assign({}, extraParams, {\n        jti: utils_1.makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: null,\n        public_keys: [],\n        domain_name: appDomain,\n        manifest_uri: manifestURI,\n        redirect_uri: redirectURI,\n        version: VERSION,\n        do_not_include_profile: true,\n        supports_hub_url: true,\n        scopes\n    });\n    logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth request`);\n    /* Convert the private key to a public key to an issuer */\n    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);\n    payload.public_keys = [publicKey];\n    const address = keys_1.publicKeyToAddress(publicKey);\n    payload.iss = dids_1.makeDIDFromAddress(address);\n    /* Sign and return the token */\n    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);\n    const token = tokenSigner.sign(payload);\n    return token;\n}\nexports.makeAuthRequest = makeAuthRequest;\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nfunction encryptPrivateKey(publicKey, privateKey) {\n    const encryptedObj = ec_1.encryptECIES(publicKey, privateKey);\n    const encryptedJSON = JSON.stringify(encryptedObj);\n    return (Buffer.from(encryptedJSON)).toString('hex');\n}\nexports.encryptPrivateKey = encryptPrivateKey;\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n    const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n    const encryptedObj = JSON.parse(unhexedString);\n    const decrypted = ec_1.decryptECIES(privateKey, encryptedObj);\n    if (typeof decrypted !== 'string') {\n        throw new Error('Unable to correctly decrypt private key');\n    }\n    else {\n        return decrypted;\n    }\n}\nexports.decryptPrivateKey = decryptPrivateKey;\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nfunction makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = utils_1.nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n    /* Convert the private key to a public key to an issuer */\n    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n    const address = keys_1.publicKeyToAddress(publicKey);\n    /* See if we should encrypt with the transit key */\n    let privateKeyPayload = appPrivateKey;\n    let coreTokenPayload = coreToken;\n    let additionalProperties = {};\n    if (appPrivateKey !== undefined && appPrivateKey !== null) {\n        logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth response`);\n        if (transitPublicKey !== undefined && transitPublicKey !== null) {\n            privateKeyPayload = encryptPrivateKey(transitPublicKey, appPrivateKey);\n            if (coreToken !== undefined && coreToken !== null) {\n                coreTokenPayload = encryptPrivateKey(transitPublicKey, coreToken);\n            }\n        }\n        additionalProperties = {\n            email: metadata.email ? metadata.email : null,\n            profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n            hubUrl,\n            blockstackAPIUrl,\n            associationToken,\n            version: VERSION\n        };\n    }\n    else {\n        logger_1.Logger.info('blockstack.js: generating legacy auth response');\n    }\n    /* Create the payload */\n    const payload = Object.assign({}, {\n        jti: utils_1.makeUUID4(),\n        iat: Math.floor(new Date().getTime() / 1000),\n        exp: Math.floor(expiresAt / 1000),\n        iss: dids_1.makeDIDFromAddress(address),\n        private_key: privateKeyPayload,\n        public_keys: [publicKey],\n        profile,\n        username,\n        core_token: coreTokenPayload\n    }, additionalProperties);\n    /* Sign and return the token */\n    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);\n    return tokenSigner.sign(payload);\n}\nexports.makeAuthResponse = makeAuthResponse;\n//# sourceMappingURL=authMessages.js.map"]},"metadata":{},"sourceType":"script"}