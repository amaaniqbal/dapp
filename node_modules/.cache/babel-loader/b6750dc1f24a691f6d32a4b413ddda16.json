{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst bip39_1 = require(\"bip39\");\n\nconst wallet_1 = require(\"./encryption/wallet\");\n\nconst cryptoRandom_1 = require(\"./encryption/cryptoRandom\");\n\nconst sha2Hash_1 = require(\"./encryption/sha2Hash\");\n\nconst keys_1 = require(\"./keys\");\n\nconst APPS_NODE_INDEX = 0;\nconst IDENTITY_KEYCHAIN = 888;\nconst BLOCKSTACK_ON_BITCOIN = 0;\nconst BITCOIN_BIP_44_PURPOSE = 44;\nconst BITCOIN_COIN_TYPE = 0;\nconst BITCOIN_ACCOUNT_INDEX = 0;\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n/**\n *\n * @ignore\n */\n\nfunction hashCode(string) {\n  let hash = 0;\n  if (string.length === 0) return hash;\n\n  for (let i = 0; i < string.length; i++) {\n    const character = string.charCodeAt(i);\n    hash = (hash << 5) - hash + character;\n    hash &= hash;\n  }\n\n  return hash & 0x7fffffff;\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getNodePrivateKey(node) {\n  return keys_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getNodePublicKey(node) {\n  return node.publicKey.toString('hex');\n}\n/**\n * Get a BIP32 node for an application-specific domain.\n * @param {String} appsNode - the BIP32Interface ir base58-encoded private key for\n * applications node\n * @param {String} salt - a string, used to salt the\n * application-specific addresses\n * @param {String} appDomain - the appDomain to generate a key for\n * @return {String} the private key hex-string. this will be a 64\n * character string\n * @ignore\n */\n\n\nfunction getLegacyAppNode(appsNode, salt, appDomain) {\n  const hashBuffer = sha2Hash_1.hashSha256Sync(Buffer.from(`${appDomain}${salt}`));\n  const hash = hashBuffer.toString('hex');\n  const appIndex = hashCode(hash);\n  const appNodeInstance = typeof appsNode === 'string' ? bitcoinjs_lib_1.bip32.fromBase58(appsNode) : appsNode;\n  return appNodeInstance.deriveHardened(appIndex);\n}\n\nexports.getLegacyAppNode = getLegacyAppNode;\n/**\n * The `BlockstackWallet` class manages the hierarchical derivation\n * paths for a standard Blockstack client wallet. This includes paths\n * for Bitcoin payment address, Blockstack identity addresses, Blockstack\n * application specific addresses.\n *\n * @ignore\n */\n\nclass BlockstackWallet {\n  constructor(rootNode) {\n    this.rootNode = rootNode;\n  }\n\n  toBase58() {\n    return this.rootNode.toBase58();\n  }\n  /**\n   * Initialize a Blockstack wallet from a seed buffer\n   * @param {Buffer} seed - the input seed for initializing the root node\n   *  of the hierarchical wallet\n   * @return {BlockstackWallet} the constructed wallet\n   */\n\n\n  static fromSeedBuffer(seed) {\n    return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n  }\n  /**\n   * Initialize a Blockstack wallet from a base58 string\n   * @param {string} keychain - the Base58 string used to initialize\n   *  the root node of the hierarchical wallet\n   * @return {BlockstackWallet} the constructed wallet\n   */\n\n\n  static fromBase58(keychain) {\n    return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromBase58(keychain));\n  }\n  /**\n   * Initialize a blockstack wallet from an encrypted phrase & password. Throws\n   * if the password is incorrect. Supports all formats of Blockstack phrases.\n   * @param {string} data - The encrypted phrase as a hex-encoded string\n   * @param {string} password - The plain password\n   * @return {Promise<BlockstackWallet>} the constructed wallet\n   *\n   * @ignore\n   */\n\n\n  static fromEncryptedMnemonic(data, password, triplesecDecrypt) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const mnemonic = yield wallet_1.decryptMnemonic(data, password, triplesecDecrypt);\n        const seed = yield bip39_1.mnemonicToSeed(mnemonic);\n        return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n      } catch (err) {\n        if (err.message && err.message.startsWith('bad header;')) {\n          throw new Error('Incorrect password');\n        } else {\n          throw err;\n        }\n      }\n    });\n  }\n  /**\n   * Generate a BIP-39 12 word mnemonic\n   * @return {Promise<string>} space-separated 12 word phrase\n   */\n\n\n  static generateMnemonic() {\n    return bip39_1.generateMnemonic(128, cryptoRandom_1.randomBytes);\n  }\n  /**\n   * Encrypt a mnemonic phrase with a password\n   * @param {string} mnemonic - Raw mnemonic phrase\n   * @param {string} password - Password to encrypt mnemonic with\n   * @return {Promise<string>} Hex-encoded encrypted mnemonic\n   *\n   */\n\n\n  static encryptMnemonic(mnemonic, password, opts) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const encryptedBuffer = yield wallet_1.encryptMnemonic(mnemonic, password, opts);\n      return encryptedBuffer.toString('hex');\n    });\n  }\n\n  getIdentityPrivateKeychain() {\n    return this.rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);\n  }\n\n  getBitcoinPrivateKeychain() {\n    return this.rootNode.deriveHardened(BITCOIN_BIP_44_PURPOSE).deriveHardened(BITCOIN_COIN_TYPE).deriveHardened(BITCOIN_ACCOUNT_INDEX);\n  }\n\n  getBitcoinNode(addressIndex, chainType = EXTERNAL_ADDRESS) {\n    return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n  }\n\n  getIdentityAddressNode(identityIndex) {\n    const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n    return identityPrivateKeychain.deriveHardened(identityIndex);\n  }\n\n  static getAppsNode(identityNode) {\n    return identityNode.deriveHardened(APPS_NODE_INDEX);\n  }\n  /**\n   * Get a salt for use with creating application specific addresses\n   * @return {String} the salt\n   */\n\n\n  getIdentitySalt() {\n    const identityPrivateKeychain = this.getIdentityPrivateKeychain(); // NOTE: This is being decoded as a utf8 string rather than a hex string\n\n    const publicKeyHex = Buffer.from(getNodePublicKey(identityPrivateKeychain));\n    return sha2Hash_1.hashSha256Sync(publicKeyHex).toString('hex');\n  }\n  /**\n   * Get a bitcoin receive address at a given index\n   * @param {number} addressIndex - the index of the address\n   * @return {String} address\n   */\n\n\n  getBitcoinAddress(addressIndex) {\n    return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n  }\n  /**\n   * Get the private key hex-string for a given bitcoin receive address\n   * @param {number} addressIndex - the index of the address\n   * @return {String} the hex-string. this will be either 64\n   * characters long to denote an uncompressed bitcoin address, or 66\n   * characters long for a compressed bitcoin address.\n   */\n\n\n  getBitcoinPrivateKey(addressIndex) {\n    return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n  }\n  /**\n   * Get the root node for the bitcoin public keychain\n   * @return {String} base58-encoding of the public node\n   */\n\n\n  getBitcoinPublicKeychain() {\n    return this.getBitcoinPrivateKeychain().neutered();\n  }\n  /**\n   * Get the root node for the identity public keychain\n   * @return {String} base58-encoding of the public node\n   */\n\n\n  getIdentityPublicKeychain() {\n    return this.getIdentityPrivateKeychain().neutered();\n  }\n\n  static getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n    let chain;\n\n    if (chainType === EXTERNAL_ADDRESS) {\n      chain = 0;\n    } else if (chainType === CHANGE_ADDRESS) {\n      chain = 1;\n    } else {\n      throw new Error('Invalid chain type');\n    }\n\n    const keychain = bitcoinjs_lib_1.bip32.fromBase58(keychainBase58);\n    return keychain.derive(chain).derive(addressIndex);\n  }\n  /**\n   * Get a bitcoin address given a base-58 encoded bitcoin node\n   * (usually called the account node)\n   * @param {String} keychainBase58 - base58-encoding of the node\n   * @param {number} addressIndex - index of the address to get\n   * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\n   * \"receive\" address) or 'CHANGE_ADDRESS'\n   * @return {String} the address\n   */\n\n\n  static getAddressFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n    return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet.getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n  }\n  /**\n   * Get a ECDSA private key hex-string for an application-specific\n   *  address.\n   * @param {String} appsNodeKey - the base58-encoded private key for\n   * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n   * @param {String} salt - a string, used to salt the\n   * application-specific addresses\n   * @param {String} appDomain - the appDomain to generate a key for\n   * @return {String} the private key hex-string. this will be a 64\n   * character string\n   */\n\n\n  static getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n    const appNode = getLegacyAppNode(appsNodeKey, salt, appDomain);\n    return getNodePrivateKey(appNode).slice(0, 64);\n  }\n\n  static getAddressFromBIP32Node(node) {\n    return bitcoinjs_lib_1.payments.p2pkh({\n      pubkey: node.publicKey\n    }).address;\n  }\n  /**\n   * Get a ECDSA private key hex-string for an application-specific\n   *  address.\n   * @param {String} appsNodeKey - the base58-encoded private key for\n   * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n   * @param {String} salt - a string, used to salt the\n   * application-specific addresses\n   * @param {String} appDomain - the appDomain to generate a key for\n   * @return {String} the private key hex-string. this will be a 64\n   * character string\n   */\n\n\n  static getAppPrivateKey(appsNodeKey, salt, appDomain) {\n    const hashBuffer = sha2Hash_1.hashSha256Sync(Buffer.from(`${appDomain}${salt}`));\n    const hash = hashBuffer.toString('hex');\n    const appIndexHexes = []; // note: there's hardcoded numbers here, precisely because I want this\n    //   code to be very specific to the derivation paths we expect.\n\n    if (hash.length !== 64) {\n      throw new Error(`Unexpected app-domain hash length of ${hash.length}`);\n    }\n\n    for (let i = 0; i < 11; i++) {\n      // split the hash into 3-byte chunks\n      // because child nodes can only be up to 2^31,\n      // and we shouldn't deal in partial bytes.\n      appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n    }\n\n    let appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey);\n    appIndexHexes.forEach(hex => {\n      if (hex.length > 6) {\n        throw new Error('Invalid hex string length');\n      }\n\n      appNode = appNode.deriveHardened(parseInt(hex, 16));\n    });\n    return getNodePrivateKey(appNode).slice(0, 64);\n  }\n  /**\n   * Get the keypair information for a given identity index. This\n   * information is used to obtain the private key for an identity address\n   * and derive application specific keys for that address.\n   * @param {number} addressIndex - the identity index\n   * @param {boolean} alwaysUncompressed - if true, always return a\n   *   private-key hex string corresponding to the uncompressed address\n   * @return {Object} an IdentityKeyPair type object with keys:\n   *   .key {String} - the private key hex-string\n   *   .keyID {String} - the public key hex-string\n   *   .address {String} - the identity address\n   *   .appsNodeKey {String} - the base-58 encoding of the applications node\n   *   .salt {String} - the salt used for creating app-specific addresses\n   */\n\n\n  getIdentityKeyPair(addressIndex, alwaysUncompressed = false) {\n    const identityNode = this.getIdentityAddressNode(addressIndex);\n    const address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n    let identityKey = getNodePrivateKey(identityNode);\n\n    if (alwaysUncompressed && identityKey.length === 66) {\n      identityKey = identityKey.slice(0, 64);\n    }\n\n    const identityKeyID = getNodePublicKey(identityNode);\n    const appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n    const salt = this.getIdentitySalt();\n    const keyPair = {\n      key: identityKey,\n      keyID: identityKeyID,\n      address,\n      appsNodeKey,\n      salt\n    };\n    return keyPair;\n  }\n\n}\n\nexports.BlockstackWallet = BlockstackWallet;","map":{"version":3,"sources":["../src/wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst bip39_1 = require(\"bip39\");\nconst wallet_1 = require(\"./encryption/wallet\");\nconst cryptoRandom_1 = require(\"./encryption/cryptoRandom\");\nconst sha2Hash_1 = require(\"./encryption/sha2Hash\");\nconst keys_1 = require(\"./keys\");\nconst APPS_NODE_INDEX = 0;\nconst IDENTITY_KEYCHAIN = 888;\nconst BLOCKSTACK_ON_BITCOIN = 0;\nconst BITCOIN_BIP_44_PURPOSE = 44;\nconst BITCOIN_COIN_TYPE = 0;\nconst BITCOIN_ACCOUNT_INDEX = 0;\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n/**\n *\n * @ignore\n */\nfunction hashCode(string) {\n    let hash = 0;\n    if (string.length === 0)\n        return hash;\n    for (let i = 0; i < string.length; i++) {\n        const character = string.charCodeAt(i);\n        hash = (hash << 5) - hash + character;\n        hash &= hash;\n    }\n    return hash & 0x7fffffff;\n}\n/**\n *\n * @ignore\n */\nfunction getNodePrivateKey(node) {\n    return keys_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));\n}\n/**\n *\n * @ignore\n */\nfunction getNodePublicKey(node) {\n    return node.publicKey.toString('hex');\n}\n/**\n * Get a BIP32 node for an application-specific domain.\n * @param {String} appsNode - the BIP32Interface ir base58-encoded private key for\n * applications node\n * @param {String} salt - a string, used to salt the\n * application-specific addresses\n * @param {String} appDomain - the appDomain to generate a key for\n * @return {String} the private key hex-string. this will be a 64\n * character string\n * @ignore\n */\nfunction getLegacyAppNode(appsNode, salt, appDomain) {\n    const hashBuffer = sha2Hash_1.hashSha256Sync(Buffer.from(`${appDomain}${salt}`));\n    const hash = hashBuffer.toString('hex');\n    const appIndex = hashCode(hash);\n    const appNodeInstance = typeof appsNode === 'string' ? bitcoinjs_lib_1.bip32.fromBase58(appsNode) : appsNode;\n    return appNodeInstance.deriveHardened(appIndex);\n}\nexports.getLegacyAppNode = getLegacyAppNode;\n/**\n * The `BlockstackWallet` class manages the hierarchical derivation\n * paths for a standard Blockstack client wallet. This includes paths\n * for Bitcoin payment address, Blockstack identity addresses, Blockstack\n * application specific addresses.\n *\n * @ignore\n */\nclass BlockstackWallet {\n    constructor(rootNode) {\n        this.rootNode = rootNode;\n    }\n    toBase58() {\n        return this.rootNode.toBase58();\n    }\n    /**\n     * Initialize a Blockstack wallet from a seed buffer\n     * @param {Buffer} seed - the input seed for initializing the root node\n     *  of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n    static fromSeedBuffer(seed) {\n        return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n    }\n    /**\n     * Initialize a Blockstack wallet from a base58 string\n     * @param {string} keychain - the Base58 string used to initialize\n     *  the root node of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n    static fromBase58(keychain) {\n        return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromBase58(keychain));\n    }\n    /**\n     * Initialize a blockstack wallet from an encrypted phrase & password. Throws\n     * if the password is incorrect. Supports all formats of Blockstack phrases.\n     * @param {string} data - The encrypted phrase as a hex-encoded string\n     * @param {string} password - The plain password\n     * @return {Promise<BlockstackWallet>} the constructed wallet\n     *\n     * @ignore\n     */\n    static fromEncryptedMnemonic(data, password, triplesecDecrypt) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            try {\n                const mnemonic = yield wallet_1.decryptMnemonic(data, password, triplesecDecrypt);\n                const seed = yield bip39_1.mnemonicToSeed(mnemonic);\n                return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n            }\n            catch (err) {\n                if (err.message && err.message.startsWith('bad header;')) {\n                    throw new Error('Incorrect password');\n                }\n                else {\n                    throw err;\n                }\n            }\n        });\n    }\n    /**\n     * Generate a BIP-39 12 word mnemonic\n     * @return {Promise<string>} space-separated 12 word phrase\n     */\n    static generateMnemonic() {\n        return bip39_1.generateMnemonic(128, cryptoRandom_1.randomBytes);\n    }\n    /**\n     * Encrypt a mnemonic phrase with a password\n     * @param {string} mnemonic - Raw mnemonic phrase\n     * @param {string} password - Password to encrypt mnemonic with\n     * @return {Promise<string>} Hex-encoded encrypted mnemonic\n     *\n     */\n    static encryptMnemonic(mnemonic, password, opts) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const encryptedBuffer = yield wallet_1.encryptMnemonic(mnemonic, password, opts);\n            return encryptedBuffer.toString('hex');\n        });\n    }\n    getIdentityPrivateKeychain() {\n        return this.rootNode\n            .deriveHardened(IDENTITY_KEYCHAIN)\n            .deriveHardened(BLOCKSTACK_ON_BITCOIN);\n    }\n    getBitcoinPrivateKeychain() {\n        return this.rootNode\n            .deriveHardened(BITCOIN_BIP_44_PURPOSE)\n            .deriveHardened(BITCOIN_COIN_TYPE)\n            .deriveHardened(BITCOIN_ACCOUNT_INDEX);\n    }\n    getBitcoinNode(addressIndex, chainType = EXTERNAL_ADDRESS) {\n        return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n    }\n    getIdentityAddressNode(identityIndex) {\n        const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n        return identityPrivateKeychain.deriveHardened(identityIndex);\n    }\n    static getAppsNode(identityNode) {\n        return identityNode.deriveHardened(APPS_NODE_INDEX);\n    }\n    /**\n     * Get a salt for use with creating application specific addresses\n     * @return {String} the salt\n     */\n    getIdentitySalt() {\n        const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n        // NOTE: This is being decoded as a utf8 string rather than a hex string\n        const publicKeyHex = Buffer.from(getNodePublicKey(identityPrivateKeychain));\n        return sha2Hash_1.hashSha256Sync(publicKeyHex).toString('hex');\n    }\n    /**\n     * Get a bitcoin receive address at a given index\n     * @param {number} addressIndex - the index of the address\n     * @return {String} address\n     */\n    getBitcoinAddress(addressIndex) {\n        return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the private key hex-string for a given bitcoin receive address\n     * @param {number} addressIndex - the index of the address\n     * @return {String} the hex-string. this will be either 64\n     * characters long to denote an uncompressed bitcoin address, or 66\n     * characters long for a compressed bitcoin address.\n     */\n    getBitcoinPrivateKey(addressIndex) {\n        return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the root node for the bitcoin public keychain\n     * @return {String} base58-encoding of the public node\n     */\n    getBitcoinPublicKeychain() {\n        return this.getBitcoinPrivateKeychain().neutered();\n    }\n    /**\n     * Get the root node for the identity public keychain\n     * @return {String} base58-encoding of the public node\n     */\n    getIdentityPublicKeychain() {\n        return this.getIdentityPrivateKeychain().neutered();\n    }\n    static getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n        let chain;\n        if (chainType === EXTERNAL_ADDRESS) {\n            chain = 0;\n        }\n        else if (chainType === CHANGE_ADDRESS) {\n            chain = 1;\n        }\n        else {\n            throw new Error('Invalid chain type');\n        }\n        const keychain = bitcoinjs_lib_1.bip32.fromBase58(keychainBase58);\n        return keychain.derive(chain).derive(addressIndex);\n    }\n    /**\n     * Get a bitcoin address given a base-58 encoded bitcoin node\n     * (usually called the account node)\n     * @param {String} keychainBase58 - base58-encoding of the node\n     * @param {number} addressIndex - index of the address to get\n     * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\n     * \"receive\" address) or 'CHANGE_ADDRESS'\n     * @return {String} the address\n     */\n    static getAddressFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n        return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet\n            .getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n    static getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n        const appNode = getLegacyAppNode(appsNodeKey, salt, appDomain);\n        return getNodePrivateKey(appNode).slice(0, 64);\n    }\n    static getAddressFromBIP32Node(node) {\n        return bitcoinjs_lib_1.payments.p2pkh({ pubkey: node.publicKey }).address;\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n    static getAppPrivateKey(appsNodeKey, salt, appDomain) {\n        const hashBuffer = sha2Hash_1.hashSha256Sync(Buffer.from(`${appDomain}${salt}`));\n        const hash = hashBuffer.toString('hex');\n        const appIndexHexes = [];\n        // note: there's hardcoded numbers here, precisely because I want this\n        //   code to be very specific to the derivation paths we expect.\n        if (hash.length !== 64) {\n            throw new Error(`Unexpected app-domain hash length of ${hash.length}`);\n        }\n        for (let i = 0; i < 11; i++) { // split the hash into 3-byte chunks\n            // because child nodes can only be up to 2^31,\n            // and we shouldn't deal in partial bytes.\n            appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n        }\n        let appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey);\n        appIndexHexes.forEach((hex) => {\n            if (hex.length > 6) {\n                throw new Error('Invalid hex string length');\n            }\n            appNode = appNode.deriveHardened(parseInt(hex, 16));\n        });\n        return getNodePrivateKey(appNode).slice(0, 64);\n    }\n    /**\n     * Get the keypair information for a given identity index. This\n     * information is used to obtain the private key for an identity address\n     * and derive application specific keys for that address.\n     * @param {number} addressIndex - the identity index\n     * @param {boolean} alwaysUncompressed - if true, always return a\n     *   private-key hex string corresponding to the uncompressed address\n     * @return {Object} an IdentityKeyPair type object with keys:\n     *   .key {String} - the private key hex-string\n     *   .keyID {String} - the public key hex-string\n     *   .address {String} - the identity address\n     *   .appsNodeKey {String} - the base-58 encoding of the applications node\n     *   .salt {String} - the salt used for creating app-specific addresses\n     */\n    getIdentityKeyPair(addressIndex, alwaysUncompressed = false) {\n        const identityNode = this.getIdentityAddressNode(addressIndex);\n        const address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n        let identityKey = getNodePrivateKey(identityNode);\n        if (alwaysUncompressed && identityKey.length === 66) {\n            identityKey = identityKey.slice(0, 64);\n        }\n        const identityKeyID = getNodePublicKey(identityNode);\n        const appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n        const salt = this.getIdentitySalt();\n        const keyPair = {\n            key: identityKey,\n            keyID: identityKeyID,\n            address,\n            appsNodeKey,\n            salt\n        };\n        return keyPair;\n    }\n}\nexports.BlockstackWallet = BlockstackWallet;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}