{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst serviceUtils_1 = require(\"./serviceUtils\");\n\nconst fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\n\n\nclass Service {\n  validateProof(proof, ownerAddress, cheerio, name = null) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const proofUrl = this.getProofUrl(proof);\n        const res = yield fetchUtil_1.fetchPrivate(proofUrl);\n\n        if (res.status !== 200) {\n          throw new Error(`Proof url ${proofUrl} returned unexpected http status ${res.status}.\n            Unable to validate proof.`);\n        }\n\n        const text = yield res.text(); // Validate identity in provided proof body/tags if required\n\n        if (this.shouldValidateIdentityInBody() && proof.identifier !== this.getProofIdentity(text, cheerio)) {\n          return proof;\n        }\n\n        const proofText = this.getProofStatement(text, cheerio);\n        proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name) || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n        return proof;\n      } catch (error) {\n        console.error(error);\n        proof.valid = false;\n        return proof;\n      }\n    });\n  }\n\n  shouldValidateIdentityInBody() {\n    return false;\n  }\n\n  prefixScheme(proofUrl) {\n    if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n      return `https://${proofUrl}`;\n    } else if (proofUrl.startsWith('http://')) {\n      return proofUrl.replace('http://', 'https://');\n    } else {\n      return proofUrl;\n    }\n  }\n\n  getProofIdentity(searchText, _cheerio) {\n    return searchText;\n  }\n\n}\n\nexports.Service = Service;","map":{"version":3,"sources":["../../../src/profiles/services/service.ts"],"names":[],"mappings":";;;;;;;;AAAA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAKA;;;;;AAGA,MAAsB,OAAtB,CAA6B;AACrB,EAAA,aAAa,CAAC,KAAD,EACC,YADD,EAEC,OAFD,EAGC,IAAA,GAAe,IAHhB,EAGoB;;AAErC,UAAI;AACF,cAAM,QAAQ,GAAG,KAAK,WAAL,CAAiB,KAAjB,CAAjB;AACA,cAAM,GAAG,GAAG,MAAM,WAAA,CAAA,YAAA,CAAa,QAAb,CAAlB;;AACA,YAAI,GAAG,CAAC,MAAJ,KAAe,GAAnB,EAAwB;AACtB,gBAAM,IAAI,KAAJ,CAAU,aAAa,QAAQ,oCAAoC,GAAG,CAAC,MAAM;sCAA7E,CAAN;AAED;;AACD,cAAM,IAAI,GAAG,MAAM,GAAG,CAAC,IAAJ,EAAnB,CAPE,CASF;;AACA,YAAI,KAAK,4BAAL,MACG,KAAK,CAAC,UAAN,KAAqB,KAAK,gBAAL,CAAsB,IAAtB,EAA4B,OAA5B,CAD5B,EACkE;AAChE,iBAAO,KAAP;AACD;;AACD,cAAM,SAAS,GAAG,KAAK,iBAAL,CAAuB,IAAvB,EAA6B,OAA7B,CAAlB;AACA,QAAA,KAAK,CAAC,KAAN,GAAc,cAAA,CAAA,2BAAA,CAA4B,SAA5B,EAAuC,IAAvC,KACT,cAAA,CAAA,kCAAA,CAAmC,SAAnC,EAA8C,YAA9C,CADL;AAEA,eAAO,KAAP;AACD,OAlBD,CAkBE,OAAO,KAAP,EAAc;AACd,QAAA,OAAO,CAAC,KAAR,CAAc,KAAd;AACA,QAAA,KAAK,CAAC,KAAN,GAAc,KAAd;AACA,eAAO,KAAP;AACD;AACF,K;AAAA;;AAED,EAAA,4BAA4B,GAAA;AAC1B,WAAO,KAAP;AACD;;AAED,EAAA,YAAY,CAAC,QAAD,EAAiB;AAC3B,QAAI,CAAC,QAAQ,CAAC,UAAT,CAAoB,UAApB,CAAD,IAAoC,CAAC,QAAQ,CAAC,UAAT,CAAoB,SAApB,CAAzC,EAAyE;AACvE,aAAO,WAAW,QAAQ,EAA1B;AACD,KAFD,MAEO,IAAI,QAAQ,CAAC,UAAT,CAAoB,SAApB,CAAJ,EAAoC;AACzC,aAAO,QAAQ,CAAC,OAAT,CAAiB,SAAjB,EAA4B,UAA5B,CAAP;AACD,KAFM,MAEA;AACL,aAAO,QAAP;AACD;AACF;;AAED,EAAA,gBAAgB,CAAC,UAAD,EAAqB,QAArB,EAAgD;AAC9D,WAAO,UAAP;AACD;;AA/C0B;;AAA7B,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst serviceUtils_1 = require(\"./serviceUtils\");\nconst fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\nclass Service {\n    validateProof(proof, ownerAddress, cheerio, name = null) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            try {\n                const proofUrl = this.getProofUrl(proof);\n                const res = yield fetchUtil_1.fetchPrivate(proofUrl);\n                if (res.status !== 200) {\n                    throw new Error(`Proof url ${proofUrl} returned unexpected http status ${res.status}.\n            Unable to validate proof.`);\n                }\n                const text = yield res.text();\n                // Validate identity in provided proof body/tags if required\n                if (this.shouldValidateIdentityInBody()\n                    && proof.identifier !== this.getProofIdentity(text, cheerio)) {\n                    return proof;\n                }\n                const proofText = this.getProofStatement(text, cheerio);\n                proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name)\n                    || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n                return proof;\n            }\n            catch (error) {\n                console.error(error);\n                proof.valid = false;\n                return proof;\n            }\n        });\n    }\n    shouldValidateIdentityInBody() {\n        return false;\n    }\n    prefixScheme(proofUrl) {\n        if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n            return `https://${proofUrl}`;\n        }\n        else if (proofUrl.startsWith('http://')) {\n            return proofUrl.replace('http://', 'https://');\n        }\n        else {\n            return proofUrl;\n        }\n    }\n    getProofIdentity(searchText, _cheerio) {\n        return searchText;\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=service.js.map"]},"metadata":{},"sourceType":"script"}