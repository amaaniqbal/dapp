{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64url_1 = __importDefault(require(\"base64url\"));\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nclass TokenVerifier {\n  constructor(signingAlgorithm, rawPublicKey) {\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n\n  verify(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token);\n    } else {\n      return false;\n    }\n  }\n\n  verifyCompact(token) {\n    // decompose the token into parts\n    const tokenParts = token.split('.'); // calculate the signing input hash\n\n    const signingInput = tokenParts[0] + '.' + tokenParts[1];\n    const signingInputHash = this.cryptoClient.createHash(signingInput); // extract the signature as a DER array\n\n    const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]); // verify the signed hash\n\n    return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n  }\n\n  verifyExpanded(token) {\n    const signingInput = [token['header'].join('.'), base64url_1.default.encode(token['payload'])].join('.');\n    const signingInputHash = this.cryptoClient.createHash(signingInput);\n    let verified = true;\n    token['signature'].map(signature => {\n      const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n      const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n\n      if (!signatureVerified) {\n        verified = false;\n      }\n    });\n    return verified;\n  }\n\n}\n\nexports.TokenVerifier = TokenVerifier;","map":{"version":3,"sources":["verifier.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,MAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAGA,MAAa,aAAb,CAA0B;AAMtB,EAAA,WAAA,CAAY,gBAAZ,EAAsC,YAAtC,EAA0D;AACtD,QAAI,EAAE,gBAAgB,IAAI,YAAtB,CAAJ,EAAyC;AACrC,YAAM,IAAI,QAAA,CAAA,sBAAJ,CACF,iDADE,CAAN;AAEH;;AACD,QAAI,OAAO,gBAAP,KAA4B,QAAhC,EAA0C;AACtC,YAAM,8CAAN;AACH;;AACD,IAAA,gBAAgB,GAAG,gBAAgB,CAAC,WAAjB,EAAnB;;AACA,QAAI,CAAC,eAAA,CAAA,aAAA,CAAc,cAAd,CAA6B,gBAA7B,CAAL,EAAqD;AACjD,YAAM,2BAAN;AACH;;AACD,SAAK,SAAL,GAAiB,KAAjB;AACA,SAAK,YAAL,GAAoB,eAAA,CAAA,aAAA,CAAc,gBAAd,CAApB;AACA,SAAK,YAAL,GAAoB,YAApB;AACH;;AAED,EAAA,MAAM,CAAC,KAAD,EAA4B;AAC9B,QAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,aAAO,KAAK,aAAL,CAAmB,KAAnB,CAAP;AACH,KAFD,MAEO,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAClC,aAAO,KAAK,cAAL,CAAoB,KAApB,CAAP;AACH,KAFM,MAEA;AACH,aAAO,KAAP;AACH;AACJ;;AAED,EAAA,aAAa,CAAC,KAAD,EAAc;AACvB;AACA,UAAM,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,GAAZ,CAAnB,CAFuB,CAIvB;;AACA,UAAM,YAAY,GAAG,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAhB,GAAsB,UAAU,CAAC,CAAD,CAArD;AACA,UAAM,gBAAgB,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,YAA7B,CAAzB,CANuB,CAQvB;;AACA,UAAM,kBAAkB,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,UAAU,CAAC,CAAD,CAA1C,CAA3B,CATuB,CAWvB;;AACA,WAAO,KAAK,YAAL,CAAkB,UAAlB,CACH,gBADG,EACe,kBADf,EACmC,KAAK,YADxC,CAAP;AAEH;;AAED,EAAA,cAAc,CAAC,KAAD,EAAmB;AAC7B,UAAM,YAAY,GAAG,CACjB,KAAK,CAAC,QAAD,CAAL,CAAgB,IAAhB,CAAqB,GAArB,CADiB,EAEjB,WAAA,CAAA,OAAA,CAAU,MAAV,CAAiB,KAAK,CAAC,SAAD,CAAtB,CAFiB,EAGnB,IAHmB,CAGd,GAHc,CAArB;AAIA,UAAM,gBAAgB,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,YAA7B,CAAzB;AAEA,QAAI,QAAQ,GAAG,IAAf;AAEA,IAAA,KAAK,CAAC,WAAD,CAAL,CAAmB,GAAnB,CAAwB,SAAD,IAAsB;AACzC,YAAM,kBAAkB,GAAG,KAAK,YAAL,CAAkB,aAAlB,CAAgC,SAAhC,CAA3B;AACA,YAAM,iBAAiB,GAAG,KAAK,YAAL,CAAkB,UAAlB,CACtB,gBADsB,EACJ,kBADI,EACgB,KAAK,YADrB,CAA1B;;AAEA,UAAI,CAAC,iBAAL,EAAwB;AACpB,QAAA,QAAQ,GAAG,KAAX;AACH;AACJ,KAPD;AASA,WAAO,QAAP;AACH;;AApEqB;;AAA1B,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"./","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64url_1 = __importDefault(require(\"base64url\"));\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nclass TokenVerifier {\n    constructor(signingAlgorithm, rawPublicKey) {\n        if (!(signingAlgorithm && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw 'signing algorithm parameter must be a string';\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw 'invalid signing algorithm';\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPublicKey = rawPublicKey;\n    }\n    verify(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token);\n        }\n        else {\n            return false;\n        }\n    }\n    verifyCompact(token) {\n        // decompose the token into parts\n        const tokenParts = token.split('.');\n        // calculate the signing input hash\n        const signingInput = tokenParts[0] + '.' + tokenParts[1];\n        const signingInputHash = this.cryptoClient.createHash(signingInput);\n        // extract the signature as a DER array\n        const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]);\n        // verify the signed hash\n        return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n    }\n    verifyExpanded(token) {\n        const signingInput = [\n            token['header'].join('.'),\n            base64url_1.default.encode(token['payload'])\n        ].join('.');\n        const signingInputHash = this.cryptoClient.createHash(signingInput);\n        let verified = true;\n        token['signature'].map((signature) => {\n            const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n            const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n            if (!signatureVerified) {\n                verified = false;\n            }\n        });\n        return verified;\n    }\n}\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map"]},"metadata":{},"sourceType":"script"}