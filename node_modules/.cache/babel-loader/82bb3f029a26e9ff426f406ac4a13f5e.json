{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\"); // @ts-ignore\n\n\nconst BN = require(\"bn.js\");\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\"); // todo : add name length / character verification\n\n/**\n* @ignore\n*/\n\n\nclass BlockstackNamespace {\n  constructor(namespaceID) {\n    if (namespaceID.length > 19) {\n      throw new Error('Namespace ID too long (19 chars max)');\n    }\n\n    if (!namespaceID.match('[0123456789abcdefghijklmnopqrstuvwxyz_-]+')) {\n      throw new Error('Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_');\n    }\n\n    this.namespaceID = namespaceID;\n    this.version = -1;\n    this.lifetime = -1;\n    this.coeff = -1;\n    this.base = -1;\n    this.buckets = [-1];\n    this.nonalphaDiscount = -1;\n    this.noVowelDiscount = -1;\n  }\n\n  check() {\n    try {\n      this.setVersion(this.version);\n      this.setLifetime(this.lifetime);\n      this.setCoeff(this.coeff);\n      this.setBase(this.base);\n      this.setBuckets(this.buckets);\n      this.setNonalphaDiscount(this.nonalphaDiscount);\n      this.setNoVowelDiscount(this.noVowelDiscount);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  setVersion(version) {\n    if (version < 0 || version > Math.pow(2, 16) - 1) {\n      throw new Error('Invalid version: must be a 16-bit number');\n    }\n\n    this.version = version;\n  }\n\n  setLifetime(lifetime) {\n    if (lifetime < 0 || lifetime > Math.pow(2, 32) - 1) {\n      throw new Error('Invalid lifetime: must be a 32-bit number');\n    }\n\n    this.lifetime = lifetime;\n  }\n\n  setCoeff(coeff) {\n    if (coeff < 0 || coeff > 255) {\n      throw new Error('Invalid coeff: must be an 8-bit number');\n    }\n\n    this.coeff = coeff;\n  }\n\n  setBase(base) {\n    if (base < 0 || base > 255) {\n      throw new Error('Invalid base: must be an 8-bit number');\n    }\n\n    this.base = base;\n  }\n\n  setBuckets(buckets) {\n    if (buckets.length !== 16) {\n      throw new Error('Invalid buckets: must have 16 entries');\n    }\n\n    for (let i = 0; i < buckets.length; i++) {\n      if (buckets[i] < 0 || buckets[i] > 15) {\n        throw new Error('Invalid buckets: must be 4-bit numbers');\n      }\n    }\n\n    this.buckets = buckets.slice(0);\n  }\n\n  setNonalphaDiscount(nonalphaDiscount) {\n    if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {\n      throw new Error('Invalid nonalphaDiscount: must be a positive 4-bit number');\n    }\n\n    this.nonalphaDiscount = nonalphaDiscount;\n  }\n\n  setNoVowelDiscount(noVowelDiscount) {\n    if (noVowelDiscount <= 0 || noVowelDiscount > 15) {\n      throw new Error('Invalid noVowelDiscount: must be a positive 4-bit number');\n    }\n\n    this.noVowelDiscount = noVowelDiscount;\n  }\n\n  toHexPayload() {\n    const lifeHex = `00000000${this.lifetime.toString(16)}`.slice(-8);\n    const coeffHex = `00${this.coeff.toString(16)}`.slice(-2);\n    const baseHex = `00${this.base.toString(16)}`.slice(-2);\n    const bucketHex = this.buckets.map(b => b.toString(16)).reduce((b1, b2) => b1 + b2, '');\n    const discountHex = this.nonalphaDiscount.toString(16) + this.noVowelDiscount.toString(16);\n    const versionHex = `0000${this.version.toString(16)}`.slice(-4);\n    const namespaceIDHex = Buffer.from(this.namespaceID).toString('hex');\n    return lifeHex + coeffHex + baseHex + bucketHex + discountHex + versionHex + namespaceIDHex;\n  }\n\n}\n\nexports.BlockstackNamespace = BlockstackNamespace;\n/**\n* @ignore\n*/\n\nfunction asAmountV2(amount) {\n  // convert an AmountType v1 or v2 to an AmountTypeV2.\n  // the \"units\" of a v1 amount type are always 'BTC'\n  if (typeof amount === 'number') {\n    return {\n      units: 'BTC',\n      amount: new BN(String(amount))\n    };\n  } else {\n    return {\n      units: amount.units,\n      amount: amount.amount\n    };\n  }\n}\n/**\n* @ignore\n*/\n\n\nfunction makeTXbuilder() {\n  const txb = new bitcoinjs_lib_1.TransactionBuilder(config_1.config.network.layer1);\n  txb.setVersion(1);\n  return txb;\n}\n/**\n* @ignore\n*/\n\n\nfunction opEncode(opcode) {\n  // NOTE: must *always* a 3-character string\n  const res = `${config_1.config.network.MAGIC_BYTES}${opcode}`;\n\n  if (res.length !== 3) {\n    throw new Error('Runtime error: invalid MAGIC_BYTES');\n  }\n\n  return res;\n}\n/**\n* @ignore\n*/\n\n\nfunction makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burn, registerAddress = null) {\n  // Returns a preorder tx skeleton.\n  //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data\n  //                    2. the Preorder's change address (5500 satoshi minimum)\n  //                    3. the BURN\n  //\n  // 0     2  3                                     23             39          47            66\n  // |-----|--|--------------------------------------|--------------|-----------|-------------|\n  // magic op  hash160(fqn,scriptPubkey,registerAddr) consensus hash token burn  token type\n  //                                                                 (optional)   (optional)\n  //\n  // output 0: name preorder code\n  // output 1: preorder address\n  // output 2: burn address\n  //\n  // Returns an unsigned serialized transaction.\n  const burnAmount = asAmountV2(burn);\n  const network = config_1.config.network;\n  const nameBuff = Buffer.from(utils_1.decodeB40(fullyQualifiedName), 'hex'); // base40\n\n  const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);\n  const dataBuffers = [nameBuff, scriptPublicKey];\n\n  if (!!registerAddress) {\n    const registerBuff = Buffer.from(registerAddress, 'ascii');\n    dataBuffers.push(registerBuff);\n  }\n\n  const dataBuff = Buffer.concat(dataBuffers);\n  const hashed = utils_1.hash160(dataBuff);\n  const opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;\n  const opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n  opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');\n  hashed.copy(opReturnBuffer, 3);\n  opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n\n  if (burnAmount.units !== 'BTC') {\n    const burnHex = burnAmount.amount.toString(16, 2);\n\n    if (burnHex.length > 16) {\n      // exceeds 2**64; can't fit\n      throw new Error(`Cannot preorder '${fullyQualifiedName}': cannot fit price into 8 bytes`);\n    }\n\n    const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);\n    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n    opReturnBuffer.write(burnAmount.units, 47, burnAmount.units.length, 'ascii');\n  }\n\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);\n\n  if (burnAmount.units === 'BTC') {\n    const btcBurnAmount = burnAmount.amount.toNumber();\n    tx.addOutput(burnAddress, btcBurnAmount);\n  } else {\n    tx.addOutput(burnAddress, utils_1.DUST_MINIMUM);\n  }\n\n  return tx.buildIncomplete();\n}\n\nexports.makePreorderSkeleton = makePreorderSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeRegisterSkeleton(fullyQualifiedName, ownerAddress, valueHash = null, burnTokenAmountHex = null) {\n  // Returns a register tx skeleton.\n  //   with 2 outputs : 1. The register OP_RETURN\n  //                    2. The owner address (can be different from REGISTER address on renewals)\n  // You MUST make the first input a UTXO from the current OWNER *or* the\n  //   funder of the PREORDER\n  // in the case of a renewal, this would need to be modified to include a change address\n  //  as output (3) before the burn output (4)\n\n  /*\n    Formats\n       No zonefile hash, and pay with BTC:\n       0    2  3                                  39\n    |----|--|----------------------------------|\n    magic op   name.ns_id (up to 37 bytes)\n   \n    With zonefile hash, and pay with BTC:\n       0    2  3                                  39                  59\n    |----|--|----------------------------------|-------------------|\n    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n       output 0: name registration code\n    output 1: owner address\n  */\n  let payload;\n\n  if (!!burnTokenAmountHex && !valueHash) {\n    // empty value hash\n    valueHash = '0000000000000000000000000000000000000000';\n  }\n\n  if (!!valueHash) {\n    if (valueHash.length !== 40) {\n      throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');\n    }\n\n    if (!!burnTokenAmountHex) {\n      if (burnTokenAmountHex.length !== 16) {\n        throw new Error('Burn field length incorrect.  Expecting 8-bytes, hex-encoded');\n      }\n    }\n\n    const payloadLen = burnTokenAmountHex ? 65 : 57;\n    payload = Buffer.alloc(payloadLen, 0);\n    payload.write(fullyQualifiedName, 0, 37, 'ascii');\n    payload.write(valueHash, 37, 20, 'hex');\n\n    if (!!burnTokenAmountHex) {\n      payload.write(burnTokenAmountHex, 57, 8, 'hex');\n    }\n  } else {\n    payload = Buffer.from(fullyQualifiedName, 'ascii');\n  }\n\n  const opReturnBuffer = Buffer.concat([Buffer.from(opEncode(':'), 'ascii'), payload]);\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(ownerAddress, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeRegisterSkeleton = makeRegisterSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burn, valueHash = null) {\n  /*\n    Formats\n       No zonefile hash, and pay with BTC:\n       0    2  3                                  39\n    |----|--|----------------------------------|\n    magic op   name.ns_id (up to 37 bytes)\n   \n    With zonefile hash, and pay with BTC:\n       0    2  3                                  39                  59\n    |----|--|----------------------------------|-------------------|\n    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n   \n   With renewal payment in a token:\n   (for register, tokens burned is not included)\n   (for renew, tokens burned is the number of tokens to burn)\n      0    2  3                                  39                  59                            67\n   |----|--|----------------------------------|-------------------|------------------------------|\n   magic op   name.ns_id (37 bytes, 0-padded)     zone file hash    tokens burned (big-endian)\n      output 0: renewal code\n   output 1: new owner address\n   output 2: current owner address\n   output 3: burn address\n  */\n  const burnAmount = asAmountV2(burn);\n  const network = config_1.config.network;\n  const burnTokenAmount = burnAmount.units === 'BTC' ? null : burnAmount.amount;\n  const burnBTCAmount = burnAmount.units === 'BTC' ? burnAmount.amount.toNumber() : utils_1.DUST_MINIMUM;\n  let burnTokenHex = null;\n\n  if (!!burnTokenAmount) {\n    const burnHex = burnTokenAmount.toString(16, 2);\n\n    if (burnHex.length > 16) {\n      // exceeds 2**64; can't fit \n      throw new Error(`Cannot renew '${fullyQualifiedName}': cannot fit price into 8 bytes`);\n    }\n\n    burnTokenHex = `0000000000000000${burnHex}`.slice(-16);\n  }\n\n  const registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash, burnTokenHex);\n  const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerTX, network.layer1);\n  txB.addOutput(lastOwnerAddress, utils_1.DUST_MINIMUM);\n  txB.addOutput(burnAddress, burnBTCAmount);\n  return txB.buildIncomplete();\n}\n\nexports.makeRenewalSkeleton = makeRenewalSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner, keepZonefile = false) {\n  // Returns a transfer tx skeleton.\n  //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data\n  //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction.\n\n  /*\n    Format\n       0     2  3    4                   20              36\n    |-----|--|----|-------------------|---------------|\n    magic op keep  hash128(name.ns_id) consensus hash\n             data?\n       output 0: transfer code\n    output 1: new owner\n  */\n  const opRet = Buffer.alloc(36);\n  let keepChar = '~';\n\n  if (keepZonefile) {\n    keepChar = '>';\n  }\n\n  opRet.write(opEncode('>'), 0, 3, 'ascii');\n  opRet.write(keepChar, 3, 1, 'ascii');\n  const hashed = utils_1.hash128(Buffer.from(fullyQualifiedName, 'ascii'));\n  hashed.copy(opRet, 4);\n  opRet.write(consensusHash, 20, 16, 'hex');\n  const opRetPayload = bitcoinjs_lib_1.payments.embed({\n    data: [opRet]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(opRetPayload, 0);\n  tx.addOutput(newOwner, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeTransferSkeleton = makeTransferSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {\n  // Returns an update tx skeleton.\n  //   with 1 output : 1. the Blockstack update OP_RETURN\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction.\n  //\n  // output 0: the revoke code\n\n  /*\n    Format:\n       0     2  3                                   19                      39\n    |-----|--|-----------------------------------|-----------------------|\n    magic op  hash128(name.ns_id,consensus hash) hash160(data)\n       output 0: update code\n  */\n  const opRet = Buffer.alloc(39);\n  const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n  const consensusBuff = Buffer.from(consensusHash, 'ascii');\n  const hashedName = utils_1.hash128(Buffer.concat([nameBuff, consensusBuff]));\n  opRet.write(opEncode('+'), 0, 3, 'ascii');\n  hashedName.copy(opRet, 3);\n  opRet.write(valueHash, 19, 20, 'hex');\n  const opRetPayload = bitcoinjs_lib_1.payments.embed({\n    data: [opRet]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(opRetPayload, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeUpdateSkeleton = makeUpdateSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeRevokeSkeleton(fullyQualifiedName) {\n  // Returns a revoke tx skeleton\n  //    with 1 output: 1. the Blockstack revoke OP_RETURN\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction\n\n  /*\n   Format:\n      0    2  3                             39\n   |----|--|-----------------------------|\n   magic op   name.ns_id (37 bytes)\n      output 0: the revoke code\n  */\n  const opRet = Buffer.alloc(3);\n  const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n  opRet.write(opEncode('~'), 0, 3, 'ascii');\n  const opReturnBuffer = Buffer.concat([opRet, nameBuff]);\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeRevokeSkeleton = makeRevokeSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, registerAddress, burn) {\n  // Returns a namespace preorder tx skeleton.\n  // Returns an unsigned serialized transaction.\n\n  /*\n   Formats:\n      Without STACKS:\n      0     2   3                                      23               39\n   |-----|---|--------------------------------------|----------------|\n   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash\n   \n   with STACKs:\n      0     2   3                                      23               39                         47\n   |-----|---|--------------------------------------|----------------|--------------------------|\n   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash    token fee (big-endian)\n      output 0: namespace preorder code\n   output 1: change address\n   otuput 2: burn address\n  */\n  const burnAmount = asAmountV2(burn);\n\n  if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {\n    throw new Error(`Invalid burnUnits ${burnAmount.units}`);\n  }\n\n  const network = config_1.config.network;\n  const burnAddress = network.getDefaultBurnAddress();\n  const namespaceIDBuff = Buffer.from(utils_1.decodeB40(namespaceID), 'hex'); // base40\n\n  const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);\n  const registerBuff = Buffer.from(registerAddress, 'ascii');\n  const dataBuffers = [namespaceIDBuff, scriptPublicKey, registerBuff];\n  const dataBuff = Buffer.concat(dataBuffers);\n  const hashed = utils_1.hash160(dataBuff);\n  let btcBurnAmount = utils_1.DUST_MINIMUM;\n  let opReturnBufferLen = 39;\n\n  if (burnAmount.units === 'STACKS') {\n    opReturnBufferLen = 47;\n  } else {\n    btcBurnAmount = burnAmount.amount.toNumber();\n  }\n\n  const opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n  opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');\n  hashed.copy(opReturnBuffer, 3);\n  opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n\n  if (burnAmount.units === 'STACKS') {\n    const burnHex = burnAmount.amount.toString(16, 2);\n    const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);\n    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n  }\n\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);\n  tx.addOutput(burnAddress, btcBurnAmount);\n  return tx.buildIncomplete();\n}\n\nexports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeNamespaceRevealSkeleton(namespace, revealAddress) {\n  /*\n   Format:\n      0     2   3    7     8     9    10   11   12   13   14    15    16    17       18      20     39\n   |-----|---|----|-----|-----|----|----|----|----|----|-----|-----|-----|--------|-------|-------|\n   magic  op  life coeff. base 1-2  3-4  5-6  7-8  9-10 11-12 13-14 15-16 nonalpha version  ns ID\n                                                  bucket exponents        no-vowel\n                                                                          discounts\n   \n   output 0: namespace reveal code\n   output 1: reveal address\n  */\n  const hexPayload = namespace.toHexPayload();\n  const opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);\n  opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');\n  opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(revealAddress, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeNamespaceReadySkeleton(namespaceID) {\n  /*\n   Format:\n      0     2  3  4           23\n   |-----|--|--|------------|\n   magic op  .  ns_id\n      output 0: namespace ready code\n   */\n  const opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);\n  opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');\n  opReturnBuffer.write(`.${namespaceID}`, 3, namespaceID.length + 1, 'ascii');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton; // type bitcoin.payments.p2data bitcoin.payments.embed\n\n/**\n* @ignore\n*/\n\nfunction makeNameImportSkeleton(name, recipientAddr, zonefileHash) {\n  /*\n   Format:\n       0    2  3                             39\n    |----|--|-----------------------------|\n    magic op   name.ns_id (37 bytes)\n      Output 0: the OP_RETURN\n   Output 1: the recipient\n   Output 2: the zonefile hash\n  */\n  if (zonefileHash.length !== 40) {\n    throw new Error('Invalid zonefile hash: must be 20 bytes hex-encoded');\n  }\n\n  const network = config_1.config.network;\n  const opReturnBuffer = Buffer.alloc(3 + name.length);\n  opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');\n  opReturnBuffer.write(name, 3, name.length, 'ascii');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  const zonefileHashB58 = bitcoinjs_lib_1.address.toBase58Check(Buffer.from(zonefileHash, 'hex'), network.layer1.pubKeyHash);\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(recipientAddr, utils_1.DUST_MINIMUM);\n  tx.addOutput(zonefileHashB58, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeNameImportSkeleton = makeNameImportSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeAnnounceSkeleton(messageHash) {\n  /*\n    Format:\n       0    2  3                             23\n    |----|--|-----------------------------|\n    magic op   message hash (160-bit)\n       output 0: the OP_RETURN\n  */\n  if (messageHash.length !== 40) {\n    throw new Error('Invalid message hash: must be 20 bytes hex-encoded');\n  }\n\n  const opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);\n  opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');\n  opReturnBuffer.write(messageHash, 3, messageHash.length / 2, 'hex');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeAnnounceSkeleton = makeAnnounceSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea) {\n  /*\n   Format:\n       0     2  3              19         38          46                        80\n    |-----|--|--------------|----------|-----------|-------------------------|\n    magic op  consensus_hash token_type amount (BE) scratch area\n                             (ns_id)\n       output 0: token transfer code\n    output 1: recipient address\n  */\n  if (scratchArea.length > 34) {\n    throw new Error('Invalid scratch area: must be no more than 34 bytes');\n  }\n\n  const opReturnBuffer = Buffer.alloc(46 + scratchArea.length);\n  const tokenTypeHex = Buffer.from(tokenType).toString('hex');\n  const tokenTypeHexPadded = `00000000000000000000000000000000000000${tokenTypeHex}`.slice(-38);\n  const tokenValueHex = tokenAmount.toString(16, 2);\n\n  if (tokenValueHex.length > 16) {\n    // exceeds 2**64; can't fit\n    throw new Error(`Cannot send tokens: cannot fit ${tokenAmount.toString()} into 8 bytes`);\n  }\n\n  const tokenValueHexPadded = `0000000000000000${tokenValueHex}`.slice(-16);\n  opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');\n  opReturnBuffer.write(consensusHash, 3, consensusHash.length / 2, 'hex');\n  opReturnBuffer.write(tokenTypeHexPadded, 19, tokenTypeHexPadded.length / 2, 'hex');\n  opReturnBuffer.write(tokenValueHexPadded, 38, tokenValueHexPadded.length / 2, 'hex');\n  opReturnBuffer.write(scratchArea, 46, scratchArea.length, 'ascii');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(recipientAddress, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;","map":{"version":3,"sources":["../../src/operations/skeletons.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n// @ts-ignore\nconst BN = require(\"bn.js\");\nconst utils_1 = require(\"./utils\");\nconst config_1 = require(\"../config\");\n// todo : add name length / character verification\n/**\n* @ignore\n*/\nclass BlockstackNamespace {\n    constructor(namespaceID) {\n        if (namespaceID.length > 19) {\n            throw new Error('Namespace ID too long (19 chars max)');\n        }\n        if (!namespaceID.match('[0123456789abcdefghijklmnopqrstuvwxyz_-]+')) {\n            throw new Error('Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_');\n        }\n        this.namespaceID = namespaceID;\n        this.version = -1;\n        this.lifetime = -1;\n        this.coeff = -1;\n        this.base = -1;\n        this.buckets = [-1];\n        this.nonalphaDiscount = -1;\n        this.noVowelDiscount = -1;\n    }\n    check() {\n        try {\n            this.setVersion(this.version);\n            this.setLifetime(this.lifetime);\n            this.setCoeff(this.coeff);\n            this.setBase(this.base);\n            this.setBuckets(this.buckets);\n            this.setNonalphaDiscount(this.nonalphaDiscount);\n            this.setNoVowelDiscount(this.noVowelDiscount);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    setVersion(version) {\n        if (version < 0 || version > Math.pow(2, 16) - 1) {\n            throw new Error('Invalid version: must be a 16-bit number');\n        }\n        this.version = version;\n    }\n    setLifetime(lifetime) {\n        if (lifetime < 0 || lifetime > Math.pow(2, 32) - 1) {\n            throw new Error('Invalid lifetime: must be a 32-bit number');\n        }\n        this.lifetime = lifetime;\n    }\n    setCoeff(coeff) {\n        if (coeff < 0 || coeff > 255) {\n            throw new Error('Invalid coeff: must be an 8-bit number');\n        }\n        this.coeff = coeff;\n    }\n    setBase(base) {\n        if (base < 0 || base > 255) {\n            throw new Error('Invalid base: must be an 8-bit number');\n        }\n        this.base = base;\n    }\n    setBuckets(buckets) {\n        if (buckets.length !== 16) {\n            throw new Error('Invalid buckets: must have 16 entries');\n        }\n        for (let i = 0; i < buckets.length; i++) {\n            if (buckets[i] < 0 || buckets[i] > 15) {\n                throw new Error('Invalid buckets: must be 4-bit numbers');\n            }\n        }\n        this.buckets = buckets.slice(0);\n    }\n    setNonalphaDiscount(nonalphaDiscount) {\n        if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {\n            throw new Error('Invalid nonalphaDiscount: must be a positive 4-bit number');\n        }\n        this.nonalphaDiscount = nonalphaDiscount;\n    }\n    setNoVowelDiscount(noVowelDiscount) {\n        if (noVowelDiscount <= 0 || noVowelDiscount > 15) {\n            throw new Error('Invalid noVowelDiscount: must be a positive 4-bit number');\n        }\n        this.noVowelDiscount = noVowelDiscount;\n    }\n    toHexPayload() {\n        const lifeHex = `00000000${this.lifetime.toString(16)}`.slice(-8);\n        const coeffHex = `00${this.coeff.toString(16)}`.slice(-2);\n        const baseHex = `00${this.base.toString(16)}`.slice(-2);\n        const bucketHex = this.buckets.map(b => b.toString(16)).reduce((b1, b2) => b1 + b2, '');\n        const discountHex = this.nonalphaDiscount.toString(16) + this.noVowelDiscount.toString(16);\n        const versionHex = `0000${this.version.toString(16)}`.slice(-4);\n        const namespaceIDHex = Buffer.from(this.namespaceID).toString('hex');\n        return lifeHex + coeffHex + baseHex + bucketHex + discountHex + versionHex + namespaceIDHex;\n    }\n}\nexports.BlockstackNamespace = BlockstackNamespace;\n/**\n* @ignore\n*/\nfunction asAmountV2(amount) {\n    // convert an AmountType v1 or v2 to an AmountTypeV2.\n    // the \"units\" of a v1 amount type are always 'BTC'\n    if (typeof amount === 'number') {\n        return { units: 'BTC', amount: new BN(String(amount)) };\n    }\n    else {\n        return { units: amount.units, amount: amount.amount };\n    }\n}\n/**\n* @ignore\n*/\nfunction makeTXbuilder() {\n    const txb = new bitcoinjs_lib_1.TransactionBuilder(config_1.config.network.layer1);\n    txb.setVersion(1);\n    return txb;\n}\n/**\n* @ignore\n*/\nfunction opEncode(opcode) {\n    // NOTE: must *always* a 3-character string\n    const res = `${config_1.config.network.MAGIC_BYTES}${opcode}`;\n    if (res.length !== 3) {\n        throw new Error('Runtime error: invalid MAGIC_BYTES');\n    }\n    return res;\n}\n/**\n* @ignore\n*/\nfunction makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burn, registerAddress = null) {\n    // Returns a preorder tx skeleton.\n    //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data\n    //                    2. the Preorder's change address (5500 satoshi minimum)\n    //                    3. the BURN\n    //\n    // 0     2  3                                     23             39          47            66\n    // |-----|--|--------------------------------------|--------------|-----------|-------------|\n    // magic op  hash160(fqn,scriptPubkey,registerAddr) consensus hash token burn  token type\n    //                                                                 (optional)   (optional)\n    //\n    // output 0: name preorder code\n    // output 1: preorder address\n    // output 2: burn address\n    //\n    // Returns an unsigned serialized transaction.\n    const burnAmount = asAmountV2(burn);\n    const network = config_1.config.network;\n    const nameBuff = Buffer.from(utils_1.decodeB40(fullyQualifiedName), 'hex'); // base40\n    const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);\n    const dataBuffers = [nameBuff, scriptPublicKey];\n    if (!!registerAddress) {\n        const registerBuff = Buffer.from(registerAddress, 'ascii');\n        dataBuffers.push(registerBuff);\n    }\n    const dataBuff = Buffer.concat(dataBuffers);\n    const hashed = utils_1.hash160(dataBuff);\n    const opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;\n    const opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n    opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');\n    hashed.copy(opReturnBuffer, 3);\n    opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n    if (burnAmount.units !== 'BTC') {\n        const burnHex = burnAmount.amount.toString(16, 2);\n        if (burnHex.length > 16) {\n            // exceeds 2**64; can't fit\n            throw new Error(`Cannot preorder '${fullyQualifiedName}': cannot fit price into 8 bytes`);\n        }\n        const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);\n        opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n        opReturnBuffer.write(burnAmount.units, 47, burnAmount.units.length, 'ascii');\n    }\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);\n    if (burnAmount.units === 'BTC') {\n        const btcBurnAmount = burnAmount.amount.toNumber();\n        tx.addOutput(burnAddress, btcBurnAmount);\n    }\n    else {\n        tx.addOutput(burnAddress, utils_1.DUST_MINIMUM);\n    }\n    return tx.buildIncomplete();\n}\nexports.makePreorderSkeleton = makePreorderSkeleton;\n/**\n* @ignore\n*/\nfunction makeRegisterSkeleton(fullyQualifiedName, ownerAddress, valueHash = null, burnTokenAmountHex = null) {\n    // Returns a register tx skeleton.\n    //   with 2 outputs : 1. The register OP_RETURN\n    //                    2. The owner address (can be different from REGISTER address on renewals)\n    // You MUST make the first input a UTXO from the current OWNER *or* the\n    //   funder of the PREORDER\n    // in the case of a renewal, this would need to be modified to include a change address\n    //  as output (3) before the burn output (4)\n    /*\n      Formats\n  \n      No zonefile hash, and pay with BTC:\n  \n      0    2  3                                  39\n      |----|--|----------------------------------|\n      magic op   name.ns_id (up to 37 bytes)\n  \n  \n      With zonefile hash, and pay with BTC:\n  \n      0    2  3                                  39                  59\n      |----|--|----------------------------------|-------------------|\n      magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n  \n      output 0: name registration code\n      output 1: owner address\n    */\n    let payload;\n    if (!!burnTokenAmountHex && !valueHash) {\n        // empty value hash\n        valueHash = '0000000000000000000000000000000000000000';\n    }\n    if (!!valueHash) {\n        if (valueHash.length !== 40) {\n            throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');\n        }\n        if (!!burnTokenAmountHex) {\n            if (burnTokenAmountHex.length !== 16) {\n                throw new Error('Burn field length incorrect.  Expecting 8-bytes, hex-encoded');\n            }\n        }\n        const payloadLen = burnTokenAmountHex ? 65 : 57;\n        payload = Buffer.alloc(payloadLen, 0);\n        payload.write(fullyQualifiedName, 0, 37, 'ascii');\n        payload.write(valueHash, 37, 20, 'hex');\n        if (!!burnTokenAmountHex) {\n            payload.write(burnTokenAmountHex, 57, 8, 'hex');\n        }\n    }\n    else {\n        payload = Buffer.from(fullyQualifiedName, 'ascii');\n    }\n    const opReturnBuffer = Buffer.concat([Buffer.from(opEncode(':'), 'ascii'), payload]);\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    tx.addOutput(ownerAddress, utils_1.DUST_MINIMUM);\n    return tx.buildIncomplete();\n}\nexports.makeRegisterSkeleton = makeRegisterSkeleton;\n/**\n* @ignore\n*/\nfunction makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burn, valueHash = null) {\n    /*\n      Formats\n  \n      No zonefile hash, and pay with BTC:\n  \n      0    2  3                                  39\n      |----|--|----------------------------------|\n      magic op   name.ns_id (up to 37 bytes)\n  \n  \n      With zonefile hash, and pay with BTC:\n  \n      0    2  3                                  39                  59\n      |----|--|----------------------------------|-------------------|\n      magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n  \n  \n     With renewal payment in a token:\n     (for register, tokens burned is not included)\n     (for renew, tokens burned is the number of tokens to burn)\n  \n     0    2  3                                  39                  59                            67\n     |----|--|----------------------------------|-------------------|------------------------------|\n     magic op   name.ns_id (37 bytes, 0-padded)     zone file hash    tokens burned (big-endian)\n  \n     output 0: renewal code\n     output 1: new owner address\n     output 2: current owner address\n     output 3: burn address\n    */\n    const burnAmount = asAmountV2(burn);\n    const network = config_1.config.network;\n    const burnTokenAmount = burnAmount.units === 'BTC' ? null : burnAmount.amount;\n    const burnBTCAmount = burnAmount.units === 'BTC'\n        ? burnAmount.amount.toNumber() : utils_1.DUST_MINIMUM;\n    let burnTokenHex = null;\n    if (!!burnTokenAmount) {\n        const burnHex = burnTokenAmount.toString(16, 2);\n        if (burnHex.length > 16) {\n            // exceeds 2**64; can't fit \n            throw new Error(`Cannot renew '${fullyQualifiedName}': cannot fit price into 8 bytes`);\n        }\n        burnTokenHex = `0000000000000000${burnHex}`.slice(-16);\n    }\n    const registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash, burnTokenHex);\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerTX, network.layer1);\n    txB.addOutput(lastOwnerAddress, utils_1.DUST_MINIMUM);\n    txB.addOutput(burnAddress, burnBTCAmount);\n    return txB.buildIncomplete();\n}\nexports.makeRenewalSkeleton = makeRenewalSkeleton;\n/**\n* @ignore\n*/\nfunction makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner, keepZonefile = false) {\n    // Returns a transfer tx skeleton.\n    //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data\n    //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)\n    //\n    // You MUST make the first input a UTXO from the current OWNER\n    //\n    // Returns an unsigned serialized transaction.\n    /*\n      Format\n  \n      0     2  3    4                   20              36\n      |-----|--|----|-------------------|---------------|\n      magic op keep  hash128(name.ns_id) consensus hash\n               data?\n  \n      output 0: transfer code\n      output 1: new owner\n    */\n    const opRet = Buffer.alloc(36);\n    let keepChar = '~';\n    if (keepZonefile) {\n        keepChar = '>';\n    }\n    opRet.write(opEncode('>'), 0, 3, 'ascii');\n    opRet.write(keepChar, 3, 1, 'ascii');\n    const hashed = utils_1.hash128(Buffer.from(fullyQualifiedName, 'ascii'));\n    hashed.copy(opRet, 4);\n    opRet.write(consensusHash, 20, 16, 'hex');\n    const opRetPayload = bitcoinjs_lib_1.payments.embed({ data: [opRet] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(opRetPayload, 0);\n    tx.addOutput(newOwner, utils_1.DUST_MINIMUM);\n    return tx.buildIncomplete();\n}\nexports.makeTransferSkeleton = makeTransferSkeleton;\n/**\n* @ignore\n*/\nfunction makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {\n    // Returns an update tx skeleton.\n    //   with 1 output : 1. the Blockstack update OP_RETURN\n    //\n    // You MUST make the first input a UTXO from the current OWNER\n    //\n    // Returns an unsigned serialized transaction.\n    //\n    // output 0: the revoke code\n    /*\n      Format:\n  \n      0     2  3                                   19                      39\n      |-----|--|-----------------------------------|-----------------------|\n      magic op  hash128(name.ns_id,consensus hash) hash160(data)\n  \n      output 0: update code\n    */\n    const opRet = Buffer.alloc(39);\n    const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n    const consensusBuff = Buffer.from(consensusHash, 'ascii');\n    const hashedName = utils_1.hash128(Buffer.concat([nameBuff, consensusBuff]));\n    opRet.write(opEncode('+'), 0, 3, 'ascii');\n    hashedName.copy(opRet, 3);\n    opRet.write(valueHash, 19, 20, 'hex');\n    const opRetPayload = bitcoinjs_lib_1.payments.embed({ data: [opRet] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(opRetPayload, 0);\n    return tx.buildIncomplete();\n}\nexports.makeUpdateSkeleton = makeUpdateSkeleton;\n/**\n* @ignore\n*/\nfunction makeRevokeSkeleton(fullyQualifiedName) {\n    // Returns a revoke tx skeleton\n    //    with 1 output: 1. the Blockstack revoke OP_RETURN\n    //\n    // You MUST make the first input a UTXO from the current OWNER\n    //\n    // Returns an unsigned serialized transaction\n    /*\n     Format:\n  \n     0    2  3                             39\n     |----|--|-----------------------------|\n     magic op   name.ns_id (37 bytes)\n  \n     output 0: the revoke code\n    */\n    const opRet = Buffer.alloc(3);\n    const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n    opRet.write(opEncode('~'), 0, 3, 'ascii');\n    const opReturnBuffer = Buffer.concat([opRet, nameBuff]);\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    return tx.buildIncomplete();\n}\nexports.makeRevokeSkeleton = makeRevokeSkeleton;\n/**\n* @ignore\n*/\nfunction makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, registerAddress, burn) {\n    // Returns a namespace preorder tx skeleton.\n    // Returns an unsigned serialized transaction.\n    /*\n     Formats:\n  \n     Without STACKS:\n  \n     0     2   3                                      23               39\n     |-----|---|--------------------------------------|----------------|\n     magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash\n  \n  \n     with STACKs:\n  \n     0     2   3                                      23               39                         47\n     |-----|---|--------------------------------------|----------------|--------------------------|\n     magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash    token fee (big-endian)\n  \n     output 0: namespace preorder code\n     output 1: change address\n     otuput 2: burn address\n    */\n    const burnAmount = asAmountV2(burn);\n    if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {\n        throw new Error(`Invalid burnUnits ${burnAmount.units}`);\n    }\n    const network = config_1.config.network;\n    const burnAddress = network.getDefaultBurnAddress();\n    const namespaceIDBuff = Buffer.from(utils_1.decodeB40(namespaceID), 'hex'); // base40\n    const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);\n    const registerBuff = Buffer.from(registerAddress, 'ascii');\n    const dataBuffers = [namespaceIDBuff, scriptPublicKey, registerBuff];\n    const dataBuff = Buffer.concat(dataBuffers);\n    const hashed = utils_1.hash160(dataBuff);\n    let btcBurnAmount = utils_1.DUST_MINIMUM;\n    let opReturnBufferLen = 39;\n    if (burnAmount.units === 'STACKS') {\n        opReturnBufferLen = 47;\n    }\n    else {\n        btcBurnAmount = burnAmount.amount.toNumber();\n    }\n    const opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n    opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');\n    hashed.copy(opReturnBuffer, 3);\n    opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n    if (burnAmount.units === 'STACKS') {\n        const burnHex = burnAmount.amount.toString(16, 2);\n        const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);\n        opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n    }\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);\n    tx.addOutput(burnAddress, btcBurnAmount);\n    return tx.buildIncomplete();\n}\nexports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;\n/**\n* @ignore\n*/\nfunction makeNamespaceRevealSkeleton(namespace, revealAddress) {\n    /*\n     Format:\n  \n     0     2   3    7     8     9    10   11   12   13   14    15    16    17       18      20     39\n     |-----|---|----|-----|-----|----|----|----|----|----|-----|-----|-----|--------|-------|-------|\n     magic  op  life coeff. base 1-2  3-4  5-6  7-8  9-10 11-12 13-14 15-16 nonalpha version  ns ID\n                                                    bucket exponents        no-vowel\n                                                                            discounts\n     \n     output 0: namespace reveal code\n     output 1: reveal address\n    */\n    const hexPayload = namespace.toHexPayload();\n    const opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);\n    opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');\n    opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    tx.addOutput(revealAddress, utils_1.DUST_MINIMUM);\n    return tx.buildIncomplete();\n}\nexports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;\n/**\n* @ignore\n*/\nfunction makeNamespaceReadySkeleton(namespaceID) {\n    /*\n     Format:\n  \n     0     2  3  4           23\n     |-----|--|--|------------|\n     magic op  .  ns_id\n  \n     output 0: namespace ready code\n     */\n    const opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);\n    opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');\n    opReturnBuffer.write(`.${namespaceID}`, 3, namespaceID.length + 1, 'ascii');\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    return tx.buildIncomplete();\n}\nexports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton;\n// type bitcoin.payments.p2data bitcoin.payments.embed\n/**\n* @ignore\n*/\nfunction makeNameImportSkeleton(name, recipientAddr, zonefileHash) {\n    /*\n     Format:\n  \n      0    2  3                             39\n      |----|--|-----------------------------|\n      magic op   name.ns_id (37 bytes)\n  \n     Output 0: the OP_RETURN\n     Output 1: the recipient\n     Output 2: the zonefile hash\n   */\n    if (zonefileHash.length !== 40) {\n        throw new Error('Invalid zonefile hash: must be 20 bytes hex-encoded');\n    }\n    const network = config_1.config.network;\n    const opReturnBuffer = Buffer.alloc(3 + name.length);\n    opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');\n    opReturnBuffer.write(name, 3, name.length, 'ascii');\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    const zonefileHashB58 = bitcoinjs_lib_1.address.toBase58Check(Buffer.from(zonefileHash, 'hex'), network.layer1.pubKeyHash);\n    tx.addOutput(nullOutput, 0);\n    tx.addOutput(recipientAddr, utils_1.DUST_MINIMUM);\n    tx.addOutput(zonefileHashB58, utils_1.DUST_MINIMUM);\n    return tx.buildIncomplete();\n}\nexports.makeNameImportSkeleton = makeNameImportSkeleton;\n/**\n* @ignore\n*/\nfunction makeAnnounceSkeleton(messageHash) {\n    /*\n      Format:\n  \n      0    2  3                             23\n      |----|--|-----------------------------|\n      magic op   message hash (160-bit)\n  \n      output 0: the OP_RETURN\n    */\n    if (messageHash.length !== 40) {\n        throw new Error('Invalid message hash: must be 20 bytes hex-encoded');\n    }\n    const opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);\n    opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');\n    opReturnBuffer.write(messageHash, 3, messageHash.length / 2, 'hex');\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    return tx.buildIncomplete();\n}\nexports.makeAnnounceSkeleton = makeAnnounceSkeleton;\n/**\n* @ignore\n*/\nfunction makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea) {\n    /*\n     Format:\n  \n      0     2  3              19         38          46                        80\n      |-----|--|--------------|----------|-----------|-------------------------|\n      magic op  consensus_hash token_type amount (BE) scratch area\n                               (ns_id)\n  \n      output 0: token transfer code\n      output 1: recipient address\n    */\n    if (scratchArea.length > 34) {\n        throw new Error('Invalid scratch area: must be no more than 34 bytes');\n    }\n    const opReturnBuffer = Buffer.alloc(46 + scratchArea.length);\n    const tokenTypeHex = Buffer.from(tokenType).toString('hex');\n    const tokenTypeHexPadded = `00000000000000000000000000000000000000${tokenTypeHex}`.slice(-38);\n    const tokenValueHex = tokenAmount.toString(16, 2);\n    if (tokenValueHex.length > 16) {\n        // exceeds 2**64; can't fit\n        throw new Error(`Cannot send tokens: cannot fit ${tokenAmount.toString()} into 8 bytes`);\n    }\n    const tokenValueHexPadded = `0000000000000000${tokenValueHex}`.slice(-16);\n    opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');\n    opReturnBuffer.write(consensusHash, 3, consensusHash.length / 2, 'hex');\n    opReturnBuffer.write(tokenTypeHexPadded, 19, tokenTypeHexPadded.length / 2, 'hex');\n    opReturnBuffer.write(tokenValueHexPadded, 38, tokenValueHexPadded.length / 2, 'hex');\n    opReturnBuffer.write(scratchArea, 46, scratchArea.length, 'ascii');\n    const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;\n    const tx = makeTXbuilder();\n    tx.addOutput(nullOutput, 0);\n    tx.addOutput(recipientAddress, utils_1.DUST_MINIMUM);\n    return tx.buildIncomplete();\n}\nexports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;\n//# sourceMappingURL=skeletons.js.map"]},"metadata":{},"sourceType":"script"}