{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst queryString = require(\"query-string\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst logger_1 = require(\"../logger\");\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\n\n\nfunction getAuthRequestFromURL() {\n  const location = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthRequestFromURL'\n  });\n  const queryDict = queryString.parse(location.search);\n\n  if (queryDict.authRequest) {\n    return queryDict.authRequest.split(`${utils_1.BLOCKSTACK_HANDLER}:`).join('');\n  } else {\n    return null;\n  }\n}\n\nexports.getAuthRequestFromURL = getAuthRequestFromURL;\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\n\nfunction fetchAppManifest(authRequest) {\n  return new Promise((resolve, reject) => {\n    if (!authRequest) {\n      reject('Invalid auth request');\n    } else {\n      const payload = jsontokens_1.decodeToken(authRequest).payload;\n\n      if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n      }\n\n      const manifestURI = payload.manifest_uri;\n\n      try {\n        logger_1.Logger.debug(`Fetching manifest from ${manifestURI}`);\n        fetchUtil_1.fetchPrivate(manifestURI).then(response => response.text()).then(responseText => JSON.parse(responseText)).then(responseJSON => {\n          resolve(Object.assign({}, responseJSON, {\n            manifestURI\n          }));\n        }).catch(e => {\n          logger_1.Logger.debug(e.stack);\n          reject('Could not fetch manifest.json');\n        });\n      } catch (e) {\n        logger_1.Logger.debug(e.stack);\n        reject('Could not fetch manifest.json');\n      }\n    }\n  });\n}\n\nexports.fetchAppManifest = fetchAppManifest;\n/**\n * Redirect the user's browser to the app using the `redirect_uri`\n * specified in the authentication request, passing the authentication\n * response token as a query parameter.\n *\n * @param {String} authRequest  encoded and signed authentication request token\n * @param {String} authResponse encoded and signed authentication response token\n * @return {void}\n * @throws {Error} if there is no redirect uri\n * @private\n * @ignore\n */\n\nfunction redirectUserToApp(authRequest, authResponse) {\n  const payload = jsontokens_1.decodeToken(authRequest).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  let redirectURI = payload.redirect_uri;\n  logger_1.Logger.debug(redirectURI);\n\n  if (redirectURI) {\n    redirectURI = utils_1.updateQueryStringParameter(redirectURI, 'authResponse', authResponse);\n  } else {\n    throw new Error('Invalid redirect URI');\n  }\n\n  const location = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'redirectUserToApp'\n  });\n  location.href = redirectURI;\n}\n\nexports.redirectUserToApp = redirectUserToApp;","map":{"version":3,"sources":["../../src/auth/authProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst queryString = require(\"query-string\");\n// @ts-ignore: Could not find a declaration file for module\nconst jsontokens_1 = require(\"jsontokens\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst logger_1 = require(\"../logger\");\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\nfunction getAuthRequestFromURL() {\n    const location = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'getAuthRequestFromURL' });\n    const queryDict = queryString.parse(location.search);\n    if (queryDict.authRequest) {\n        return queryDict.authRequest.split(`${utils_1.BLOCKSTACK_HANDLER}:`).join('');\n    }\n    else {\n        return null;\n    }\n}\nexports.getAuthRequestFromURL = getAuthRequestFromURL;\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\nfunction fetchAppManifest(authRequest) {\n    return new Promise((resolve, reject) => {\n        if (!authRequest) {\n            reject('Invalid auth request');\n        }\n        else {\n            const payload = jsontokens_1.decodeToken(authRequest).payload;\n            if (typeof payload === 'string') {\n                throw new Error('Unexpected token payload type of string');\n            }\n            const manifestURI = payload.manifest_uri;\n            try {\n                logger_1.Logger.debug(`Fetching manifest from ${manifestURI}`);\n                fetchUtil_1.fetchPrivate(manifestURI)\n                    .then(response => response.text())\n                    .then(responseText => JSON.parse(responseText))\n                    .then((responseJSON) => {\n                    resolve(Object.assign({}, responseJSON, { manifestURI }));\n                })\n                    .catch((e) => {\n                    logger_1.Logger.debug(e.stack);\n                    reject('Could not fetch manifest.json');\n                });\n            }\n            catch (e) {\n                logger_1.Logger.debug(e.stack);\n                reject('Could not fetch manifest.json');\n            }\n        }\n    });\n}\nexports.fetchAppManifest = fetchAppManifest;\n/**\n * Redirect the user's browser to the app using the `redirect_uri`\n * specified in the authentication request, passing the authentication\n * response token as a query parameter.\n *\n * @param {String} authRequest  encoded and signed authentication request token\n * @param {String} authResponse encoded and signed authentication response token\n * @return {void}\n * @throws {Error} if there is no redirect uri\n * @private\n * @ignore\n */\nfunction redirectUserToApp(authRequest, authResponse) {\n    const payload = jsontokens_1.decodeToken(authRequest).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    let redirectURI = payload.redirect_uri;\n    logger_1.Logger.debug(redirectURI);\n    if (redirectURI) {\n        redirectURI = utils_1.updateQueryStringParameter(redirectURI, 'authResponse', authResponse);\n    }\n    else {\n        throw new Error('Invalid redirect URI');\n    }\n    const location = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'redirectUserToApp' });\n    location.href = redirectURI;\n}\nexports.redirectUserToApp = redirectUserToApp;\n//# sourceMappingURL=authProvider.js.map"]},"metadata":{},"sourceType":"script"}