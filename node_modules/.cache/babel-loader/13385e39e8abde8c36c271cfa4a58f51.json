{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\");\n\nconst serviceUtils_1 = require(\"./serviceUtils\");\n\nconst fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\n\n\nclass Service {\n  static validateProof(proof, ownerAddress, name = null) {\n    let proofUrl;\n    return Promise.resolve().then(() => {\n      proofUrl = this.getProofUrl(proof);\n      return fetchUtil_1.fetchPrivate(proofUrl);\n    }).then(res => {\n      if (res.status !== 200) {\n        throw new Error(`Proof url ${proofUrl} returned unexpected http status ${res.status}.\n              Unable to validate proof.`);\n      }\n\n      return res.text();\n    }).then(text => {\n      // Validate identity in provided proof body/tags if required\n      if (this.shouldValidateIdentityInBody() && proof.identifier !== this.getProofIdentity(text)) {\n        return proof;\n      }\n\n      const proofText = this.getProofStatement(text);\n      proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name) || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n      return proof;\n    }).catch(error => {\n      console.error(error);\n      proof.valid = false;\n      return proof;\n    });\n  }\n\n  static getBaseUrls() {\n    return [];\n  }\n\n  static getProofIdentity(searchText) {\n    return searchText;\n  }\n\n  static getProofStatement(searchText) {\n    return searchText;\n  }\n\n  static shouldValidateIdentityInBody() {\n    return false;\n  }\n\n  static prefixScheme(proofUrl) {\n    if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n      return `https://${proofUrl}`;\n    } else if (proofUrl.startsWith('http://')) {\n      return proofUrl.replace('http://', 'https://');\n    } else {\n      return proofUrl;\n    }\n  }\n\n  static getProofUrl(proof) {\n    const baseUrls = this.getBaseUrls();\n    let proofUrl = proof.proof_url.toLowerCase();\n    proofUrl = this.prefixScheme(proofUrl);\n\n    for (let i = 0; i < baseUrls.length; i++) {\n      const requiredPrefix = `${baseUrls[i]}${proof.identifier}`.toLowerCase();\n\n      if (proofUrl.startsWith(requiredPrefix)) {\n        return proofUrl;\n      }\n    }\n\n    throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);\n  }\n\n}\n\nexports.Service = Service;","map":{"version":3,"sources":["../../../src/profiles/services/service.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"cross-fetch/polyfill\");\nconst serviceUtils_1 = require(\"./serviceUtils\");\nconst fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\nclass Service {\n    static validateProof(proof, ownerAddress, name = null) {\n        let proofUrl;\n        return Promise.resolve()\n            .then(() => {\n            proofUrl = this.getProofUrl(proof);\n            return fetchUtil_1.fetchPrivate(proofUrl);\n        })\n            .then((res) => {\n            if (res.status !== 200) {\n                throw new Error(`Proof url ${proofUrl} returned unexpected http status ${res.status}.\n              Unable to validate proof.`);\n            }\n            return res.text();\n        })\n            .then((text) => {\n            // Validate identity in provided proof body/tags if required\n            if (this.shouldValidateIdentityInBody()\n                && proof.identifier !== this.getProofIdentity(text)) {\n                return proof;\n            }\n            const proofText = this.getProofStatement(text);\n            proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name)\n                || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n            return proof;\n        })\n            .catch((error) => {\n            console.error(error);\n            proof.valid = false;\n            return proof;\n        });\n    }\n    static getBaseUrls() {\n        return [];\n    }\n    static getProofIdentity(searchText) {\n        return searchText;\n    }\n    static getProofStatement(searchText) {\n        return searchText;\n    }\n    static shouldValidateIdentityInBody() {\n        return false;\n    }\n    static prefixScheme(proofUrl) {\n        if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n            return `https://${proofUrl}`;\n        }\n        else if (proofUrl.startsWith('http://')) {\n            return proofUrl.replace('http://', 'https://');\n        }\n        else {\n            return proofUrl;\n        }\n    }\n    static getProofUrl(proof) {\n        const baseUrls = this.getBaseUrls();\n        let proofUrl = proof.proof_url.toLowerCase();\n        proofUrl = this.prefixScheme(proofUrl);\n        for (let i = 0; i < baseUrls.length; i++) {\n            const requiredPrefix = `${baseUrls[i]}${proof.identifier}`.toLowerCase();\n            if (proofUrl.startsWith(requiredPrefix)) {\n                return proofUrl;\n            }\n        }\n        throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=service.js.map"]},"metadata":{},"sourceType":"script"}