{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst FormData = require(\"form-data\");\n\nconst BN = require(\"bn.js\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nconst config_1 = require(\"./config\");\n\nconst fetchUtil_1 = require(\"./fetchUtil\");\n\nconst sha2Hash_1 = require(\"./encryption/sha2Hash\");\n\nconst hashRipemd160_1 = require(\"./encryption/hashRipemd160\");\n\nconst SATOSHIS_PER_BTC = 1e8;\nconst TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';\nconst TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';\nconst TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';\n/**\n * @private\n * @ignore\n */\n\nclass BitcoinNetwork {\n  broadcastTransaction(transaction) {\n    return Promise.reject(new Error(`Not implemented, broadcastTransaction(${transaction})`));\n  }\n\n  getBlockHeight() {\n    return Promise.reject(new Error('Not implemented, getBlockHeight()'));\n  }\n\n  getTransactionInfo(txid) {\n    return Promise.reject(new Error(`Not implemented, getTransactionInfo(${txid})`));\n  }\n\n  getNetworkedUTXOs(address) {\n    return Promise.reject(new Error(`Not implemented, getNetworkedUTXOs(${address})`));\n  }\n\n}\n\nexports.BitcoinNetwork = BitcoinNetwork;\n/**\n * Use the methods in class to build third-party wallets or in DApps that register names.\n */\n\nclass BlockstackNetwork {\n  constructor(apiUrl, broadcastServiceUrl, bitcoinAPI, network = bitcoinjs_lib_1.networks.bitcoin) {\n    this.blockstackAPIUrl = apiUrl;\n    this.broadcastServiceUrl = broadcastServiceUrl;\n    this.layer1 = network;\n    this.btc = bitcoinAPI;\n    this.DUST_MINIMUM = 5500;\n    this.includeUtxoMap = {};\n    this.excludeUtxoSet = [];\n    this.MAGIC_BYTES = 'id';\n  }\n  /**\n   * @ignore\n   */\n\n\n  coerceAddress(address) {\n    const {\n      hash,\n      version\n    } = bitcoinjs_lib_1.address.fromBase58Check(address);\n    const scriptHashes = [bitcoinjs_lib_1.networks.bitcoin.scriptHash, bitcoinjs_lib_1.networks.testnet.scriptHash];\n    const pubKeyHashes = [bitcoinjs_lib_1.networks.bitcoin.pubKeyHash, bitcoinjs_lib_1.networks.testnet.pubKeyHash];\n    let coercedVersion;\n\n    if (scriptHashes.indexOf(version) >= 0) {\n      coercedVersion = this.layer1.scriptHash;\n    } else if (pubKeyHashes.indexOf(version) >= 0) {\n      coercedVersion = this.layer1.pubKeyHash;\n    } else {\n      throw new Error(`Unrecognized address version number ${version} in ${address}`);\n    }\n\n    return bitcoinjs_lib_1.address.toBase58Check(hash, coercedVersion);\n  }\n  /**\n   * This is intended for use in third-party wallets or in DApps that register names.\n   */\n\n\n  getDefaultBurnAddress() {\n    return this.coerceAddress('1111111111111111111114oLvT2');\n  }\n  /**\n   * Get the price of a name via the legacy /v1/prices API endpoint. This is\n   * intended for use in third-party wallets or in DApps that register names.\n   * @param fullyQualifiedName the name to query\n   * @return a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamePriceV1(fullyQualifiedName) {\n    // legacy code path\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/names/${fullyQualifiedName}`).then(resp => {\n      if (!resp.ok) {\n        throw new Error(`Failed to query name price for ${fullyQualifiedName}`);\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(resp => resp.name_price).then(namePrice => {\n      if (!namePrice || !namePrice.satoshis) {\n        throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);\n      }\n\n      if (namePrice.satoshis < this.DUST_MINIMUM) {\n        namePrice.satoshis = this.DUST_MINIMUM;\n      }\n\n      const result = {\n        units: 'BTC',\n        amount: new BN(String(namePrice.satoshis))\n      };\n      return result;\n    });\n  }\n  /**\n   * Get the price of a namespace via the legacy /v1/prices API endpoint. This is intended for\n   * use in third-party wallets or in DApps that register names.\n   * @param namespaceID the namespace to query\n   * @return a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamespacePriceV1(namespaceID) {\n    // legacy code path\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/namespaces/${namespaceID}`).then(resp => {\n      if (!resp.ok) {\n        throw new Error(`Failed to query name price for ${namespaceID}`);\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(namespacePrice => {\n      if (!namespacePrice || !namespacePrice.satoshis) {\n        throw new Error(`Failed to get price for ${namespaceID}`);\n      }\n\n      if (namespacePrice.satoshis < this.DUST_MINIMUM) {\n        namespacePrice.satoshis = this.DUST_MINIMUM;\n      }\n\n      const result = {\n        units: 'BTC',\n        amount: new BN(String(namespacePrice.satoshis))\n      };\n      return result;\n    });\n  }\n  /**\n   * Get the price of a name via the /v2/prices API endpoint. This is intended\n   * for use in third-party wallets or in DApps that register names.\n   * @param fullyQualifiedName the name to query\n   * @return a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamePriceV2(fullyQualifiedName) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/names/${fullyQualifiedName}`).then(resp => {\n      if (resp.status !== 200) {\n        // old core node \n        throw new Error('The upstream node does not handle the /v2/ price namespace');\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(resp => resp.name_price).then(namePrice => {\n      if (!namePrice) {\n        throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);\n      }\n\n      const result = {\n        units: namePrice.units,\n        amount: new BN(namePrice.amount)\n      };\n\n      if (namePrice.units === 'BTC') {\n        // must be at least dust-minimum\n        const dustMin = new BN(String(this.DUST_MINIMUM));\n\n        if (result.amount.ucmp(dustMin) < 0) {\n          result.amount = dustMin;\n        }\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Get the price of a namespace via the /v2/prices API endpoint.\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param namespaceID the namespace to query\n   * @return a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamespacePriceV2(namespaceID) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/namespaces/${namespaceID}`).then(resp => {\n      if (resp.status !== 200) {\n        // old core node \n        throw new Error('The upstream node does not handle the /v2/ price namespace');\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(namespacePrice => {\n      if (!namespacePrice) {\n        throw new Error(`Failed to get price for ${namespaceID}`);\n      }\n\n      const result = {\n        units: namespacePrice.units,\n        amount: new BN(namespacePrice.amount)\n      };\n\n      if (namespacePrice.units === 'BTC') {\n        // must be at least dust-minimum\n        const dustMin = new BN(String(this.DUST_MINIMUM));\n\n        if (result.amount.ucmp(dustMin) < 0) {\n          result.amount = dustMin;\n        }\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Get the price of a name. This is intended for\n   * use in third-party wallets or in DApps that register names.\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param fullyQualifiedName the name to query\n   * @return a promise to an Object with { units: String, amount: BigInteger }, where\n   *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n   *   .amount encodes the number of units, in the smallest denominiated amount\n   *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n   *   .amount will be microStacks)\n   */\n\n\n  getNamePrice(fullyQualifiedName) {\n    // handle v1 or v2 \n    return Promise.resolve().then(() => this.getNamePriceV2(fullyQualifiedName)).catch(() => this.getNamePriceV1(fullyQualifiedName));\n  }\n  /**\n   * Get the price of a namespace. This is intended for use in third-party\n   * wallets or in DApps that register names.\n   * @param namespaceID the namespace to query\n   * @return a promise to an Object with { units: String, amount: BigInteger }, where\n   *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n   *   .amount encodes the number of units, in the smallest denominiated amount\n   *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n   *   .amount will be microStacks)\n   */\n\n\n  getNamespacePrice(namespaceID) {\n    // handle v1 or v2 \n    return Promise.resolve().then(() => this.getNamespacePriceV2(namespaceID)).catch(() => this.getNamespacePriceV1(namespaceID));\n  }\n  /**\n   * How many blocks can pass between a name expiring and the name being able to be\n   * re-registered by a different owner. This is intended for\n   * use in third-party wallets or in DApps that register names.\n   * @param fullyQualifiedName unused\n   * @return a promise to the number of blocks\n   */\n\n\n  getGracePeriod(_fullyQualifiedName) {\n    return Promise.resolve(5000);\n  }\n  /**\n   * Get the names -- both on-chain and off-chain -- owned by an address. This is intended for\n   * use in third-party wallets or in DApps that register names.\n   * @param address the blockchain address (the hash of the owner public key)\n   * @return a promise that resolves to a list of names (Strings)\n   */\n\n\n  getNamesOwned(address) {\n    const networkAddress = this.coerceAddress(address);\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/addresses/bitcoin/${networkAddress}`).then(resp => resp.json()).then(obj => obj.names);\n  }\n  /**\n   * Get the blockchain address to which a name's registration fee must be sent\n   * (the address will depend on the namespace in which it is registered.)\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param namespace the namespace ID\n   * @return a promise that resolves to an address (String)\n   */\n\n\n  getNamespaceBurnAddress(namespace) {\n    return Promise.all([fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespace}`), this.getBlockHeight()]).then(([resp, blockHeight]) => {\n      if (resp.status === 404) {\n        throw new Error(`No such namespace '${namespace}'`);\n      } else {\n        return Promise.all([resp.json(), blockHeight]);\n      }\n    }).then(([namespaceInfo, blockHeight]) => {\n      let address = this.getDefaultBurnAddress();\n\n      if (namespaceInfo.version === 2) {\n        // pay-to-namespace-creator if this namespace is less than 1 year old\n        if (namespaceInfo.reveal_block + 52595 >= blockHeight) {\n          address = namespaceInfo.address;\n        }\n      }\n\n      return address;\n    }).then(address => this.coerceAddress(address));\n  }\n  /**\n   * Get WHOIS-like information for a name, including the address that owns it,\n   * the block at which it expires, and the zone file anchored to it (if available).\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n   * @return a promise that resolves to the WHOIS-like information\n   */\n\n\n  getNameInfo(fullyQualifiedName) {\n    logger_1.Logger.debug(this.blockstackAPIUrl);\n    const nameLookupURL = `${this.blockstackAPIUrl}/v1/names/${fullyQualifiedName}`;\n    return fetchUtil_1.fetchPrivate(nameLookupURL).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Name not found');\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(nameInfo => {\n      logger_1.Logger.debug(`nameInfo: ${JSON.stringify(nameInfo)}`); // the returned address _should_ be in the correct network ---\n      //  blockstackd gets into trouble because it tries to coerce back to mainnet\n      //  and the regtest transaction generation libraries want to use testnet addresses\n\n      if (nameInfo.address) {\n        return Object.assign({}, nameInfo, {\n          address: this.coerceAddress(nameInfo.address)\n        });\n      } else {\n        return nameInfo;\n      }\n    });\n  }\n  /**\n   * Get the pricing parameters and creation history of a namespace. This is intended for\n   * use in third-party wallets or in DApps that register names.\n   * @param namespaceID the namespace to query\n   * @return a promise that resolves to the namespace information.\n   */\n\n\n  getNamespaceInfo(namespaceID) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespaceID}`).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Namespace not found');\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(namespaceInfo => {\n      // the returned address _should_ be in the correct network ---\n      //  blockstackd gets into trouble because it tries to coerce back to mainnet\n      //  and the regtest transaction generation libraries want to use testnet addresses\n      if (namespaceInfo.address && namespaceInfo.recipient_address) {\n        return Object.assign({}, namespaceInfo, {\n          address: this.coerceAddress(namespaceInfo.address),\n          recipient_address: this.coerceAddress(namespaceInfo.recipient_address)\n        });\n      } else {\n        return namespaceInfo;\n      }\n    });\n  }\n  /**\n   * Get a zone file, given its hash.  Throws an exception if the zone file\n   * obtained does not match the hash.\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   *\n   * @param zonefileHash the ripemd160(sha256) hash of the zone file\n   * @return a promise that resolves to the zone file's text\n   */\n\n\n  getZonefile(zonefileHash) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefiles/${zonefileHash}`).then(resp => {\n      if (resp.status === 200) {\n        return resp.text().then(body => tslib_1.__awaiter(this, void 0, void 0, function* () {\n          const sha2Hash = yield sha2Hash_1.createSha2Hash();\n          const sha256 = yield sha2Hash.digest(Buffer.from(body));\n          const h = hashRipemd160_1.hashRipemd160(sha256).toString('hex');\n\n          if (h !== zonefileHash) {\n            throw new Error(`Zone file contents hash to ${h}, not ${zonefileHash}`);\n          }\n\n          return body;\n        }));\n      } else {\n        throw new Error(`Bad response status: ${resp.status}`);\n      }\n    });\n  }\n  /**\n   * Get the status of an account for a particular token holding.  This includes its total number of\n   * expenditures and credits, lockup times, last `txid`, and so on.\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param address the account\n   * @param tokenType the token type to query\n   * @return a promise that resolves to an object representing the state of the account\n   *   for this token\n   */\n\n\n  getAccountStatus(address, tokenType) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/status`).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(accountStatus => {\n      // coerce all addresses, and convert credit/debit to biginteger\n      const formattedStatus = Object.assign({}, accountStatus, {\n        address: this.coerceAddress(accountStatus.address),\n        debit_value: new BN(String(accountStatus.debit_value)),\n        credit_value: new BN(String(accountStatus.credit_value))\n      });\n      return formattedStatus;\n    });\n  }\n  /**\n   * Get a page of an account's transaction history. This is intended for use in\n   * third-party wallets or in DApps that register names.\n   * @param address the account's address\n   * @param page the page number.  Page 0 is the most recent transactions\n   * @return a promise that resolves to an Array of Objects, where each Object encodes\n   *   states of the account at various block heights (e.g. prior balances, txids, etc)\n   */\n\n\n  getAccountHistoryPage(address, page) {\n    const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history?page=${page}`;\n    return fetchUtil_1.fetchPrivate(url).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(historyList => {\n      if (historyList.error) {\n        throw new Error(`Unable to get account history page: ${historyList.error}`);\n      } // coerse all addresses and convert to bigint\n\n\n      return historyList.map(histEntry => {\n        histEntry.address = this.coerceAddress(histEntry.address);\n        histEntry.debit_value = new BN(String(histEntry.debit_value));\n        histEntry.credit_value = new BN(String(histEntry.credit_value));\n        return histEntry;\n      });\n    });\n  }\n  /**\n   * Get the state(s) of an account at a particular block height.  This includes the state of the\n   * account beginning with this block's transactions, as well as all of the states the account\n   * passed through when this block was processed (if any).\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param address the account's address\n   * @param blockHeight the block to query\n   * @return a promise that resolves to an Array of Objects, where each Object encodes\n   *   states of the account at this block.\n   */\n\n\n  getAccountAt(address, blockHeight) {\n    const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history/${blockHeight}`;\n    return fetchUtil_1.fetchPrivate(url).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(historyList => {\n      if (historyList.error) {\n        throw new Error(`Unable to get historic account state: ${historyList.error}`);\n      } // coerce all addresses \n\n\n      return historyList.map(histEntry => {\n        histEntry.address = this.coerceAddress(histEntry.address);\n        histEntry.debit_value = new BN(String(histEntry.debit_value));\n        histEntry.credit_value = new BN(String(histEntry.credit_value));\n        return histEntry;\n      });\n    });\n  }\n  /**\n   * Get the set of token types that this account owns. This is intended for use\n   * in third-party wallets or in DApps that register names.\n   * @param address the account's address\n   * @return a promise that resolves to an Array of Strings, where each item encodes the\n   *   type of token this account holds (excluding the underlying blockchain's tokens)\n   */\n\n\n  getAccountTokens(address) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/tokens`).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(tokenList => {\n      if (tokenList.error) {\n        throw new Error(`Unable to get token list: ${tokenList.error}`);\n      }\n\n      return tokenList;\n    });\n  }\n  /**\n   * Get the number of tokens owned by an account.  If the account does not exist or has no\n   * tokens of this type, then 0 will be returned.\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param address the account's address\n   * @param tokenType the type of token to query.\n   * @return a promise that resolves to a BigInteger that encodes the number of tokens\n   *   held by this account.\n   */\n\n\n  getAccountBalance(address, tokenType) {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/balance`).then(resp => {\n      if (resp.status === 404) {\n        // talking to an older blockstack core node without the accounts API\n        return Promise.resolve().then(() => new BN('0'));\n      } else if (resp.status !== 200) {\n        throw new Error(`Bad response status: ${resp.status}`);\n      } else {\n        return resp.json();\n      }\n    }).then(tokenBalance => {\n      if (tokenBalance.error) {\n        throw new Error(`Unable to get account balance: ${tokenBalance.error}`);\n      }\n\n      let balance = '0';\n\n      if (tokenBalance && tokenBalance.balance) {\n        balance = tokenBalance.balance;\n      }\n\n      return new BN(balance);\n    });\n  }\n  /**\n   * Performs a POST request to the given URL. This is intended for\n   * use in third-party wallets or in DApps that register names.\n   * @param endpoint  the name of\n   * @param body [description]\n   * @return Returns a `Promise` that resolves to the object requested.\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   * with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   * parameter\n   *\n   * @private\n   */\n\n\n  broadcastServiceFetchHelper(endpoint, body) {\n    const requestHeaders = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    };\n    const options = {\n      method: 'POST',\n      headers: requestHeaders,\n      body: JSON.stringify(body)\n    };\n    const url = `${this.broadcastServiceUrl}/v1/broadcast/${endpoint}`;\n    return fetchUtil_1.fetchPrivate(url, options).then(response => {\n      if (response.ok) {\n        return response.json();\n      } else {\n        throw new errors_1.RemoteServiceError(response);\n      }\n    });\n  }\n  /**\n   * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the\n   * transaction until a second transaction has a certain number of confirmations.\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   *\n   * @param transaction the hex-encoded transaction to broadcast\n   * @param transactionToWatch the hex transaction id of the transaction to watch for\n   * the specified number of confirmations before broadcasting the `transaction`\n   * @param confirmations the number of confirmations `transactionToWatch` must have\n   * before broadcasting `transaction`.\n   * @return Returns a Promise that resolves to an object with a\n   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n   *\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   *   with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   *   parameter\n   * @private\n   */\n\n\n  broadcastTransaction(transaction, transactionToWatch = null, confirmations = 6) {\n    if (!transaction) {\n      const error = new errors_1.MissingParameterError('transaction');\n      return Promise.reject(error);\n    }\n\n    if (!confirmations && confirmations !== 0) {\n      const error = new errors_1.MissingParameterError('confirmations');\n      return Promise.reject(error);\n    }\n\n    if (transactionToWatch === null) {\n      return this.btc.broadcastTransaction(transaction);\n    } else {\n      /*\n       * POST /v1/broadcast/transaction\n       * Request body:\n       * JSON.stringify({\n       *  transaction,\n       *  transactionToWatch,\n       *  confirmations\n       * })\n       */\n      const endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;\n      const requestBody = {\n        transaction,\n        transactionToWatch,\n        confirmations\n      };\n      return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    }\n  }\n  /**\n   * Broadcasts a zone file to the Atlas network via the transaction broadcast service.\n   * This is intended for use in third-party wallets or in DApps that register names.\n   *\n   * @param zoneFile the zone file to be broadcast to the Atlas network\n   * @param transactionToWatch the hex transaction id of the transaction\n   * to watch for confirmation before broadcasting the zone file to the Atlas network\n   * @return Returns a Promise that resolves to an object with a\n   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n   *\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   *   with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   *   parameter\n   * @private\n   */\n\n\n  broadcastZoneFile(zoneFile, transactionToWatch = null) {\n    if (!zoneFile) {\n      return Promise.reject(new errors_1.MissingParameterError('zoneFile'));\n    } // TODO: validate zonefile\n\n\n    if (transactionToWatch) {\n      // broadcast via transaction broadcast service\n\n      /*\n       * POST /v1/broadcast/zone-file\n       * Request body:\n       * JSON.stringify({\n       *  zoneFile,\n       *  transactionToWatch\n       * })\n       */\n      const requestBody = {\n        zoneFile,\n        transactionToWatch\n      };\n      const endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;\n      return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    } else {\n      // broadcast via core endpoint\n      // zone file is two words but core's api treats it as one word 'zonefile'\n      const requestBody = {\n        zonefile: zoneFile\n      };\n      return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefile/`, {\n        method: 'POST',\n        body: JSON.stringify(requestBody),\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }).then(resp => {\n        const json = resp.json();\n        return json.then(respObj => {\n          if (respObj.hasOwnProperty('error')) {\n            throw new errors_1.RemoteServiceError(resp);\n          }\n\n          return respObj.servers;\n        });\n      });\n    }\n  }\n  /**\n   * Sends the preorder and registration transactions and zone file\n   * for a Blockstack name registration along with the to the transaction\n   *  broadcast service.\n   *\n   * The transaction broadcast:\n   *\n   * * immediately broadcasts the preorder transaction\n   * * broadcasts the register transactions after the preorder transaction\n   * has an appropriate number of confirmations\n   * * broadcasts the zone file to the Atlas network after the register transaction\n   * has an appropriate number of confirmations\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   *\n   * @param preorderTransaction the hex-encoded, signed preorder transaction generated\n   * using the `makePreorder` function\n   * @param registerTransaction the hex-encoded, signed register transaction generated\n   * using the `makeRegister` function\n   * @param zoneFile the zone file to be broadcast to the Atlas network\n   * @return Returns a Promise that resolves to an object with a\n   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n   *\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   *   with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   *   parameter\n   * @private\n   */\n\n\n  broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {\n    /*\n       * POST /v1/broadcast/registration\n       * Request body:\n       * JSON.stringify({\n       * preorderTransaction,\n       * registerTransaction,\n       * zoneFile\n       * })\n       */\n    if (!preorderTransaction) {\n      const error = new errors_1.MissingParameterError('preorderTransaction');\n      return Promise.reject(error);\n    }\n\n    if (!registerTransaction) {\n      const error = new errors_1.MissingParameterError('registerTransaction');\n      return Promise.reject(error);\n    }\n\n    if (!zoneFile) {\n      const error = new errors_1.MissingParameterError('zoneFile');\n      return Promise.reject(error);\n    }\n\n    const requestBody = {\n      preorderTransaction,\n      registerTransaction,\n      zoneFile\n    };\n    const endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;\n    return this.broadcastServiceFetchHelper(endpoint, requestBody);\n  }\n  /**\n   * @ignore\n   */\n\n\n  getFeeRate() {\n    return fetchUtil_1.fetchPrivate('https://bitcoinfees.earn.com/api/v1/fees/recommended').then(resp => resp.json()).then(rates => Math.floor(rates.fastestFee));\n  }\n  /**\n   * @ignore\n   */\n\n\n  countDustOutputs() {\n    throw new Error('Not implemented.');\n  }\n  /**\n   * @ignore\n   */\n\n\n  getUTXOs(address) {\n    return this.getNetworkedUTXOs(address).then(networkedUTXOs => {\n      let returnSet = networkedUTXOs.concat();\n\n      if (this.includeUtxoMap.hasOwnProperty(address)) {\n        returnSet = networkedUTXOs.concat(this.includeUtxoMap[address]);\n      } // aaron: I am *well* aware this is O(n)*O(m) runtime\n      //    however, clients should clear the exclude set periodically\n\n\n      const excludeSet = this.excludeUtxoSet;\n      returnSet = returnSet.filter(utxo => {\n        const inExcludeSet = excludeSet.reduce((inSet, utxoToCheck) => inSet || utxoToCheck.tx_hash === utxo.tx_hash && utxoToCheck.tx_output_n === utxo.tx_output_n, false);\n        return !inExcludeSet;\n      });\n      return returnSet;\n    });\n  }\n  /**\n   * This will modify the network's utxo set to include UTXOs\n   *  from the given transaction and exclude UTXOs *spent* in\n   *  that transaction.\n   *\n   * This is intended for use in third-party wallets or in DApps that register names.\n   * @param txHex - the hex-encoded transaction to use\n   * @return no return value, this modifies the UTXO config state\n   * @private\n   * @ignore\n   */\n\n\n  modifyUTXOSetFrom(txHex) {\n    const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);\n    const excludeSet = this.excludeUtxoSet.concat();\n    tx.ins.forEach(utxoUsed => {\n      const reverseHash = Buffer.from(utxoUsed.hash);\n      reverseHash.reverse();\n      excludeSet.push({\n        tx_hash: reverseHash.toString('hex'),\n        tx_output_n: utxoUsed.index\n      });\n    });\n    this.excludeUtxoSet = excludeSet;\n    const txHash = Buffer.from(tx.getHash().reverse()).toString('hex');\n    tx.outs.forEach((utxoCreated, txOutputN) => {\n      const isNullData = function isNullData(script) {\n        try {\n          bitcoinjs_lib_1.payments.embed({\n            output: script\n          }, {\n            validate: true\n          });\n          return true;\n        } catch (_) {\n          return false;\n        }\n      };\n\n      if (isNullData(utxoCreated.script)) {\n        return;\n      }\n\n      const address = bitcoinjs_lib_1.address.fromOutputScript(utxoCreated.script, this.layer1);\n      let includeSet = [];\n\n      if (this.includeUtxoMap.hasOwnProperty(address)) {\n        includeSet = includeSet.concat(this.includeUtxoMap[address]);\n      }\n\n      includeSet.push({\n        tx_hash: txHash,\n        confirmations: 0,\n        value: utxoCreated.value,\n        tx_output_n: txOutputN\n      });\n      this.includeUtxoMap[address] = includeSet;\n    });\n  }\n  /**\n   * @ignore\n   */\n\n\n  resetUTXOs(address) {\n    delete this.includeUtxoMap[address];\n    this.excludeUtxoSet = [];\n  }\n  /**\n   * @ignore\n   */\n\n\n  getConsensusHash() {\n    return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/blockchains/bitcoin/consensus`).then(resp => resp.json()).then(x => x.consensus_hash);\n  }\n\n  getTransactionInfo(txHash) {\n    return this.btc.getTransactionInfo(txHash);\n  }\n  /**\n   * @ignore\n   */\n\n\n  getBlockHeight() {\n    return this.btc.getBlockHeight();\n  }\n\n  getNetworkedUTXOs(address) {\n    return this.btc.getNetworkedUTXOs(address);\n  }\n\n}\n\nexports.BlockstackNetwork = BlockstackNetwork;\n/**\n * @ignore\n */\n\nclass LocalRegtest extends BlockstackNetwork {\n  constructor(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n    super(apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.networks.testnet);\n  }\n\n  getFeeRate() {\n    return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));\n  }\n\n}\n\nexports.LocalRegtest = LocalRegtest;\n/**\n * @ignore\n */\n\nclass BitcoindAPI extends BitcoinNetwork {\n  constructor(bitcoindUrl, bitcoindCredentials) {\n    super();\n    this.bitcoindUrl = bitcoindUrl;\n    this.bitcoindCredentials = bitcoindCredentials;\n    this.importedBefore = {};\n  }\n\n  broadcastTransaction(transaction) {\n    const jsonRPC = {\n      jsonrpc: '1.0',\n      method: 'sendrawtransaction',\n      params: [transaction]\n    };\n    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');\n    const headers = {\n      Authorization: `Basic ${authString}`\n    };\n    return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPC),\n      headers\n    }).then(resp => resp.json()).then(respObj => respObj.result);\n  }\n\n  getBlockHeight() {\n    const jsonRPC = {\n      jsonrpc: '1.0',\n      method: 'getblockcount'\n    };\n    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');\n    const headers = {\n      Authorization: `Basic ${authString}`\n    };\n    return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPC),\n      headers\n    }).then(resp => resp.json()).then(respObj => respObj.result);\n  }\n\n  getTransactionInfo(txHash) {\n    const jsonRPC = {\n      jsonrpc: '1.0',\n      method: 'gettransaction',\n      params: [txHash]\n    };\n    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');\n    const headers = {\n      Authorization: `Basic ${authString}`\n    };\n    return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPC),\n      headers\n    }).then(resp => resp.json()).then(respObj => respObj.result).then(txInfo => txInfo.blockhash).then(blockhash => {\n      const jsonRPCBlock = {\n        jsonrpc: '1.0',\n        method: 'getblockheader',\n        params: [blockhash]\n      };\n      headers.Authorization = `Basic ${authString}`;\n      return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPCBlock),\n        headers\n      });\n    }).then(resp => resp.json()).then(respObj => {\n      if (!respObj || !respObj.result) {\n        // unconfirmed \n        throw new Error('Unconfirmed transaction');\n      } else {\n        return {\n          block_height: respObj.result.height\n        };\n      }\n    });\n  }\n\n  getNetworkedUTXOs(address) {\n    const jsonRPCImport = {\n      jsonrpc: '1.0',\n      method: 'importaddress',\n      params: [address]\n    };\n    const jsonRPCUnspent = {\n      jsonrpc: '1.0',\n      method: 'listunspent',\n      params: [0, 9999999, [address]]\n    };\n    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');\n    const headers = {\n      Authorization: `Basic ${authString}`\n    };\n    const importPromise = this.importedBefore[address] ? Promise.resolve() : fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPCImport),\n      headers\n    }).then(() => {\n      this.importedBefore[address] = true;\n    });\n    return importPromise.then(() => fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPCUnspent),\n      headers\n    })).then(resp => resp.json()).then(x => x.result).then(utxos => utxos.map(x => ({\n      value: Math.round(x.amount * SATOSHIS_PER_BTC),\n      confirmations: x.confirmations,\n      tx_hash: x.txid,\n      tx_output_n: x.vout\n    })));\n  }\n\n}\n\nexports.BitcoindAPI = BitcoindAPI;\n/**\n * @ignore\n */\n\nclass InsightClient extends BitcoinNetwork {\n  constructor(insightUrl = 'https://utxo.technofractal.com/') {\n    super();\n    this.apiUrl = insightUrl;\n  }\n\n  broadcastTransaction(transaction) {\n    const jsonData = {\n      rawtx: transaction\n    };\n    return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/send`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(jsonData)\n    }).then(resp => resp.json());\n  }\n\n  getBlockHeight() {\n    return fetchUtil_1.fetchPrivate(`${this.apiUrl}/status`).then(resp => resp.json()).then(status => status.blocks);\n  }\n\n  getTransactionInfo(txHash) {\n    return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/${txHash}`).then(resp => resp.json()).then(transactionInfo => {\n      if (transactionInfo.error) {\n        throw new Error(`Error finding transaction: ${transactionInfo.error}`);\n      }\n\n      return fetchUtil_1.fetchPrivate(`${this.apiUrl}/block/${transactionInfo.blockHash}`);\n    }).then(resp => resp.json()).then(blockInfo => ({\n      block_height: blockInfo.height\n    }));\n  }\n\n  getNetworkedUTXOs(address) {\n    return fetchUtil_1.fetchPrivate(`${this.apiUrl}/addr/${address}/utxo`).then(resp => resp.json()).then(utxos => utxos.map(x => ({\n      value: x.satoshis,\n      confirmations: x.confirmations,\n      tx_hash: x.txid,\n      tx_output_n: x.vout\n    })));\n  }\n\n}\n\nexports.InsightClient = InsightClient;\n/**\n * @ignore\n */\n\nclass BlockchainInfoApi extends BitcoinNetwork {\n  constructor(blockchainInfoUrl = 'https://blockchain.info') {\n    super();\n    this.utxoProviderUrl = blockchainInfoUrl;\n  }\n\n  getBlockHeight() {\n    return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/latestblock?cors=true`).then(resp => resp.json()).then(blockObj => blockObj.height);\n  }\n\n  getNetworkedUTXOs(address) {\n    return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/unspent?format=json&active=${address}&cors=true`).then(resp => {\n      if (resp.status === 500) {\n        logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');\n        return {\n          unspent_outputs: []\n        };\n      } else {\n        return resp.json();\n      }\n    }).then(utxoJSON => utxoJSON.unspent_outputs).then(utxoList => utxoList.map(utxo => {\n      const utxoOut = {\n        value: utxo.value,\n        tx_output_n: utxo.tx_output_n,\n        confirmations: utxo.confirmations,\n        tx_hash: utxo.tx_hash_big_endian\n      };\n      return utxoOut;\n    }));\n  }\n\n  getTransactionInfo(txHash) {\n    return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/rawtx/${txHash}?cors=true`).then(resp => {\n      if (resp.status === 200) {\n        return resp.json();\n      } else {\n        throw new Error(`Could not lookup transaction info for '${txHash}'. Server error.`);\n      }\n    }).then(respObj => ({\n      block_height: respObj.block_height\n    }));\n  }\n\n  broadcastTransaction(transaction) {\n    const form = new FormData();\n    form.append('tx', transaction);\n    return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/pushtx?cors=true`, {\n      method: 'POST',\n      body: form\n    }).then(resp => {\n      const text = resp.text();\n      return text.then(respText => {\n        if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {\n          const txHash = Buffer.from(bitcoinjs_lib_1.Transaction.fromHex(transaction).getHash().reverse()).toString('hex'); // big_endian\n\n          return txHash;\n        } else {\n          throw new errors_1.RemoteServiceError(resp, `Broadcast transaction failed with message: ${respText}`);\n        }\n      });\n    });\n  }\n\n}\n\nexports.BlockchainInfoApi = BlockchainInfoApi;\n/**\n* @ignore\n*/\n\nconst LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', {\n  username: 'blockstack',\n  password: 'blockstacksystem'\n}));\n/**\n* Instance of [[BlockstackNetwork]] set to the default endpoints.\n*/\n\nexports.MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());\n/**\n * Get WHOIS-like information for a name, including the address that owns it,\n * the block at which it expires, and the zone file anchored to it (if available).\n * This is intended for use in third-party wallets or in DApps that register names.\n * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n * @return a promise that resolves to the WHOIS-like information\n */\n\nfunction getNameInfo(fullyQualifiedName) {\n  return config_1.config.network.getNameInfo(fullyQualifiedName);\n}\n\nexports.getNameInfo = getNameInfo;\n/**\n* @ignore\n*/\n\nexports.network = {\n  BlockstackNetwork,\n  LocalRegtest,\n  BlockchainInfoApi,\n  BitcoindAPI,\n  InsightClient,\n  defaults: {\n    LOCAL_REGTEST,\n    MAINNET_DEFAULT: exports.MAINNET_DEFAULT\n  }\n};","map":{"version":3,"sources":["../src/network.ts"],"names":[],"mappings":";;;;;;;;AAAA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,EAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAuBA,MAAM,gBAAgB,GAAG,GAAzB;AACA,MAAM,uCAAuC,GAAG,WAAhD;AACA,MAAM,0CAA0C,GAAG,cAAnD;AACA,MAAM,gCAAgC,GAAG,aAAzC;AAEA;;;;;AAIA,MAAa,cAAb,CAA2B;AACzB,EAAA,oBAAoB,CAAC,WAAD,EAAoB;AACtC,WAAO,OAAO,CAAC,MAAR,CAAe,IAAI,KAAJ,CAAU,yCAAyC,WAAW,GAA9D,CAAf,CAAP;AACD;;AAED,EAAA,cAAc,GAAA;AACZ,WAAO,OAAO,CAAC,MAAR,CAAe,IAAI,KAAJ,CAAU,mCAAV,CAAf,CAAP;AACD;;AAED,EAAA,kBAAkB,CAAC,IAAD,EAAa;AAC7B,WAAO,OAAO,CAAC,MAAR,CAAe,IAAI,KAAJ,CAAU,uCAAuC,IAAI,GAArD,CAAf,CAAP;AACD;;AAED,EAAA,iBAAiB,CAAC,OAAD,EAAgB;AAC/B,WAAO,OAAO,CAAC,MAAR,CAAe,IAAI,KAAJ,CAAU,sCAAsC,OAAO,GAAvD,CAAf,CAAP;AACD;;AAfwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA;AAiBA;;;;AAGA,MAAa,iBAAb,CAA8B;AAoB5B,EAAA,WAAA,CAAY,MAAZ,EAA4B,mBAA5B,EACY,UADZ,EAEY,OAAO,GAAG,eAAA,CAAA,QAAA,CAAS,OAF/B,EAEsC;AACpC,SAAK,gBAAL,GAAwB,MAAxB;AACA,SAAK,mBAAL,GAA2B,mBAA3B;AACA,SAAK,MAAL,GAAc,OAAd;AACA,SAAK,GAAL,GAAW,UAAX;AAEA,SAAK,YAAL,GAAoB,IAApB;AACA,SAAK,cAAL,GAAsB,EAAtB;AACA,SAAK,cAAL,GAAsB,EAAtB;AACA,SAAK,WAAL,GAAmB,IAAnB;AACD;AAED;;;;;AAGA,EAAA,aAAa,CAAC,OAAD,EAAgB;AAC3B,UAAM;AAAE,MAAA,IAAF;AAAQ,MAAA;AAAR,QAAoB,eAAA,CAAA,OAAA,CAAW,eAAX,CAA2B,OAA3B,CAA1B;AACA,UAAM,YAAY,GAAG,CAAC,eAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,UAAlB,EACC,eAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,UADlB,CAArB;AAEA,UAAM,YAAY,GAAG,CAAC,eAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,UAAlB,EACC,eAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,UADlB,CAArB;AAEA,QAAI,cAAJ;;AACA,QAAI,YAAY,CAAC,OAAb,CAAqB,OAArB,KAAiC,CAArC,EAAwC;AACtC,MAAA,cAAc,GAAG,KAAK,MAAL,CAAY,UAA7B;AACD,KAFD,MAEO,IAAI,YAAY,CAAC,OAAb,CAAqB,OAArB,KAAiC,CAArC,EAAwC;AAC7C,MAAA,cAAc,GAAG,KAAK,MAAL,CAAY,UAA7B;AACD,KAFM,MAEA;AACL,YAAM,IAAI,KAAJ,CAAU,uCAAuC,OAAO,OAAO,OAAO,EAAtE,CAAN;AACD;;AACD,WAAO,eAAA,CAAA,OAAA,CAAW,aAAX,CAAyB,IAAzB,EAA+B,cAA/B,CAAP;AACD;AAED;;;;;AAGA,EAAA,qBAAqB,GAAA;AACnB,WAAO,KAAK,aAAL,CAAmB,6BAAnB,CAAP;AACD;AAED;;;;;;;;;AAOA,EAAA,cAAc,CAAC,kBAAD,EAA2B;AACvC;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,oBAAoB,kBAAkB,EAA3E,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,CAAC,IAAI,CAAC,EAAV,EAAc;AACZ,cAAM,IAAI,KAAJ,CAAU,kCAAkC,kBAAkB,EAA9D,CAAN;AACD;;AACD,aAAO,IAAP;AACD,KANI,EAOJ,IAPI,CAOC,IAAI,IAAI,IAAI,CAAC,IAAL,EAPT,EAQJ,IARI,CAQC,IAAI,IAAI,IAAI,CAAC,UARd,EASJ,IATI,CASE,SAAD,IAAc;AAClB,UAAI,CAAC,SAAD,IAAc,CAAC,SAAS,CAAC,QAA7B,EAAuC;AACrC,cAAM,IAAI,KAAJ,CACJ,2BAA2B,kBAAkB,6BADzC,CAAN;AAGD;;AACD,UAAI,SAAS,CAAC,QAAV,GAAqB,KAAK,YAA9B,EAA4C;AAC1C,QAAA,SAAS,CAAC,QAAV,GAAqB,KAAK,YAA1B;AACD;;AACD,YAAM,MAAM,GAAG;AACb,QAAA,KAAK,EAAE,KADM;AAEb,QAAA,MAAM,EAAE,IAAI,EAAJ,CAAO,MAAM,CAAC,SAAS,CAAC,QAAX,CAAb;AAFK,OAAf;AAIA,aAAO,MAAP;AACD,KAvBI,CAAP;AAwBD;AAED;;;;;;;;;AAOA,EAAA,mBAAmB,CAAC,WAAD,EAAoB;AACrC;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,yBAAyB,WAAW,EAAzE,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,CAAC,IAAI,CAAC,EAAV,EAAc;AACZ,cAAM,IAAI,KAAJ,CAAU,kCAAkC,WAAW,EAAvD,CAAN;AACD;;AACD,aAAO,IAAP;AACD,KANI,EAOJ,IAPI,CAOC,IAAI,IAAI,IAAI,CAAC,IAAL,EAPT,EAQJ,IARI,CAQE,cAAD,IAAmB;AACvB,UAAI,CAAC,cAAD,IAAmB,CAAC,cAAc,CAAC,QAAvC,EAAiD;AAC/C,cAAM,IAAI,KAAJ,CAAU,2BAA2B,WAAW,EAAhD,CAAN;AACD;;AACD,UAAI,cAAc,CAAC,QAAf,GAA0B,KAAK,YAAnC,EAAiD;AAC/C,QAAA,cAAc,CAAC,QAAf,GAA0B,KAAK,YAA/B;AACD;;AACD,YAAM,MAAM,GAAG;AACb,QAAA,KAAK,EAAE,KADM;AAEb,QAAA,MAAM,EAAE,IAAI,EAAJ,CAAO,MAAM,CAAC,cAAc,CAAC,QAAhB,CAAb;AAFK,OAAf;AAIA,aAAO,MAAP;AACD,KApBI,CAAP;AAqBD;AAED;;;;;;;;;AAOA,EAAA,cAAc,CAAC,kBAAD,EAA2B;AACvC,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,oBAAoB,kBAAkB,EAA3E,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB;AACA,cAAM,IAAI,KAAJ,CAAU,4DAAV,CAAN;AACD;;AACD,aAAO,IAAP;AACD,KAPI,EAQJ,IARI,CAQC,IAAI,IAAI,IAAI,CAAC,IAAL,EART,EASJ,IATI,CASC,IAAI,IAAI,IAAI,CAAC,UATd,EAUJ,IAVI,CAUE,SAAD,IAAc;AAClB,UAAI,CAAC,SAAL,EAAgB;AACd,cAAM,IAAI,KAAJ,CACJ,2BAA2B,kBAAkB,6BADzC,CAAN;AAGD;;AACD,YAAM,MAAM,GAAG;AACb,QAAA,KAAK,EAAE,SAAS,CAAC,KADJ;AAEb,QAAA,MAAM,EAAE,IAAI,EAAJ,CAAO,SAAS,CAAC,MAAjB;AAFK,OAAf;;AAIA,UAAI,SAAS,CAAC,KAAV,KAAoB,KAAxB,EAA+B;AAC7B;AACA,cAAM,OAAO,GAAG,IAAI,EAAJ,CAAO,MAAM,CAAC,KAAK,YAAN,CAAb,CAAhB;;AACA,YAAI,MAAM,CAAC,MAAP,CAAc,IAAd,CAAmB,OAAnB,IAA8B,CAAlC,EAAqC;AACnC,UAAA,MAAM,CAAC,MAAP,GAAgB,OAAhB;AACD;AACF;;AACD,aAAO,MAAP;AACD,KA5BI,CAAP;AA6BD;AAED;;;;;;;;;AAOA,EAAA,mBAAmB,CAAC,WAAD,EAAoB;AACrC,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,yBAAyB,WAAW,EAAzE,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB;AACA,cAAM,IAAI,KAAJ,CAAU,4DAAV,CAAN;AACD;;AACD,aAAO,IAAP;AACD,KAPI,EAQJ,IARI,CAQC,IAAI,IAAI,IAAI,CAAC,IAAL,EART,EASJ,IATI,CASE,cAAD,IAAmB;AACvB,UAAI,CAAC,cAAL,EAAqB;AACnB,cAAM,IAAI,KAAJ,CAAU,2BAA2B,WAAW,EAAhD,CAAN;AACD;;AACD,YAAM,MAAM,GAAG;AACb,QAAA,KAAK,EAAE,cAAc,CAAC,KADT;AAEb,QAAA,MAAM,EAAE,IAAI,EAAJ,CAAO,cAAc,CAAC,MAAtB;AAFK,OAAf;;AAIA,UAAI,cAAc,CAAC,KAAf,KAAyB,KAA7B,EAAoC;AAClC;AACA,cAAM,OAAO,GAAG,IAAI,EAAJ,CAAO,MAAM,CAAC,KAAK,YAAN,CAAb,CAAhB;;AACA,YAAI,MAAM,CAAC,MAAP,CAAc,IAAd,CAAmB,OAAnB,IAA8B,CAAlC,EAAqC;AACnC,UAAA,MAAM,CAAC,MAAP,GAAgB,OAAhB;AACD;AACF;;AACD,aAAO,MAAP;AACD,KAzBI,CAAP;AA0BD;AAED;;;;;;;;;;;;;AAWA,EAAA,YAAY,CAAC,kBAAD,EAA2B;AACrC;AACA,WAAO,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,MAAM,KAAK,cAAL,CAAoB,kBAApB,CAA7B,EACJ,KADI,CACE,MAAM,KAAK,cAAL,CAAoB,kBAApB,CADR,CAAP;AAED;AAED;;;;;;;;;;;;AAUA,EAAA,iBAAiB,CAAC,WAAD,EAAoB;AACnC;AACA,WAAO,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,MAAM,KAAK,mBAAL,CAAyB,WAAzB,CAA7B,EACJ,KADI,CACE,MAAM,KAAK,mBAAL,CAAyB,WAAzB,CADR,CAAP;AAED;AAED;;;;;;;;;AAOA,EAAA,cAAc,CAAC,mBAAD,EAA6B;AACzC,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACD;AAED;;;;;;;;AAMA,EAAA,aAAa,CAAC,OAAD,EAAgB;AAC3B,UAAM,cAAc,GAAG,KAAK,aAAL,CAAmB,OAAnB,CAAvB;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,yBAAyB,cAAc,EAA5E,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEC,GAAG,IAAI,GAAG,CAAC,KAFZ,CAAP;AAGD;AAED;;;;;;;;;;AAQA,EAAA,uBAAuB,CAAC,SAAD,EAAkB;AACvC,WAAO,OAAO,CAAC,GAAR,CAAY,CACjB,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,kBAAkB,SAAS,EAAhE,CADiB,EAEjB,KAAK,cAAL,EAFiB,CAAZ,EAIJ,IAJI,CAIC,CAAC,CAAC,IAAD,EAAO,WAAP,CAAD,KAAwB;AAC5B,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,sBAAsB,SAAS,GAAzC,CAAN;AACD,OAFD,MAEO;AACL,eAAO,OAAO,CAAC,GAAR,CAAY,CAAC,IAAI,CAAC,IAAL,EAAD,EAAc,WAAd,CAAZ,CAAP;AACD;AACF,KAVI,EAWJ,IAXI,CAWC,CAAC,CAAC,aAAD,EAAgB,WAAhB,CAAD,KAAiC;AACrC,UAAI,OAAO,GAAG,KAAK,qBAAL,EAAd;;AACA,UAAI,aAAa,CAAC,OAAd,KAA0B,CAA9B,EAAiC;AAC/B;AACA,YAAI,aAAa,CAAC,YAAd,GAA6B,KAA7B,IAAsC,WAA1C,EAAuD;AACrD,UAAA,OAAO,GAAG,aAAa,CAAC,OAAxB;AACD;AACF;;AACD,aAAO,OAAP;AACD,KApBI,EAqBJ,IArBI,CAqBC,OAAO,IAAI,KAAK,aAAL,CAAmB,OAAnB,CArBZ,CAAP;AAsBD;AAED;;;;;;;;;;AAQA,EAAA,WAAW,CAAC,kBAAD,EAA2B;AACpC,IAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,KAAK,gBAAlB;AACA,UAAM,aAAa,GAAG,GAAG,KAAK,gBAAgB,aAAa,kBAAkB,EAA7E;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,aAAb,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,gBAAV,CAAN;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KATI,EAUJ,IAVI,CAUE,QAAD,IAAa;AACjB,MAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,aAAa,IAAI,CAAC,SAAL,CAAe,QAAf,CAAwB,EAAlD,EADiB,CAEjB;AACA;AACA;;AACA,UAAI,QAAQ,CAAC,OAAb,EAAsB;AACpB,eAAO,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,QAAlB,EAA4B;AAAE,UAAA,OAAO,EAAE,KAAK,aAAL,CAAmB,QAAQ,CAAC,OAA5B;AAAX,SAA5B,CAAP;AACD,OAFD,MAEO;AACL,eAAO,QAAP;AACD;AACF,KApBI,CAAP;AAqBD;AAED;;;;;;;;AAMA,EAAA,gBAAgB,CAAC,WAAD,EAAoB;AAClC,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,kBAAkB,WAAW,EAAlE,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KATI,EAUJ,IAVI,CAUE,aAAD,IAAkB;AACtB;AACA;AACA;AACA,UAAI,aAAa,CAAC,OAAd,IAAyB,aAAa,CAAC,iBAA3C,EAA8D;AAC5D,eAAO,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,aAAlB,EAAiC;AACtC,UAAA,OAAO,EAAE,KAAK,aAAL,CAAmB,aAAa,CAAC,OAAjC,CAD6B;AAEtC,UAAA,iBAAiB,EAAE,KAAK,aAAL,CAAmB,aAAa,CAAC,iBAAjC;AAFmB,SAAjC,CAAP;AAID,OALD,MAKO;AACL,eAAO,aAAP;AACD;AACF,KAtBI,CAAP;AAuBD;AAED;;;;;;;;;;;AASA,EAAA,WAAW,CAAC,YAAD,EAAqB;AAC9B,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,iBAAiB,YAAY,EAAlE,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,eAAO,IAAI,CAAC,IAAL,GACJ,IADI,CACQ,IAAP,IAAe,OAAA,CAAA,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACnB,gBAAM,QAAQ,GAAG,MAAM,UAAA,CAAA,cAAA,EAAvB;AACA,gBAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,MAAT,CAAgB,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAhB,CAArB;AACA,gBAAM,CAAC,GAAG,eAAA,CAAA,aAAA,CAAc,MAAd,EAAsB,QAAtB,CAA+B,KAA/B,CAAV;;AACA,cAAI,CAAC,KAAK,YAAV,EAAwB;AACtB,kBAAM,IAAI,KAAJ,CAAU,8BAA8B,CAAC,SAAS,YAAY,EAA9D,CAAN;AACD;;AACD,iBAAO,IAAP;AACD,SARoB,CADhB,CAAP;AAUD,OAXD,MAWO;AACL,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD;AACF,KAhBI,CAAP;AAiBD;AAED;;;;;;;;;;;;AAUA,EAAA,gBAAgB,CAAC,OAAD,EAAkB,SAAlB,EAAmC;AACjD,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,gBAAgB,OAAO,IAAI,SAAS,SAAzE,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KATI,EASF,IATE,CASI,aAAD,IAAkB;AACxB;AACA,YAAM,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,aAAlB,EAAiC;AACvD,QAAA,OAAO,EAAE,KAAK,aAAL,CAAmB,aAAa,CAAC,OAAjC,CAD8C;AAEvD,QAAA,WAAW,EAAE,IAAI,EAAJ,CAAO,MAAM,CAAC,aAAa,CAAC,WAAf,CAAb,CAF0C;AAGvD,QAAA,YAAY,EAAE,IAAI,EAAJ,CAAO,MAAM,CAAC,aAAa,CAAC,YAAf,CAAb;AAHyC,OAAjC,CAAxB;AAKA,aAAO,eAAP;AACD,KAjBI,CAAP;AAkBD;AAGD;;;;;;;;;;AAQA,EAAA,qBAAqB,CAAC,OAAD,EACC,IADD,EACa;AAChC,UAAM,GAAG,GAAG,GAAG,KAAK,gBAAgB,gBAAgB,OAAO,iBAAiB,IAAI,EAAhF;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAb,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KATI,EAUJ,IAVI,CAUE,WAAD,IAAgB;AACpB,UAAI,WAAW,CAAC,KAAhB,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,uCAAuC,WAAW,CAAC,KAAK,EAAlE,CAAN;AACD,OAHmB,CAIpB;;;AACA,aAAO,WAAW,CAAC,GAAZ,CAAiB,SAAD,IAAmB;AACxC,QAAA,SAAS,CAAC,OAAV,GAAoB,KAAK,aAAL,CAAmB,SAAS,CAAC,OAA7B,CAApB;AACA,QAAA,SAAS,CAAC,WAAV,GAAwB,IAAI,EAAJ,CAAO,MAAM,CAAC,SAAS,CAAC,WAAX,CAAb,CAAxB;AACA,QAAA,SAAS,CAAC,YAAV,GAAyB,IAAI,EAAJ,CAAO,MAAM,CAAC,SAAS,CAAC,YAAX,CAAb,CAAzB;AACA,eAAO,SAAP;AACD,OALM,CAAP;AAMD,KArBI,CAAP;AAsBD;AAED;;;;;;;;;;;;;AAWA,EAAA,YAAY,CAAC,OAAD,EAAkB,WAAlB,EAAqC;AAC/C,UAAM,GAAG,GAAG,GAAG,KAAK,gBAAgB,gBAAgB,OAAO,YAAY,WAAW,EAAlF;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAb,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KATI,EAUJ,IAVI,CAUE,WAAD,IAAgB;AACpB,UAAI,WAAW,CAAC,KAAhB,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,yCAAyC,WAAW,CAAC,KAAK,EAApE,CAAN;AACD,OAHmB,CAIpB;;;AACA,aAAO,WAAW,CAAC,GAAZ,CAAiB,SAAD,IAAmB;AACxC,QAAA,SAAS,CAAC,OAAV,GAAoB,KAAK,aAAL,CAAmB,SAAS,CAAC,OAA7B,CAApB;AACA,QAAA,SAAS,CAAC,WAAV,GAAwB,IAAI,EAAJ,CAAO,MAAM,CAAC,SAAS,CAAC,WAAX,CAAb,CAAxB;AACA,QAAA,SAAS,CAAC,YAAV,GAAyB,IAAI,EAAJ,CAAO,MAAM,CAAC,SAAS,CAAC,YAAX,CAAb,CAAzB;AACA,eAAO,SAAP;AACD,OALM,CAAP;AAMD,KArBI,CAAP;AAsBD;AAED;;;;;;;;;AAOA,EAAA,gBAAgB,CAAC,OAAD,EAAgB;AAC9B,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,gBAAgB,OAAO,SAA5D,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KATI,EAUJ,IAVI,CAUE,SAAD,IAAc;AAClB,UAAI,SAAS,CAAC,KAAd,EAAqB;AACnB,cAAM,IAAI,KAAJ,CAAU,6BAA6B,SAAS,CAAC,KAAK,EAAtD,CAAN;AACD;;AACD,aAAO,SAAP;AACD,KAfI,CAAP;AAgBD;AAED;;;;;;;;;;;;AAUA,EAAA,iBAAiB,CAAC,OAAD,EAAkB,SAAlB,EAAmC;AAClD,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,gBAAgB,OAAO,IAAI,SAAS,UAAzE,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB;AACA,eAAO,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,MAAM,IAAI,EAAJ,CAAO,GAAP,CAA7B,CAAP;AACD,OAHD,MAGO,IAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AAC9B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,IAAI,CAAC,MAAM,EAA7C,CAAN;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KAVI,EAWJ,IAXI,CAWE,YAAD,IAAiB;AACrB,UAAI,YAAY,CAAC,KAAjB,EAAwB;AACtB,cAAM,IAAI,KAAJ,CAAU,kCAAkC,YAAY,CAAC,KAAK,EAA9D,CAAN;AACD;;AACD,UAAI,OAAO,GAAG,GAAd;;AACA,UAAI,YAAY,IAAI,YAAY,CAAC,OAAjC,EAA0C;AACxC,QAAA,OAAO,GAAG,YAAY,CAAC,OAAvB;AACD;;AACD,aAAO,IAAI,EAAJ,CAAO,OAAP,CAAP;AACD,KApBI,CAAP;AAqBD;AAGD;;;;;;;;;;;;;;;;AAcA,EAAA,2BAA2B,CAAC,QAAD,EAAmB,IAAnB,EAA4B;AACrD,UAAM,cAAc,GAAG;AACrB,MAAA,MAAM,EAAE,kBADa;AAErB,sBAAgB;AAFK,KAAvB;AAKA,UAAM,OAAO,GAAG;AACd,MAAA,MAAM,EAAE,MADM;AAEd,MAAA,OAAO,EAAE,cAFK;AAGd,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,IAAf;AAHQ,KAAhB;AAMA,UAAM,GAAG,GAAG,GAAG,KAAK,mBAAmB,iBAAiB,QAAQ,EAAhE;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAb,EAAkB,OAAlB,EACJ,IADI,CACE,QAAD,IAAa;AACjB,UAAI,QAAQ,CAAC,EAAb,EAAiB;AACf,eAAO,QAAQ,CAAC,IAAT,EAAP;AACD,OAFD,MAEO;AACL,cAAM,IAAI,QAAA,CAAA,kBAAJ,CAAuB,QAAvB,CAAN;AACD;AACF,KAPI,CAAP;AAQD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAqBA,EAAA,oBAAoB,CAClB,WADkB,EAElB,kBAAA,GAA6B,IAFX,EAGlB,aAAA,GAAwB,CAHN,EAGO;AAEzB,QAAI,CAAC,WAAL,EAAkB;AAChB,YAAM,KAAK,GAAG,IAAI,QAAA,CAAA,qBAAJ,CAA0B,aAA1B,CAAd;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACD;;AAED,QAAI,CAAC,aAAD,IAAkB,aAAa,KAAK,CAAxC,EAA2C;AACzC,YAAM,KAAK,GAAG,IAAI,QAAA,CAAA,qBAAJ,CAA0B,eAA1B,CAAd;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACD;;AAED,QAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B,aAAO,KAAK,GAAL,CAAS,oBAAT,CAA8B,WAA9B,CAAP;AACD,KAFD,MAEO;AACL;;;;;;;;;AASA,YAAM,QAAQ,GAAG,gCAAjB;AAEA,YAAM,WAAW,GAAG;AAClB,QAAA,WADkB;AAElB,QAAA,kBAFkB;AAGlB,QAAA;AAHkB,OAApB;AAMA,aAAO,KAAK,2BAAL,CAAiC,QAAjC,EAA2C,WAA3C,CAAP;AACD;AACF;AAED;;;;;;;;;;;;;;;;;;;AAiBA,EAAA,iBAAiB,CACf,QADe,EAEf,kBAAA,GAA6B,IAFd,EAEkB;AAEjC,QAAI,CAAC,QAAL,EAAe;AACb,aAAO,OAAO,CAAC,MAAR,CAAe,IAAI,QAAA,CAAA,qBAAJ,CAA0B,UAA1B,CAAf,CAAP;AACD,KAJgC,CAMjC;;;AAEA,QAAI,kBAAJ,EAAwB;AACtB;;AAEA;;;;;;;;AASA,YAAM,WAAW,GAAG;AAClB,QAAA,QADkB;AAElB,QAAA;AAFkB,OAApB;AAKA,YAAM,QAAQ,GAAG,uCAAjB;AAEA,aAAO,KAAK,2BAAL,CAAiC,QAAjC,EAA2C,WAA3C,CAAP;AACD,KApBD,MAoBO;AACL;AAEA;AACA,YAAM,WAAW,GAAG;AAAE,QAAA,QAAQ,EAAE;AAAZ,OAApB;AAEA,aAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,eAArC,EACa;AACE,QAAA,MAAM,EAAE,MADV;AAEE,QAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,WAAf,CAFR;AAGE,QAAA,OAAO,EAAE;AACP,0BAAgB;AADT;AAHX,OADb,EAQJ,IARI,CAQE,IAAD,IAAS;AACb,cAAM,IAAI,GAAG,IAAI,CAAC,IAAL,EAAb;AACA,eAAO,IAAI,CACR,IADI,CACE,OAAD,IAAY;AAChB,cAAI,OAAO,CAAC,cAAR,CAAuB,OAAvB,CAAJ,EAAqC;AACnC,kBAAM,IAAI,QAAA,CAAA,kBAAJ,CAAuB,IAAvB,CAAN;AACD;;AACD,iBAAO,OAAO,CAAC,OAAf;AACD,SANI,CAAP;AAOD,OAjBI,CAAP;AAkBD;AACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,EAAA,yBAAyB,CACvB,mBADuB,EAEvB,mBAFuB,EAGvB,QAHuB,EAGP;AAEhB;;;;;;;;;AAUA,QAAI,CAAC,mBAAL,EAA0B;AACxB,YAAM,KAAK,GAAG,IAAI,QAAA,CAAA,qBAAJ,CAA0B,qBAA1B,CAAd;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACD;;AAED,QAAI,CAAC,mBAAL,EAA0B;AACxB,YAAM,KAAK,GAAG,IAAI,QAAA,CAAA,qBAAJ,CAA0B,qBAA1B,CAAd;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACD;;AAED,QAAI,CAAC,QAAL,EAAe;AACb,YAAM,KAAK,GAAG,IAAI,QAAA,CAAA,qBAAJ,CAA0B,UAA1B,CAAd;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACD;;AAED,UAAM,WAAW,GAAG;AAClB,MAAA,mBADkB;AAElB,MAAA,mBAFkB;AAGlB,MAAA;AAHkB,KAApB;AAMA,UAAM,QAAQ,GAAG,0CAAjB;AAEA,WAAO,KAAK,2BAAL,CAAiC,QAAjC,EAA2C,WAA3C,CAAP;AACD;AAED;;;;;AAGA,EAAA,UAAU,GAAA;AACR,WAAO,WAAA,CAAA,YAAA,CAAa,sDAAb,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEC,KAAK,IAAI,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,UAAjB,CAFV,CAAP;AAGD;AAED;;;;;AAGA,EAAA,gBAAgB,GAAA;AACd,UAAM,IAAI,KAAJ,CAAU,kBAAV,CAAN;AACD;AAED;;;;;AAGA,EAAA,QAAQ,CAAC,OAAD,EAAgB;AACtB,WAAO,KAAK,iBAAL,CAAuB,OAAvB,EACJ,IADI,CACE,cAAD,IAAmB;AACvB,UAAI,SAAS,GAAG,cAAc,CAAC,MAAf,EAAhB;;AACA,UAAI,KAAK,cAAL,CAAoB,cAApB,CAAmC,OAAnC,CAAJ,EAAiD;AAC/C,QAAA,SAAS,GAAG,cAAc,CAAC,MAAf,CAAsB,KAAK,cAAL,CAAoB,OAApB,CAAtB,CAAZ;AACD,OAJsB,CAMvB;AACA;;;AACA,YAAM,UAAU,GAAG,KAAK,cAAxB;AACA,MAAA,SAAS,GAAG,SAAS,CAAC,MAAV,CACT,IAAD,IAAS;AACP,cAAM,YAAY,GAAG,UAAU,CAAC,MAAX,CACnB,CAAC,KAAD,EAAQ,WAAR,KAAwB,KAAK,IAAK,WAAW,CAAC,OAAZ,KAAwB,IAAI,CAAC,OAA7B,IACnB,WAAW,CAAC,WAAZ,KAA4B,IAAI,CAAC,WAF7B,EAE2C,KAF3C,CAArB;AAIA,eAAO,CAAC,YAAR;AACD,OAPS,CAAZ;AAUA,aAAO,SAAP;AACD,KArBI,CAAP;AAsBD;AAED;;;;;;;;;;;;;AAWA,EAAA,iBAAiB,CAAC,KAAD,EAAc;AAC7B,UAAM,EAAE,GAAG,eAAA,CAAA,WAAA,CAAY,OAAZ,CAAoB,KAApB,CAAX;AAEA,UAAM,UAAU,GAAW,KAAK,cAAL,CAAoB,MAApB,EAA3B;AAEA,IAAA,EAAE,CAAC,GAAH,CAAO,OAAP,CAAgB,QAAD,IAAa;AAC1B,YAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,QAAQ,CAAC,IAArB,CAApB;AACA,MAAA,WAAW,CAAC,OAAZ;AACA,MAAA,UAAU,CAAC,IAAX,CAAgB;AACd,QAAA,OAAO,EAAE,WAAW,CAAC,QAAZ,CAAqB,KAArB,CADK;AAEd,QAAA,WAAW,EAAE,QAAQ,CAAC;AAFR,OAAhB;AAID,KAPD;AASA,SAAK,cAAL,GAAsB,UAAtB;AAEA,UAAM,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,EAAE,CAAC,OAAH,GAAa,OAAb,EAAZ,EAAoC,QAApC,CAA6C,KAA7C,CAAf;AACA,IAAA,EAAE,CAAC,IAAH,CAAQ,OAAR,CAAgB,CAAC,WAAD,EAAc,SAAd,KAA2B;AACzC,YAAM,UAAU,GAAG,SAAS,UAAT,CAAoB,MAApB,EAAkC;AACnD,YAAI;AACF,UAAA,eAAA,CAAA,QAAA,CAAS,KAAT,CAAe;AAAE,YAAA,MAAM,EAAE;AAAV,WAAf,EAAmC;AAAE,YAAA,QAAQ,EAAE;AAAZ,WAAnC;AACA,iBAAO,IAAP;AACD,SAHD,CAGE,OAAO,CAAP,EAAU;AACV,iBAAO,KAAP;AACD;AACF,OAPD;;AAQA,UAAI,UAAU,CAAC,WAAW,CAAC,MAAb,CAAd,EAAoC;AAClC;AACD;;AACD,YAAM,OAAO,GAAG,eAAA,CAAA,OAAA,CAAW,gBAAX,CACd,WAAW,CAAC,MADE,EACM,KAAK,MADX,CAAhB;AAIA,UAAI,UAAU,GAAW,EAAzB;;AACA,UAAI,KAAK,cAAL,CAAoB,cAApB,CAAmC,OAAnC,CAAJ,EAAiD;AAC/C,QAAA,UAAU,GAAG,UAAU,CAAC,MAAX,CAAkB,KAAK,cAAL,CAAoB,OAApB,CAAlB,CAAb;AACD;;AAED,MAAA,UAAU,CAAC,IAAX,CAAgB;AACd,QAAA,OAAO,EAAE,MADK;AAEd,QAAA,aAAa,EAAE,CAFD;AAGd,QAAA,KAAK,EAAG,WAAwB,CAAC,KAHnB;AAId,QAAA,WAAW,EAAE;AAJC,OAAhB;AAMA,WAAK,cAAL,CAAoB,OAApB,IAA+B,UAA/B;AACD,KA5BD;AA6BD;AAED;;;;;AAGA,EAAA,UAAU,CAAC,OAAD,EAAgB;AACxB,WAAO,KAAK,cAAL,CAAoB,OAApB,CAAP;AACA,SAAK,cAAL,GAAsB,EAAtB;AACD;AAED;;;;;AAGA,EAAA,gBAAgB,GAAA;AACd,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,gBAAgB,mCAArC,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEC,CAAC,IAAI,CAAC,CAAC,cAFR,CAAP;AAGD;;AAED,EAAA,kBAAkB,CAAC,MAAD,EAAe;AAC/B,WAAO,KAAK,GAAL,CAAS,kBAAT,CAA4B,MAA5B,CAAP;AACD;AAED;;;;;AAGA,EAAA,cAAc,GAAA;AACZ,WAAO,KAAK,GAAL,CAAS,cAAT,EAAP;AACD;;AAED,EAAA,iBAAiB,CAAC,OAAD,EAAgB;AAC/B,WAAO,KAAK,GAAL,CAAS,iBAAT,CAA2B,OAA3B,CAAP;AACD;;AAh6B2B;;AAA9B,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAm6BA;;;;AAGA,MAAa,YAAb,SAAkC,iBAAlC,CAAmD;AACjD,EAAA,WAAA,CAAY,MAAZ,EAA4B,mBAA5B,EACY,UADZ,EACsC;AACpC,UAAM,MAAN,EAAc,mBAAd,EAAmC,UAAnC,EAA+C,eAAA,CAAA,QAAA,CAAS,OAAxD;AACD;;AAED,EAAA,UAAU,GAAA;AACR,WAAO,OAAO,CAAC,OAAR,CAAgB,IAAI,CAAC,KAAL,CAAW,aAAa,gBAAxB,CAAhB,CAAP;AACD;;AARgD;;AAAnD,OAAA,CAAA,YAAA,GAAA,YAAA;AAWA;;;;AAGA,MAAa,WAAb,SAAiC,cAAjC,CAA+C;AAO7C,EAAA,WAAA,CAAY,WAAZ,EAAiC,mBAAjC,EAA0F;AACxF;AACA,SAAK,WAAL,GAAmB,WAAnB;AACA,SAAK,mBAAL,GAA2B,mBAA3B;AACA,SAAK,cAAL,GAAsB,EAAtB;AACD;;AAED,EAAA,oBAAoB,CAAC,WAAD,EAAoB;AACtC,UAAM,OAAO,GAAG;AACd,MAAA,OAAO,EAAE,KADK;AAEd,MAAA,MAAM,EAAE,oBAFM;AAGd,MAAA,MAAM,EAAE,CAAC,WAAD;AAHM,KAAhB;AAKA,UAAM,UAAU,GAAQ,MAAM,CAAC,IAAP,CAAY,GAAG,KAAK,mBAAL,CAAyB,QAAQ,IAAI,KAAK,mBAAL,CAAyB,QAAQ,EAArF,EACrB,QADqB,CACZ,QADY,CAAxB;AAEA,UAAM,OAAO,GAAG;AAAE,MAAA,aAAa,EAAE,SAAS,UAAU;AAApC,KAAhB;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,KAAK,WAAlB,EAA+B;AACpC,MAAA,MAAM,EAAE,MAD4B;AAEpC,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,OAAf,CAF8B;AAGpC,MAAA;AAHoC,KAA/B,EAKJ,IALI,CAKC,IAAI,IAAI,IAAI,CAAC,IAAL,EALT,EAMJ,IANI,CAMC,OAAO,IAAI,OAAO,CAAC,MANpB,CAAP;AAOD;;AAED,EAAA,cAAc,GAAA;AACZ,UAAM,OAAO,GAAG;AACd,MAAA,OAAO,EAAE,KADK;AAEd,MAAA,MAAM,EAAE;AAFM,KAAhB;AAIA,UAAM,UAAU,GAAQ,MAAM,CAAC,IAAP,CAAY,GAAG,KAAK,mBAAL,CAAyB,QAAQ,IAAI,KAAK,mBAAL,CAAyB,QAAQ,EAArF,EACrB,QADqB,CACZ,QADY,CAAxB;AAEA,UAAM,OAAO,GAAG;AAAE,MAAA,aAAa,EAAE,SAAS,UAAU;AAApC,KAAhB;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,KAAK,WAAlB,EAA+B;AACpC,MAAA,MAAM,EAAE,MAD4B;AAEpC,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,OAAf,CAF8B;AAGpC,MAAA;AAHoC,KAA/B,EAKJ,IALI,CAKC,IAAI,IAAI,IAAI,CAAC,IAAL,EALT,EAMJ,IANI,CAMC,OAAO,IAAI,OAAO,CAAC,MANpB,CAAP;AAOD;;AAED,EAAA,kBAAkB,CAAC,MAAD,EAAe;AAC/B,UAAM,OAAO,GAAG;AACd,MAAA,OAAO,EAAE,KADK;AAEd,MAAA,MAAM,EAAE,gBAFM;AAGd,MAAA,MAAM,EAAE,CAAC,MAAD;AAHM,KAAhB;AAKA,UAAM,UAAU,GAAQ,MAAM,CAAC,IAAP,CAAY,GAAG,KAAK,mBAAL,CAAyB,QAAQ,IAAI,KAAK,mBAAL,CAAyB,QAAQ,EAArF,EACrB,QADqB,CACZ,QADY,CAAxB;AAEA,UAAM,OAAO,GAAG;AAAE,MAAA,aAAa,EAAE,SAAS,UAAU;AAApC,KAAhB;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,KAAK,WAAlB,EAA+B;AACpC,MAAA,MAAM,EAAE,MAD4B;AAEpC,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,OAAf,CAF8B;AAGpC,MAAA;AAHoC,KAA/B,EAKJ,IALI,CAKC,IAAI,IAAI,IAAI,CAAC,IAAL,EALT,EAMJ,IANI,CAMC,OAAO,IAAI,OAAO,CAAC,MANpB,EAOJ,IAPI,CAOC,MAAM,IAAI,MAAM,CAAC,SAPlB,EAQJ,IARI,CAQE,SAAD,IAAc;AAClB,YAAM,YAAY,GAAG;AACnB,QAAA,OAAO,EAAE,KADU;AAEnB,QAAA,MAAM,EAAE,gBAFW;AAGnB,QAAA,MAAM,EAAE,CAAC,SAAD;AAHW,OAArB;AAKA,MAAA,OAAO,CAAC,aAAR,GAAwB,SAAS,UAAU,EAA3C;AACA,aAAO,WAAA,CAAA,YAAA,CAAa,KAAK,WAAlB,EAA+B;AACpC,QAAA,MAAM,EAAE,MAD4B;AAEpC,QAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,YAAf,CAF8B;AAGpC,QAAA;AAHoC,OAA/B,CAAP;AAKD,KApBI,EAqBJ,IArBI,CAqBC,IAAI,IAAI,IAAI,CAAC,IAAL,EArBT,EAsBJ,IAtBI,CAsBE,OAAD,IAAY;AAChB,UAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,MAAzB,EAAiC;AAC/B;AACA,cAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACD,OAHD,MAGO;AACL,eAAO;AAAE,UAAA,YAAY,EAAE,OAAO,CAAC,MAAR,CAAe;AAA/B,SAAP;AACD;AACF,KA7BI,CAAP;AA8BD;;AAED,EAAA,iBAAiB,CAAC,OAAD,EAAgB;AAC/B,UAAM,aAAa,GAAG;AACpB,MAAA,OAAO,EAAE,KADW;AAEpB,MAAA,MAAM,EAAE,eAFY;AAGpB,MAAA,MAAM,EAAE,CAAC,OAAD;AAHY,KAAtB;AAKA,UAAM,cAAc,GAAG;AACrB,MAAA,OAAO,EAAE,KADY;AAErB,MAAA,MAAM,EAAE,aAFa;AAGrB,MAAA,MAAM,EAAE,CAAC,CAAD,EAAI,OAAJ,EAAa,CAAC,OAAD,CAAb;AAHa,KAAvB;AAKA,UAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,GAAG,KAAK,mBAAL,CAAyB,QAAQ,IAAI,KAAK,mBAAL,CAAyB,QAAQ,EAArF,EAChB,QADgB,CACP,QADO,CAAnB;AAEA,UAAM,OAAO,GAAG;AAAE,MAAA,aAAa,EAAE,SAAS,UAAU;AAApC,KAAhB;AAEA,UAAM,aAAa,GAAI,KAAK,cAAL,CAAoB,OAApB,CAAD,GAClB,OAAO,CAAC,OAAR,EADkB,GAElB,WAAA,CAAA,YAAA,CAAa,KAAK,WAAlB,EAA+B;AAC/B,MAAA,MAAM,EAAE,MADuB;AAE/B,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,aAAf,CAFyB;AAG/B,MAAA;AAH+B,KAA/B,EAKC,IALD,CAKM,MAAK;AAAG,WAAK,cAAL,CAAoB,OAApB,IAA+B,IAA/B;AAAqC,KALnD,CAFJ;AASA,WAAO,aAAa,CACjB,IADI,CACC,MAAM,WAAA,CAAA,YAAA,CAAa,KAAK,WAAlB,EAA+B;AACzC,MAAA,MAAM,EAAE,MADiC;AAEzC,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,cAAf,CAFmC;AAGzC,MAAA;AAHyC,KAA/B,CADP,EAMJ,IANI,CAMC,IAAI,IAAI,IAAI,CAAC,IAAL,EANT,EAOJ,IAPI,CAOC,CAAC,IAAI,CAAC,CAAC,MAPR,EAQJ,IARI,CAQC,KAAK,IAAI,KAAK,CAAC,GAAN,CACZ,CAAD,KAAa;AACX,MAAA,KAAK,EAAE,IAAI,CAAC,KAAL,CAAW,CAAC,CAAC,MAAF,GAAW,gBAAtB,CADI;AAEX,MAAA,aAAa,EAAE,CAAC,CAAC,aAFN;AAGX,MAAA,OAAO,EAAE,CAAC,CAAC,IAHA;AAIX,MAAA,WAAW,EAAE,CAAC,CAAC;AAJJ,KAAb,CADa,CARV,CAAP;AAgBD;;AAlI4C;;AAA/C,OAAA,CAAA,WAAA,GAAA,WAAA;AAqIA;;;;AAGA,MAAa,aAAb,SAAmC,cAAnC,CAAiD;AAG/C,EAAA,WAAA,CAAY,UAAA,GAAqB,iCAAjC,EAAkE;AAChE;AACA,SAAK,MAAL,GAAc,UAAd;AACD;;AAED,EAAA,oBAAoB,CAAC,WAAD,EAAoB;AACtC,UAAM,QAAQ,GAAG;AAAE,MAAA,KAAK,EAAE;AAAT,KAAjB;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,MAAM,UAA3B,EACa;AACE,MAAA,MAAM,EAAE,MADV;AAEE,MAAA,OAAO,EAAE;AAAE,wBAAgB;AAAlB,OAFX;AAGE,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,QAAf;AAHR,KADb,EAMJ,IANI,CAMC,IAAI,IAAI,IAAI,CAAC,IAAL,EANT,CAAP;AAOD;;AAED,EAAA,cAAc,GAAA;AACZ,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,MAAM,SAA3B,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEC,MAAM,IAAI,MAAM,CAAC,MAFlB,CAAP;AAGD;;AAED,EAAA,kBAAkB,CAAC,MAAD,EAAe;AAC/B,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,MAAM,OAAO,MAAM,EAAxC,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEE,eAAD,IAAoB;AACxB,UAAI,eAAe,CAAC,KAApB,EAA2B;AACzB,cAAM,IAAI,KAAJ,CAAU,8BAA8B,eAAe,CAAC,KAAK,EAA7D,CAAN;AACD;;AACD,aAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,MAAM,UAAU,eAAe,CAAC,SAAS,EAA9D,CAAP;AACD,KAPI,EAQJ,IARI,CAQC,IAAI,IAAI,IAAI,CAAC,IAAL,EART,EASJ,IATI,CASC,SAAS,KAAK;AAAE,MAAA,YAAY,EAAE,SAAS,CAAC;AAA1B,KAAL,CATV,CAAP;AAUD;;AAED,EAAA,iBAAiB,CAAC,OAAD,EAAgB;AAC/B,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,MAAM,SAAS,OAAO,OAA3C,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEC,KAAK,IAAI,KAAK,CAAC,GAAN,CACZ,CAAD,KAAa;AACX,MAAA,KAAK,EAAE,CAAC,CAAC,QADE;AAEX,MAAA,aAAa,EAAE,CAAC,CAAC,aAFN;AAGX,MAAA,OAAO,EAAE,CAAC,CAAC,IAHA;AAIX,MAAA,WAAW,EAAE,CAAC,CAAC;AAJJ,KAAb,CADa,CAFV,CAAP;AAUD;;AAjD8C;;AAAjD,OAAA,CAAA,aAAA,GAAA,aAAA;AAqDA;;;;AAGA,MAAa,iBAAb,SAAuC,cAAvC,CAAqD;AAGnD,EAAA,WAAA,CAAY,iBAAA,GAA4B,yBAAxC,EAAiE;AAC/D;AACA,SAAK,eAAL,GAAuB,iBAAvB;AACD;;AAED,EAAA,cAAc,GAAA;AACZ,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,eAAe,wBAApC,EACJ,IADI,CACC,IAAI,IAAI,IAAI,CAAC,IAAL,EADT,EAEJ,IAFI,CAEC,QAAQ,IAAI,QAAQ,CAAC,MAFtB,CAAP;AAGD;;AAED,EAAA,iBAAiB,CAAC,OAAD,EAAgB;AAC/B,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,eAAe,+BAA+B,OAAO,YAA1E,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,QAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,wDAAb;AACA,eAAO;AACL,UAAA,eAAe,EAAE;AADZ,SAAP;AAGD,OALD,MAKO;AACL,eAAO,IAAI,CAAC,IAAL,EAAP;AACD;AACF,KAVI,EAWJ,IAXI,CAWC,QAAQ,IAAI,QAAQ,CAAC,eAXtB,EAYJ,IAZI,CAYC,QAAQ,IAAI,QAAQ,CAAC,GAAT,CACf,IAAD,IAAc;AACZ,YAAM,OAAO,GAAG;AACd,QAAA,KAAK,EAAE,IAAI,CAAC,KADE;AAEd,QAAA,WAAW,EAAE,IAAI,CAAC,WAFJ;AAGd,QAAA,aAAa,EAAE,IAAI,CAAC,aAHN;AAId,QAAA,OAAO,EAAE,IAAI,CAAC;AAJA,OAAhB;AAMA,aAAO,OAAP;AACD,KATe,CAZb,CAAP;AAuBD;;AAED,EAAA,kBAAkB,CAAC,MAAD,EAAe;AAC/B,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,eAAe,UAAU,MAAM,YAApD,EACJ,IADI,CACE,IAAD,IAAS;AACb,UAAI,IAAI,CAAC,MAAL,KAAgB,GAApB,EAAyB;AACvB,eAAO,IAAI,CAAC,IAAL,EAAP;AACD,OAFD,MAEO;AACL,cAAM,IAAI,KAAJ,CAAU,0CAA0C,MAAM,kBAA1D,CAAN;AACD;AACF,KAPI,EAQJ,IARI,CAQC,OAAO,KAAK;AAAE,MAAA,YAAY,EAAE,OAAO,CAAC;AAAxB,KAAL,CARR,CAAP;AASD;;AAED,EAAA,oBAAoB,CAAC,WAAD,EAAoB;AACtC,UAAM,IAAI,GAAG,IAAI,QAAJ,EAAb;AACA,IAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,EAAkB,WAAlB;AACA,WAAO,WAAA,CAAA,YAAA,CAAa,GAAG,KAAK,eAAe,mBAApC,EACa;AACE,MAAA,MAAM,EAAE,MADV;AAEE,MAAA,IAAI,EAAO;AAFb,KADb,EAKJ,IALI,CAKE,IAAD,IAAS;AACb,YAAM,IAAI,GAAG,IAAI,CAAC,IAAL,EAAb;AACA,aAAO,IAAI,CACR,IADI,CACE,QAAD,IAAa;AACjB,YAAI,QAAQ,CAAC,WAAT,GAAuB,OAAvB,CAA+B,uBAA/B,KAA2D,CAA/D,EAAkE;AAChE,gBAAM,MAAM,GAAG,MAAM,CAAC,IAAP,CACb,eAAA,CAAA,WAAA,CAAY,OAAZ,CAAoB,WAApB,EACG,OADH,GAEG,OAFH,EADa,EAGC,QAHD,CAGU,KAHV,CAAf,CADgE,CAIhC;;AAChC,iBAAO,MAAP;AACD,SAND,MAMO;AACL,gBAAM,IAAI,QAAA,CAAA,kBAAJ,CAAuB,IAAvB,EACuB,8CAA8C,QAAQ,EAD7E,CAAN;AAED;AACF,OAZI,CAAP;AAaD,KApBI,CAAP;AAqBD;;AA5EkD;;AAArD,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAgFA;;;;AAGA,MAAM,aAAa,GAAG,IAAI,YAAJ,CACpB,wBADoB,EAEpB,wBAFoB,EAGpB,IAAI,WAAJ,CAAgB,yBAAhB,EACgB;AAAE,EAAA,QAAQ,EAAE,YAAZ;AAA0B,EAAA,QAAQ,EAAE;AAApC,CADhB,CAHoB,CAAtB;AAOA;;;;AAGa,OAAA,CAAA,eAAA,GAAkB,IAAI,iBAAJ,CAC7B,6BAD6B,EAE7B,kCAF6B,EAG7B,IAAI,iBAAJ,EAH6B,CAAlB;AAMb;;;;;;;;AAOA,SAAgB,WAAhB,CAA4B,kBAA5B,EAAsD;AACpD,SAAO,QAAA,CAAA,MAAA,CAAO,OAAP,CAAe,WAAf,CAA2B,kBAA3B,CAAP;AACD;;AAFD,OAAA,CAAA,WAAA,GAAA,WAAA;AAIA;;;;AAGa,OAAA,CAAA,OAAA,GAAU;AACrB,EAAA,iBADqB;AAErB,EAAA,YAFqB;AAGrB,EAAA,iBAHqB;AAIrB,EAAA,WAJqB;AAKrB,EAAA,aALqB;AAMrB,EAAA,QAAQ,EAAE;AAAE,IAAA,aAAF;AAAiB,IAAA,eAAe,EAAf,OAAA,CAAA;AAAjB;AANW,CAAV","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst FormData = require(\"form-data\");\nconst BN = require(\"bn.js\");\nconst errors_1 = require(\"./errors\");\nconst logger_1 = require(\"./logger\");\nconst config_1 = require(\"./config\");\nconst fetchUtil_1 = require(\"./fetchUtil\");\nconst sha2Hash_1 = require(\"./encryption/sha2Hash\");\nconst hashRipemd160_1 = require(\"./encryption/hashRipemd160\");\nconst SATOSHIS_PER_BTC = 1e8;\nconst TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';\nconst TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';\nconst TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';\n/**\n * @private\n * @ignore\n */\nclass BitcoinNetwork {\n    broadcastTransaction(transaction) {\n        return Promise.reject(new Error(`Not implemented, broadcastTransaction(${transaction})`));\n    }\n    getBlockHeight() {\n        return Promise.reject(new Error('Not implemented, getBlockHeight()'));\n    }\n    getTransactionInfo(txid) {\n        return Promise.reject(new Error(`Not implemented, getTransactionInfo(${txid})`));\n    }\n    getNetworkedUTXOs(address) {\n        return Promise.reject(new Error(`Not implemented, getNetworkedUTXOs(${address})`));\n    }\n}\nexports.BitcoinNetwork = BitcoinNetwork;\n/**\n * Use the methods in class to build third-party wallets or in DApps that register names.\n */\nclass BlockstackNetwork {\n    constructor(apiUrl, broadcastServiceUrl, bitcoinAPI, network = bitcoinjs_lib_1.networks.bitcoin) {\n        this.blockstackAPIUrl = apiUrl;\n        this.broadcastServiceUrl = broadcastServiceUrl;\n        this.layer1 = network;\n        this.btc = bitcoinAPI;\n        this.DUST_MINIMUM = 5500;\n        this.includeUtxoMap = {};\n        this.excludeUtxoSet = [];\n        this.MAGIC_BYTES = 'id';\n    }\n    /**\n     * @ignore\n     */\n    coerceAddress(address) {\n        const { hash, version } = bitcoinjs_lib_1.address.fromBase58Check(address);\n        const scriptHashes = [bitcoinjs_lib_1.networks.bitcoin.scriptHash,\n            bitcoinjs_lib_1.networks.testnet.scriptHash];\n        const pubKeyHashes = [bitcoinjs_lib_1.networks.bitcoin.pubKeyHash,\n            bitcoinjs_lib_1.networks.testnet.pubKeyHash];\n        let coercedVersion;\n        if (scriptHashes.indexOf(version) >= 0) {\n            coercedVersion = this.layer1.scriptHash;\n        }\n        else if (pubKeyHashes.indexOf(version) >= 0) {\n            coercedVersion = this.layer1.pubKeyHash;\n        }\n        else {\n            throw new Error(`Unrecognized address version number ${version} in ${address}`);\n        }\n        return bitcoinjs_lib_1.address.toBase58Check(hash, coercedVersion);\n    }\n    /**\n     * This is intended for use in third-party wallets or in DApps that register names.\n     */\n    getDefaultBurnAddress() {\n        return this.coerceAddress('1111111111111111111114oLvT2');\n    }\n    /**\n     * Get the price of a name via the legacy /v1/prices API endpoint. This is\n     * intended for use in third-party wallets or in DApps that register names.\n     * @param fullyQualifiedName the name to query\n     * @return a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamePriceV1(fullyQualifiedName) {\n        // legacy code path\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/names/${fullyQualifiedName}`)\n            .then((resp) => {\n            if (!resp.ok) {\n                throw new Error(`Failed to query name price for ${fullyQualifiedName}`);\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then(resp => resp.name_price)\n            .then((namePrice) => {\n            if (!namePrice || !namePrice.satoshis) {\n                throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);\n            }\n            if (namePrice.satoshis < this.DUST_MINIMUM) {\n                namePrice.satoshis = this.DUST_MINIMUM;\n            }\n            const result = {\n                units: 'BTC',\n                amount: new BN(String(namePrice.satoshis))\n            };\n            return result;\n        });\n    }\n    /**\n     * Get the price of a namespace via the legacy /v1/prices API endpoint. This is intended for\n     * use in third-party wallets or in DApps that register names.\n     * @param namespaceID the namespace to query\n     * @return a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamespacePriceV1(namespaceID) {\n        // legacy code path\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/namespaces/${namespaceID}`)\n            .then((resp) => {\n            if (!resp.ok) {\n                throw new Error(`Failed to query name price for ${namespaceID}`);\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then((namespacePrice) => {\n            if (!namespacePrice || !namespacePrice.satoshis) {\n                throw new Error(`Failed to get price for ${namespaceID}`);\n            }\n            if (namespacePrice.satoshis < this.DUST_MINIMUM) {\n                namespacePrice.satoshis = this.DUST_MINIMUM;\n            }\n            const result = {\n                units: 'BTC',\n                amount: new BN(String(namespacePrice.satoshis))\n            };\n            return result;\n        });\n    }\n    /**\n     * Get the price of a name via the /v2/prices API endpoint. This is intended\n     * for use in third-party wallets or in DApps that register names.\n     * @param fullyQualifiedName the name to query\n     * @return a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamePriceV2(fullyQualifiedName) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/names/${fullyQualifiedName}`)\n            .then((resp) => {\n            if (resp.status !== 200) {\n                // old core node \n                throw new Error('The upstream node does not handle the /v2/ price namespace');\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then(resp => resp.name_price)\n            .then((namePrice) => {\n            if (!namePrice) {\n                throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);\n            }\n            const result = {\n                units: namePrice.units,\n                amount: new BN(namePrice.amount)\n            };\n            if (namePrice.units === 'BTC') {\n                // must be at least dust-minimum\n                const dustMin = new BN(String(this.DUST_MINIMUM));\n                if (result.amount.ucmp(dustMin) < 0) {\n                    result.amount = dustMin;\n                }\n            }\n            return result;\n        });\n    }\n    /**\n     * Get the price of a namespace via the /v2/prices API endpoint.\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param namespaceID the namespace to query\n     * @return a promise to an Object with { units: String, amount: BigInteger }\n     * @private\n     */\n    getNamespacePriceV2(namespaceID) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/namespaces/${namespaceID}`)\n            .then((resp) => {\n            if (resp.status !== 200) {\n                // old core node \n                throw new Error('The upstream node does not handle the /v2/ price namespace');\n            }\n            return resp;\n        })\n            .then(resp => resp.json())\n            .then((namespacePrice) => {\n            if (!namespacePrice) {\n                throw new Error(`Failed to get price for ${namespaceID}`);\n            }\n            const result = {\n                units: namespacePrice.units,\n                amount: new BN(namespacePrice.amount)\n            };\n            if (namespacePrice.units === 'BTC') {\n                // must be at least dust-minimum\n                const dustMin = new BN(String(this.DUST_MINIMUM));\n                if (result.amount.ucmp(dustMin) < 0) {\n                    result.amount = dustMin;\n                }\n            }\n            return result;\n        });\n    }\n    /**\n     * Get the price of a name. This is intended for\n     * use in third-party wallets or in DApps that register names.\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param fullyQualifiedName the name to query\n     * @return a promise to an Object with { units: String, amount: BigInteger }, where\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n     *   .amount encodes the number of units, in the smallest denominiated amount\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n     *   .amount will be microStacks)\n     */\n    getNamePrice(fullyQualifiedName) {\n        // handle v1 or v2 \n        return Promise.resolve().then(() => this.getNamePriceV2(fullyQualifiedName))\n            .catch(() => this.getNamePriceV1(fullyQualifiedName));\n    }\n    /**\n     * Get the price of a namespace. This is intended for use in third-party\n     * wallets or in DApps that register names.\n     * @param namespaceID the namespace to query\n     * @return a promise to an Object with { units: String, amount: BigInteger }, where\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n     *   .amount encodes the number of units, in the smallest denominiated amount\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n     *   .amount will be microStacks)\n     */\n    getNamespacePrice(namespaceID) {\n        // handle v1 or v2 \n        return Promise.resolve().then(() => this.getNamespacePriceV2(namespaceID))\n            .catch(() => this.getNamespacePriceV1(namespaceID));\n    }\n    /**\n     * How many blocks can pass between a name expiring and the name being able to be\n     * re-registered by a different owner. This is intended for\n     * use in third-party wallets or in DApps that register names.\n     * @param fullyQualifiedName unused\n     * @return a promise to the number of blocks\n     */\n    getGracePeriod(_fullyQualifiedName) {\n        return Promise.resolve(5000);\n    }\n    /**\n     * Get the names -- both on-chain and off-chain -- owned by an address. This is intended for\n     * use in third-party wallets or in DApps that register names.\n     * @param address the blockchain address (the hash of the owner public key)\n     * @return a promise that resolves to a list of names (Strings)\n     */\n    getNamesOwned(address) {\n        const networkAddress = this.coerceAddress(address);\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/addresses/bitcoin/${networkAddress}`)\n            .then(resp => resp.json())\n            .then(obj => obj.names);\n    }\n    /**\n     * Get the blockchain address to which a name's registration fee must be sent\n     * (the address will depend on the namespace in which it is registered.)\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param namespace the namespace ID\n     * @return a promise that resolves to an address (String)\n     */\n    getNamespaceBurnAddress(namespace) {\n        return Promise.all([\n            fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespace}`),\n            this.getBlockHeight()\n        ])\n            .then(([resp, blockHeight]) => {\n            if (resp.status === 404) {\n                throw new Error(`No such namespace '${namespace}'`);\n            }\n            else {\n                return Promise.all([resp.json(), blockHeight]);\n            }\n        })\n            .then(([namespaceInfo, blockHeight]) => {\n            let address = this.getDefaultBurnAddress();\n            if (namespaceInfo.version === 2) {\n                // pay-to-namespace-creator if this namespace is less than 1 year old\n                if (namespaceInfo.reveal_block + 52595 >= blockHeight) {\n                    address = namespaceInfo.address;\n                }\n            }\n            return address;\n        })\n            .then(address => this.coerceAddress(address));\n    }\n    /**\n     * Get WHOIS-like information for a name, including the address that owns it,\n     * the block at which it expires, and the zone file anchored to it (if available).\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n     * @return a promise that resolves to the WHOIS-like information\n     */\n    getNameInfo(fullyQualifiedName) {\n        logger_1.Logger.debug(this.blockstackAPIUrl);\n        const nameLookupURL = `${this.blockstackAPIUrl}/v1/names/${fullyQualifiedName}`;\n        return fetchUtil_1.fetchPrivate(nameLookupURL)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Name not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((nameInfo) => {\n            logger_1.Logger.debug(`nameInfo: ${JSON.stringify(nameInfo)}`);\n            // the returned address _should_ be in the correct network ---\n            //  blockstackd gets into trouble because it tries to coerce back to mainnet\n            //  and the regtest transaction generation libraries want to use testnet addresses\n            if (nameInfo.address) {\n                return Object.assign({}, nameInfo, { address: this.coerceAddress(nameInfo.address) });\n            }\n            else {\n                return nameInfo;\n            }\n        });\n    }\n    /**\n     * Get the pricing parameters and creation history of a namespace. This is intended for\n     * use in third-party wallets or in DApps that register names.\n     * @param namespaceID the namespace to query\n     * @return a promise that resolves to the namespace information.\n     */\n    getNamespaceInfo(namespaceID) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespaceID}`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Namespace not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((namespaceInfo) => {\n            // the returned address _should_ be in the correct network ---\n            //  blockstackd gets into trouble because it tries to coerce back to mainnet\n            //  and the regtest transaction generation libraries want to use testnet addresses\n            if (namespaceInfo.address && namespaceInfo.recipient_address) {\n                return Object.assign({}, namespaceInfo, {\n                    address: this.coerceAddress(namespaceInfo.address),\n                    recipient_address: this.coerceAddress(namespaceInfo.recipient_address)\n                });\n            }\n            else {\n                return namespaceInfo;\n            }\n        });\n    }\n    /**\n     * Get a zone file, given its hash.  Throws an exception if the zone file\n     * obtained does not match the hash.\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     *\n     * @param zonefileHash the ripemd160(sha256) hash of the zone file\n     * @return a promise that resolves to the zone file's text\n     */\n    getZonefile(zonefileHash) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefiles/${zonefileHash}`)\n            .then((resp) => {\n            if (resp.status === 200) {\n                return resp.text()\n                    .then((body) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                    const sha2Hash = yield sha2Hash_1.createSha2Hash();\n                    const sha256 = yield sha2Hash.digest(Buffer.from(body));\n                    const h = hashRipemd160_1.hashRipemd160(sha256).toString('hex');\n                    if (h !== zonefileHash) {\n                        throw new Error(`Zone file contents hash to ${h}, not ${zonefileHash}`);\n                    }\n                    return body;\n                }));\n            }\n            else {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n        });\n    }\n    /**\n     * Get the status of an account for a particular token holding.  This includes its total number of\n     * expenditures and credits, lockup times, last `txid`, and so on.\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param address the account\n     * @param tokenType the token type to query\n     * @return a promise that resolves to an object representing the state of the account\n     *   for this token\n     */\n    getAccountStatus(address, tokenType) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/status`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        }).then((accountStatus) => {\n            // coerce all addresses, and convert credit/debit to biginteger\n            const formattedStatus = Object.assign({}, accountStatus, {\n                address: this.coerceAddress(accountStatus.address),\n                debit_value: new BN(String(accountStatus.debit_value)),\n                credit_value: new BN(String(accountStatus.credit_value))\n            });\n            return formattedStatus;\n        });\n    }\n    /**\n     * Get a page of an account's transaction history. This is intended for use in\n     * third-party wallets or in DApps that register names.\n     * @param address the account's address\n     * @param page the page number.  Page 0 is the most recent transactions\n     * @return a promise that resolves to an Array of Objects, where each Object encodes\n     *   states of the account at various block heights (e.g. prior balances, txids, etc)\n     */\n    getAccountHistoryPage(address, page) {\n        const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history?page=${page}`;\n        return fetchUtil_1.fetchPrivate(url)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((historyList) => {\n            if (historyList.error) {\n                throw new Error(`Unable to get account history page: ${historyList.error}`);\n            }\n            // coerse all addresses and convert to bigint\n            return historyList.map((histEntry) => {\n                histEntry.address = this.coerceAddress(histEntry.address);\n                histEntry.debit_value = new BN(String(histEntry.debit_value));\n                histEntry.credit_value = new BN(String(histEntry.credit_value));\n                return histEntry;\n            });\n        });\n    }\n    /**\n     * Get the state(s) of an account at a particular block height.  This includes the state of the\n     * account beginning with this block's transactions, as well as all of the states the account\n     * passed through when this block was processed (if any).\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param address the account's address\n     * @param blockHeight the block to query\n     * @return a promise that resolves to an Array of Objects, where each Object encodes\n     *   states of the account at this block.\n     */\n    getAccountAt(address, blockHeight) {\n        const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history/${blockHeight}`;\n        return fetchUtil_1.fetchPrivate(url)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((historyList) => {\n            if (historyList.error) {\n                throw new Error(`Unable to get historic account state: ${historyList.error}`);\n            }\n            // coerce all addresses \n            return historyList.map((histEntry) => {\n                histEntry.address = this.coerceAddress(histEntry.address);\n                histEntry.debit_value = new BN(String(histEntry.debit_value));\n                histEntry.credit_value = new BN(String(histEntry.credit_value));\n                return histEntry;\n            });\n        });\n    }\n    /**\n     * Get the set of token types that this account owns. This is intended for use\n     * in third-party wallets or in DApps that register names.\n     * @param address the account's address\n     * @return a promise that resolves to an Array of Strings, where each item encodes the\n     *   type of token this account holds (excluding the underlying blockchain's tokens)\n     */\n    getAccountTokens(address) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/tokens`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                throw new Error('Account not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((tokenList) => {\n            if (tokenList.error) {\n                throw new Error(`Unable to get token list: ${tokenList.error}`);\n            }\n            return tokenList;\n        });\n    }\n    /**\n     * Get the number of tokens owned by an account.  If the account does not exist or has no\n     * tokens of this type, then 0 will be returned.\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param address the account's address\n     * @param tokenType the type of token to query.\n     * @return a promise that resolves to a BigInteger that encodes the number of tokens\n     *   held by this account.\n     */\n    getAccountBalance(address, tokenType) {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/balance`)\n            .then((resp) => {\n            if (resp.status === 404) {\n                // talking to an older blockstack core node without the accounts API\n                return Promise.resolve().then(() => new BN('0'));\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then((tokenBalance) => {\n            if (tokenBalance.error) {\n                throw new Error(`Unable to get account balance: ${tokenBalance.error}`);\n            }\n            let balance = '0';\n            if (tokenBalance && tokenBalance.balance) {\n                balance = tokenBalance.balance;\n            }\n            return new BN(balance);\n        });\n    }\n    /**\n     * Performs a POST request to the given URL. This is intended for\n     * use in third-party wallets or in DApps that register names.\n     * @param endpoint  the name of\n     * @param body [description]\n     * @return Returns a `Promise` that resolves to the object requested.\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     * with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     * parameter\n     *\n     * @private\n     */\n    broadcastServiceFetchHelper(endpoint, body) {\n        const requestHeaders = {\n            Accept: 'application/json',\n            'Content-Type': 'application/json'\n        };\n        const options = {\n            method: 'POST',\n            headers: requestHeaders,\n            body: JSON.stringify(body)\n        };\n        const url = `${this.broadcastServiceUrl}/v1/broadcast/${endpoint}`;\n        return fetchUtil_1.fetchPrivate(url, options)\n            .then((response) => {\n            if (response.ok) {\n                return response.json();\n            }\n            else {\n                throw new errors_1.RemoteServiceError(response);\n            }\n        });\n    }\n    /**\n     * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the\n     * transaction until a second transaction has a certain number of confirmations.\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     *\n     * @param transaction the hex-encoded transaction to broadcast\n     * @param transactionToWatch the hex transaction id of the transaction to watch for\n     * the specified number of confirmations before broadcasting the `transaction`\n     * @param confirmations the number of confirmations `transactionToWatch` must have\n     * before broadcasting `transaction`.\n     * @return Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n    broadcastTransaction(transaction, transactionToWatch = null, confirmations = 6) {\n        if (!transaction) {\n            const error = new errors_1.MissingParameterError('transaction');\n            return Promise.reject(error);\n        }\n        if (!confirmations && confirmations !== 0) {\n            const error = new errors_1.MissingParameterError('confirmations');\n            return Promise.reject(error);\n        }\n        if (transactionToWatch === null) {\n            return this.btc.broadcastTransaction(transaction);\n        }\n        else {\n            /*\n             * POST /v1/broadcast/transaction\n             * Request body:\n             * JSON.stringify({\n             *  transaction,\n             *  transactionToWatch,\n             *  confirmations\n             * })\n             */\n            const endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;\n            const requestBody = {\n                transaction,\n                transactionToWatch,\n                confirmations\n            };\n            return this.broadcastServiceFetchHelper(endpoint, requestBody);\n        }\n    }\n    /**\n     * Broadcasts a zone file to the Atlas network via the transaction broadcast service.\n     * This is intended for use in third-party wallets or in DApps that register names.\n     *\n     * @param zoneFile the zone file to be broadcast to the Atlas network\n     * @param transactionToWatch the hex transaction id of the transaction\n     * to watch for confirmation before broadcasting the zone file to the Atlas network\n     * @return Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n    broadcastZoneFile(zoneFile, transactionToWatch = null) {\n        if (!zoneFile) {\n            return Promise.reject(new errors_1.MissingParameterError('zoneFile'));\n        }\n        // TODO: validate zonefile\n        if (transactionToWatch) {\n            // broadcast via transaction broadcast service\n            /*\n             * POST /v1/broadcast/zone-file\n             * Request body:\n             * JSON.stringify({\n             *  zoneFile,\n             *  transactionToWatch\n             * })\n             */\n            const requestBody = {\n                zoneFile,\n                transactionToWatch\n            };\n            const endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;\n            return this.broadcastServiceFetchHelper(endpoint, requestBody);\n        }\n        else {\n            // broadcast via core endpoint\n            // zone file is two words but core's api treats it as one word 'zonefile'\n            const requestBody = { zonefile: zoneFile };\n            return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefile/`, {\n                method: 'POST',\n                body: JSON.stringify(requestBody),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n                .then((resp) => {\n                const json = resp.json();\n                return json\n                    .then((respObj) => {\n                    if (respObj.hasOwnProperty('error')) {\n                        throw new errors_1.RemoteServiceError(resp);\n                    }\n                    return respObj.servers;\n                });\n            });\n        }\n    }\n    /**\n     * Sends the preorder and registration transactions and zone file\n     * for a Blockstack name registration along with the to the transaction\n     *  broadcast service.\n     *\n     * The transaction broadcast:\n     *\n     * * immediately broadcasts the preorder transaction\n     * * broadcasts the register transactions after the preorder transaction\n     * has an appropriate number of confirmations\n     * * broadcasts the zone file to the Atlas network after the register transaction\n     * has an appropriate number of confirmations\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     *\n     * @param preorderTransaction the hex-encoded, signed preorder transaction generated\n     * using the `makePreorder` function\n     * @param registerTransaction the hex-encoded, signed register transaction generated\n     * using the `makeRegister` function\n     * @param zoneFile the zone file to be broadcast to the Atlas network\n     * @return Returns a Promise that resolves to an object with a\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n     *\n     * In the event of an error, it rejects with:\n     * * a `RemoteServiceError` if there is a problem\n     *   with the transaction broadcast service\n     * * `MissingParameterError` if you call the function without a required\n     *   parameter\n     * @private\n     */\n    broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {\n        /*\n           * POST /v1/broadcast/registration\n           * Request body:\n           * JSON.stringify({\n           * preorderTransaction,\n           * registerTransaction,\n           * zoneFile\n           * })\n           */\n        if (!preorderTransaction) {\n            const error = new errors_1.MissingParameterError('preorderTransaction');\n            return Promise.reject(error);\n        }\n        if (!registerTransaction) {\n            const error = new errors_1.MissingParameterError('registerTransaction');\n            return Promise.reject(error);\n        }\n        if (!zoneFile) {\n            const error = new errors_1.MissingParameterError('zoneFile');\n            return Promise.reject(error);\n        }\n        const requestBody = {\n            preorderTransaction,\n            registerTransaction,\n            zoneFile\n        };\n        const endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;\n        return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    }\n    /**\n     * @ignore\n     */\n    getFeeRate() {\n        return fetchUtil_1.fetchPrivate('https://bitcoinfees.earn.com/api/v1/fees/recommended')\n            .then(resp => resp.json())\n            .then(rates => Math.floor(rates.fastestFee));\n    }\n    /**\n     * @ignore\n     */\n    countDustOutputs() {\n        throw new Error('Not implemented.');\n    }\n    /**\n     * @ignore\n     */\n    getUTXOs(address) {\n        return this.getNetworkedUTXOs(address)\n            .then((networkedUTXOs) => {\n            let returnSet = networkedUTXOs.concat();\n            if (this.includeUtxoMap.hasOwnProperty(address)) {\n                returnSet = networkedUTXOs.concat(this.includeUtxoMap[address]);\n            }\n            // aaron: I am *well* aware this is O(n)*O(m) runtime\n            //    however, clients should clear the exclude set periodically\n            const excludeSet = this.excludeUtxoSet;\n            returnSet = returnSet.filter((utxo) => {\n                const inExcludeSet = excludeSet.reduce((inSet, utxoToCheck) => inSet || (utxoToCheck.tx_hash === utxo.tx_hash\n                    && utxoToCheck.tx_output_n === utxo.tx_output_n), false);\n                return !inExcludeSet;\n            });\n            return returnSet;\n        });\n    }\n    /**\n     * This will modify the network's utxo set to include UTXOs\n     *  from the given transaction and exclude UTXOs *spent* in\n     *  that transaction.\n     *\n     * This is intended for use in third-party wallets or in DApps that register names.\n     * @param txHex - the hex-encoded transaction to use\n     * @return no return value, this modifies the UTXO config state\n     * @private\n     * @ignore\n     */\n    modifyUTXOSetFrom(txHex) {\n        const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);\n        const excludeSet = this.excludeUtxoSet.concat();\n        tx.ins.forEach((utxoUsed) => {\n            const reverseHash = Buffer.from(utxoUsed.hash);\n            reverseHash.reverse();\n            excludeSet.push({\n                tx_hash: reverseHash.toString('hex'),\n                tx_output_n: utxoUsed.index\n            });\n        });\n        this.excludeUtxoSet = excludeSet;\n        const txHash = Buffer.from(tx.getHash().reverse()).toString('hex');\n        tx.outs.forEach((utxoCreated, txOutputN) => {\n            const isNullData = function isNullData(script) {\n                try {\n                    bitcoinjs_lib_1.payments.embed({ output: script }, { validate: true });\n                    return true;\n                }\n                catch (_) {\n                    return false;\n                }\n            };\n            if (isNullData(utxoCreated.script)) {\n                return;\n            }\n            const address = bitcoinjs_lib_1.address.fromOutputScript(utxoCreated.script, this.layer1);\n            let includeSet = [];\n            if (this.includeUtxoMap.hasOwnProperty(address)) {\n                includeSet = includeSet.concat(this.includeUtxoMap[address]);\n            }\n            includeSet.push({\n                tx_hash: txHash,\n                confirmations: 0,\n                value: utxoCreated.value,\n                tx_output_n: txOutputN\n            });\n            this.includeUtxoMap[address] = includeSet;\n        });\n    }\n    /**\n     * @ignore\n     */\n    resetUTXOs(address) {\n        delete this.includeUtxoMap[address];\n        this.excludeUtxoSet = [];\n    }\n    /**\n     * @ignore\n     */\n    getConsensusHash() {\n        return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/blockchains/bitcoin/consensus`)\n            .then(resp => resp.json())\n            .then(x => x.consensus_hash);\n    }\n    getTransactionInfo(txHash) {\n        return this.btc.getTransactionInfo(txHash);\n    }\n    /**\n     * @ignore\n     */\n    getBlockHeight() {\n        return this.btc.getBlockHeight();\n    }\n    getNetworkedUTXOs(address) {\n        return this.btc.getNetworkedUTXOs(address);\n    }\n}\nexports.BlockstackNetwork = BlockstackNetwork;\n/**\n * @ignore\n */\nclass LocalRegtest extends BlockstackNetwork {\n    constructor(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n        super(apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.networks.testnet);\n    }\n    getFeeRate() {\n        return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));\n    }\n}\nexports.LocalRegtest = LocalRegtest;\n/**\n * @ignore\n */\nclass BitcoindAPI extends BitcoinNetwork {\n    constructor(bitcoindUrl, bitcoindCredentials) {\n        super();\n        this.bitcoindUrl = bitcoindUrl;\n        this.bitcoindCredentials = bitcoindCredentials;\n        this.importedBefore = {};\n    }\n    broadcastTransaction(transaction) {\n        const jsonRPC = {\n            jsonrpc: '1.0',\n            method: 'sendrawtransaction',\n            params: [transaction]\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPC),\n            headers\n        })\n            .then(resp => resp.json())\n            .then(respObj => respObj.result);\n    }\n    getBlockHeight() {\n        const jsonRPC = {\n            jsonrpc: '1.0',\n            method: 'getblockcount'\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPC),\n            headers\n        })\n            .then(resp => resp.json())\n            .then(respObj => respObj.result);\n    }\n    getTransactionInfo(txHash) {\n        const jsonRPC = {\n            jsonrpc: '1.0',\n            method: 'gettransaction',\n            params: [txHash]\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPC),\n            headers\n        })\n            .then(resp => resp.json())\n            .then(respObj => respObj.result)\n            .then(txInfo => txInfo.blockhash)\n            .then((blockhash) => {\n            const jsonRPCBlock = {\n                jsonrpc: '1.0',\n                method: 'getblockheader',\n                params: [blockhash]\n            };\n            headers.Authorization = `Basic ${authString}`;\n            return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n                method: 'POST',\n                body: JSON.stringify(jsonRPCBlock),\n                headers\n            });\n        })\n            .then(resp => resp.json())\n            .then((respObj) => {\n            if (!respObj || !respObj.result) {\n                // unconfirmed \n                throw new Error('Unconfirmed transaction');\n            }\n            else {\n                return { block_height: respObj.result.height };\n            }\n        });\n    }\n    getNetworkedUTXOs(address) {\n        const jsonRPCImport = {\n            jsonrpc: '1.0',\n            method: 'importaddress',\n            params: [address]\n        };\n        const jsonRPCUnspent = {\n            jsonrpc: '1.0',\n            method: 'listunspent',\n            params: [0, 9999999, [address]]\n        };\n        const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)\n            .toString('base64');\n        const headers = { Authorization: `Basic ${authString}` };\n        const importPromise = (this.importedBefore[address])\n            ? Promise.resolve()\n            : fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n                method: 'POST',\n                body: JSON.stringify(jsonRPCImport),\n                headers\n            })\n                .then(() => { this.importedBefore[address] = true; });\n        return importPromise\n            .then(() => fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n            method: 'POST',\n            body: JSON.stringify(jsonRPCUnspent),\n            headers\n        }))\n            .then(resp => resp.json())\n            .then(x => x.result)\n            .then(utxos => utxos.map((x) => ({\n            value: Math.round(x.amount * SATOSHIS_PER_BTC),\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n        })));\n    }\n}\nexports.BitcoindAPI = BitcoindAPI;\n/**\n * @ignore\n */\nclass InsightClient extends BitcoinNetwork {\n    constructor(insightUrl = 'https://utxo.technofractal.com/') {\n        super();\n        this.apiUrl = insightUrl;\n    }\n    broadcastTransaction(transaction) {\n        const jsonData = { rawtx: transaction };\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/send`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(jsonData)\n        })\n            .then(resp => resp.json());\n    }\n    getBlockHeight() {\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/status`)\n            .then(resp => resp.json())\n            .then(status => status.blocks);\n    }\n    getTransactionInfo(txHash) {\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/${txHash}`)\n            .then(resp => resp.json())\n            .then((transactionInfo) => {\n            if (transactionInfo.error) {\n                throw new Error(`Error finding transaction: ${transactionInfo.error}`);\n            }\n            return fetchUtil_1.fetchPrivate(`${this.apiUrl}/block/${transactionInfo.blockHash}`);\n        })\n            .then(resp => resp.json())\n            .then(blockInfo => ({ block_height: blockInfo.height }));\n    }\n    getNetworkedUTXOs(address) {\n        return fetchUtil_1.fetchPrivate(`${this.apiUrl}/addr/${address}/utxo`)\n            .then(resp => resp.json())\n            .then(utxos => utxos.map((x) => ({\n            value: x.satoshis,\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n        })));\n    }\n}\nexports.InsightClient = InsightClient;\n/**\n * @ignore\n */\nclass BlockchainInfoApi extends BitcoinNetwork {\n    constructor(blockchainInfoUrl = 'https://blockchain.info') {\n        super();\n        this.utxoProviderUrl = blockchainInfoUrl;\n    }\n    getBlockHeight() {\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/latestblock?cors=true`)\n            .then(resp => resp.json())\n            .then(blockObj => blockObj.height);\n    }\n    getNetworkedUTXOs(address) {\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/unspent?format=json&active=${address}&cors=true`)\n            .then((resp) => {\n            if (resp.status === 500) {\n                logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');\n                return {\n                    unspent_outputs: []\n                };\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then(utxoJSON => utxoJSON.unspent_outputs)\n            .then(utxoList => utxoList.map((utxo) => {\n            const utxoOut = {\n                value: utxo.value,\n                tx_output_n: utxo.tx_output_n,\n                confirmations: utxo.confirmations,\n                tx_hash: utxo.tx_hash_big_endian\n            };\n            return utxoOut;\n        }));\n    }\n    getTransactionInfo(txHash) {\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/rawtx/${txHash}?cors=true`)\n            .then((resp) => {\n            if (resp.status === 200) {\n                return resp.json();\n            }\n            else {\n                throw new Error(`Could not lookup transaction info for '${txHash}'. Server error.`);\n            }\n        })\n            .then(respObj => ({ block_height: respObj.block_height }));\n    }\n    broadcastTransaction(transaction) {\n        const form = new FormData();\n        form.append('tx', transaction);\n        return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/pushtx?cors=true`, {\n            method: 'POST',\n            body: form\n        })\n            .then((resp) => {\n            const text = resp.text();\n            return text\n                .then((respText) => {\n                if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {\n                    const txHash = Buffer.from(bitcoinjs_lib_1.Transaction.fromHex(transaction)\n                        .getHash()\n                        .reverse()).toString('hex'); // big_endian\n                    return txHash;\n                }\n                else {\n                    throw new errors_1.RemoteServiceError(resp, `Broadcast transaction failed with message: ${respText}`);\n                }\n            });\n        });\n    }\n}\nexports.BlockchainInfoApi = BlockchainInfoApi;\n/**\n* @ignore\n*/\nconst LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', { username: 'blockstack', password: 'blockstacksystem' }));\n/**\n* Instance of [[BlockstackNetwork]] set to the default endpoints.\n*/\nexports.MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());\n/**\n * Get WHOIS-like information for a name, including the address that owns it,\n * the block at which it expires, and the zone file anchored to it (if available).\n * This is intended for use in third-party wallets or in DApps that register names.\n * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n * @return a promise that resolves to the WHOIS-like information\n */\nfunction getNameInfo(fullyQualifiedName) {\n    return config_1.config.network.getNameInfo(fullyQualifiedName);\n}\nexports.getNameInfo = getNameInfo;\n/**\n* @ignore\n*/\nexports.network = {\n    BlockstackNetwork,\n    LocalRegtest,\n    BlockchainInfoApi,\n    BitcoindAPI,\n    InsightClient,\n    defaults: { LOCAL_REGTEST, MAINNET_DEFAULT: exports.MAINNET_DEFAULT }\n};\n//# sourceMappingURL=network.js.map"]},"metadata":{},"sourceType":"script"}