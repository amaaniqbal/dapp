{"ast":null,"code":"\"use strict\";\n/**\n * This logic is in a separate file with no dependencies so that it can be\n * loaded and executed as soon as possible to fulfill the purpose of the protocol\n * detection technique. The effectiveness of this is obviously subject to how web\n * apps bundle/consume the blockstack.js lib.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst GLOBAL_DETECTION_CACHE_KEY = '_blockstackDidCheckEchoReply';\nconst ECHO_REPLY_PARAM = 'echoReply';\nconst AUTH_CONTINUATION_PARAM = 'authContinuation';\n\nfunction getQueryStringParams(query) {\n  if (!query) {\n    return {};\n  } // Trim a starting `?` character if exists\n\n\n  const trimmed = /^[?#]/.test(query) ? query.slice(1) : query;\n  return trimmed.split('&').reduce((params, param) => {\n    const [key, value] = param.split('=');\n    params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\n    return params;\n  }, {});\n}\n/**\n * Checks if the current window location URL contains an 'echoReply' parameter\n * which indicates that this page was only opened to signal back to the originating\n * tab that the protocol handler is installed.\n * If found, then localStorage events are used to notify the other tab,\n * and this page is redirected back to the Blockstack authenticator URL.\n * This function caches its result and will not trigger multiple redirects when\n * invoked multiple times.\n * @returns True if detected and the page will be automatically redirected.\n * @hidden\n */\n\n\nfunction protocolEchoReplyDetection() {\n  // Check that the `window` APIs exist\n  let globalScope;\n\n  if (typeof self !== 'undefined') {\n    globalScope = self;\n  } else if (typeof window !== 'undefined') {\n    globalScope = window;\n  } else {\n    // Exit detection function - we are not running in a browser environment.\n    return false;\n  }\n\n  if (!globalScope.location || !globalScope.localStorage) {\n    // Exit detection function - we are not running in a browser environment.\n    return false;\n  } // Avoid performing the check twice and triggered multiple redirect timers.\n\n\n  const existingDetection = globalScope[GLOBAL_DETECTION_CACHE_KEY];\n\n  if (typeof existingDetection === 'boolean') {\n    return existingDetection;\n  }\n\n  const searchParams = getQueryStringParams(globalScope.location.search);\n  const echoReplyParam = searchParams[ECHO_REPLY_PARAM];\n\n  if (echoReplyParam) {\n    globalScope[GLOBAL_DETECTION_CACHE_KEY] = true; // Use localStorage to notify originated tab that protocol handler is available and working.\n\n    const echoReplyKey = `echo-reply-${echoReplyParam}`; // Set the echo-reply result in localStorage for the other window to see.\n\n    globalScope.localStorage.setItem(echoReplyKey, 'success'); // Redirect back to the localhost auth url, as opposed to another protocol launch.\n    // This will re-use the same tab rather than creating another useless one.\n\n    globalScope.setTimeout(() => {\n      const authContinuationParam = searchParams[AUTH_CONTINUATION_PARAM];\n      globalScope.location.href = authContinuationParam;\n    }, 10);\n    return true;\n  }\n\n  return false;\n}\n\nexports.protocolEchoReplyDetection = protocolEchoReplyDetection;","map":{"version":3,"sources":["../../src/auth/protocolEchoDetection.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;AAOA,MAAM,0BAA0B,GAAG,8BAAnC;AACA,MAAM,gBAAgB,GAAG,WAAzB;AACA,MAAM,uBAAuB,GAAG,kBAAhC;;AAGA,SAAS,oBAAT,CAA8B,KAA9B,EAA2C;AACzC,MAAI,CAAC,KAAL,EAAY;AACV,WAAO,EAAP;AACD,GAHwC,CAIzC;;;AACA,QAAM,OAAO,GAAG,QAAQ,IAAR,CAAa,KAAb,IAAsB,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAtB,GAAuC,KAAvD;AACA,SAAO,OAAO,CACX,KADI,CACE,GADF,EAEJ,MAFI,CAEG,CAAC,MAAD,EAAS,KAAT,KAAkB;AACxB,UAAM,CAAC,GAAD,EAAM,KAAN,IAAe,KAAK,CAAC,KAAN,CAAY,GAAZ,CAArB;AACA,IAAA,MAAM,CAAC,GAAD,CAAN,GAAc,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,EAAqB,GAArB,CAAD,CAArB,GAAmD,EAAtE;AACA,WAAO,MAAP;AACD,GANI,EAMF,EANE,CAAP;AAOD;AAGD;;;;;;;;;;;;;AAWA,SAAgB,0BAAhB,GAA0C;AACxC;AACA,MAAI,WAAJ;;AACA,MAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;AAC/B,IAAA,WAAW,GAAG,IAAd;AACD,GAFD,MAEO,IAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACxC,IAAA,WAAW,GAAG,MAAd;AACD,GAFM,MAEA;AACL;AACA,WAAO,KAAP;AACD;;AAED,MAAI,CAAC,WAAW,CAAC,QAAb,IAAyB,CAAC,WAAW,CAAC,YAA1C,EAAwD;AACtD;AACA,WAAO,KAAP;AACD,GAfuC,CAiBxC;;;AACA,QAAM,iBAAiB,GAAI,WAAmB,CAAC,0BAAD,CAA9C;;AACA,MAAI,OAAO,iBAAP,KAA6B,SAAjC,EAA4C;AAC1C,WAAO,iBAAP;AACD;;AAED,QAAM,YAAY,GAAG,oBAAoB,CAAC,WAAW,CAAC,QAAZ,CAAqB,MAAtB,CAAzC;AACA,QAAM,cAAc,GAAG,YAAY,CAAC,gBAAD,CAAnC;;AACA,MAAI,cAAJ,EAAoB;AACjB,IAAA,WAAmB,CAAC,0BAAD,CAAnB,GAAkD,IAAlD,CADiB,CAGlB;;AACA,UAAM,YAAY,GAAG,cAAc,cAAc,EAAjD,CAJkB,CAMlB;;AACA,IAAA,WAAW,CAAC,YAAZ,CAAyB,OAAzB,CAAiC,YAAjC,EAA+C,SAA/C,EAPkB,CASlB;AACA;;AACA,IAAA,WAAW,CAAC,UAAZ,CAAuB,MAAK;AAC1B,YAAM,qBAAqB,GAAG,YAAY,CAAC,uBAAD,CAA1C;AACA,MAAA,WAAW,CAAC,QAAZ,CAAqB,IAArB,GAA4B,qBAA5B;AACD,KAHD,EAGG,EAHH;AAKA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;;AA7CD,OAAA,CAAA,0BAAA,GAAA,0BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * This logic is in a separate file with no dependencies so that it can be\n * loaded and executed as soon as possible to fulfill the purpose of the protocol\n * detection technique. The effectiveness of this is obviously subject to how web\n * apps bundle/consume the blockstack.js lib.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GLOBAL_DETECTION_CACHE_KEY = '_blockstackDidCheckEchoReply';\nconst ECHO_REPLY_PARAM = 'echoReply';\nconst AUTH_CONTINUATION_PARAM = 'authContinuation';\nfunction getQueryStringParams(query) {\n    if (!query) {\n        return {};\n    }\n    // Trim a starting `?` character if exists\n    const trimmed = /^[?#]/.test(query) ? query.slice(1) : query;\n    return trimmed\n        .split('&')\n        .reduce((params, param) => {\n        const [key, value] = param.split('=');\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\n        return params;\n    }, {});\n}\n/**\n * Checks if the current window location URL contains an 'echoReply' parameter\n * which indicates that this page was only opened to signal back to the originating\n * tab that the protocol handler is installed.\n * If found, then localStorage events are used to notify the other tab,\n * and this page is redirected back to the Blockstack authenticator URL.\n * This function caches its result and will not trigger multiple redirects when\n * invoked multiple times.\n * @returns True if detected and the page will be automatically redirected.\n * @hidden\n */\nfunction protocolEchoReplyDetection() {\n    // Check that the `window` APIs exist\n    let globalScope;\n    if (typeof self !== 'undefined') {\n        globalScope = self;\n    }\n    else if (typeof window !== 'undefined') {\n        globalScope = window;\n    }\n    else {\n        // Exit detection function - we are not running in a browser environment.\n        return false;\n    }\n    if (!globalScope.location || !globalScope.localStorage) {\n        // Exit detection function - we are not running in a browser environment.\n        return false;\n    }\n    // Avoid performing the check twice and triggered multiple redirect timers.\n    const existingDetection = globalScope[GLOBAL_DETECTION_CACHE_KEY];\n    if (typeof existingDetection === 'boolean') {\n        return existingDetection;\n    }\n    const searchParams = getQueryStringParams(globalScope.location.search);\n    const echoReplyParam = searchParams[ECHO_REPLY_PARAM];\n    if (echoReplyParam) {\n        globalScope[GLOBAL_DETECTION_CACHE_KEY] = true;\n        // Use localStorage to notify originated tab that protocol handler is available and working.\n        const echoReplyKey = `echo-reply-${echoReplyParam}`;\n        // Set the echo-reply result in localStorage for the other window to see.\n        globalScope.localStorage.setItem(echoReplyKey, 'success');\n        // Redirect back to the localhost auth url, as opposed to another protocol launch.\n        // This will re-use the same tab rather than creating another useless one.\n        globalScope.setTimeout(() => {\n            const authContinuationParam = searchParams[AUTH_CONTINUATION_PARAM];\n            globalScope.location.href = authContinuationParam;\n        }, 10);\n        return true;\n    }\n    return false;\n}\nexports.protocolEchoReplyDetection = protocolEchoReplyDetection;\n//# sourceMappingURL=protocolEchoDetection.js.map"]},"metadata":{},"sourceType":"script"}