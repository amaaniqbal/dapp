{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst crypto = require(\"crypto\");\n\nconst keys_1 = require(\"../keys\");\n\nconst ecurve = new elliptic_1.ec('secp256k1');\n/**\n* @ignore\n*/\n\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(plaintext), cipher.final()]);\n}\n/**\n* @ignore\n*/\n\n\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n  const cipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(ciphertext), cipher.final()]);\n}\n/**\n* @ignore\n*/\n\n\nfunction hmacSha256(key, content) {\n  return crypto.createHmac('sha256', key).update(content).digest();\n}\n/**\n* @ignore\n*/\n\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  let res = 0;\n\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n/**\n* @ignore\n*/\n\n\nfunction sharedSecretToKeys(sharedSecret) {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = crypto.createHash('sha512').update(sharedSecret).digest();\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n/**\n* @ignore\n*/\n\n\nfunction getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString('hex');\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\nexports.getHexFromBN = getHexFromBN;\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param {String} publicKey - secp256k1 public key hex string\n * @param {String | Buffer} content - content to encrypt\n * @return {Object} Object containing (hex encoded):\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeral public key\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n *\n * @private\n * @ignore\n */\n\nfunction encryptECIES(publicKey, content) {\n  const isString = typeof content === 'string'; // always copy to buffer\n\n  const plainText = content instanceof Buffer ? Buffer.from(content) : Buffer.from(content);\n  const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  const ephemeralSK = ecurve.genKeyPair();\n  const ephemeralPK = ephemeralSK.getPublic();\n  const sharedSecret = ephemeralSK.derive(ecPK);\n  const sharedSecretHex = getHexFromBN(sharedSecret);\n  const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecretHex, 'hex'));\n  const initializationVector = crypto.randomBytes(16);\n  const cipherText = aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, plainText);\n  const macData = Buffer.concat([initializationVector, Buffer.from(ephemeralPK.encode('array', true)), cipherText]);\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\n  return {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.encode('hex', true),\n    cipherText: cipherText.toString('hex'),\n    mac: mac.toString('hex'),\n    wasString: isString\n  };\n}\n\nexports.encryptECIES = encryptECIES;\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {Error} if unable to decrypt\n * @private\n * @ignore\n */\n\nfunction decryptECIES(privateKey, cipherObject) {\n  const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  const ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  const sharedSecret = ecSK.derive(ephemeralPK);\n  const sharedSecretBuffer = Buffer.from(getHexFromBN(sharedSecret), 'hex');\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n  const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n  const cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  const macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encode('array', true)), cipherTextBuffer]);\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new Error('Decryption failed: failure in MAC check');\n  }\n\n  const plainText = aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n\nexports.decryptECIES = decryptECIES;\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\n\nfunction signECDSA(privateKey, content) {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  const contentHash = crypto.createHash('sha256').update(contentBuffer).digest();\n  const signature = ecPrivate.sign(contentHash);\n  const signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey\n  };\n}\n\nexports.signECDSA = signECDSA;\n/**\n* @ignore\n*/\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\n\n\nfunction verifyECDSA(content, publicKey, signature) {\n  const contentBuffer = getBuffer(content);\n  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  const contentHash = crypto.createHash('sha256').update(contentBuffer).digest();\n  return ecPublic.verify(contentHash, signature);\n}\n\nexports.verifyECDSA = verifyECDSA;","map":{"version":3,"sources":["../../src/encryption/ec.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\nconst crypto = require(\"crypto\");\nconst keys_1 = require(\"../keys\");\nconst ecurve = new elliptic_1.ec('secp256k1');\n/**\n* @ignore\n*/\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n    return Buffer.concat([cipher.update(plaintext), cipher.final()]);\n}\n/**\n* @ignore\n*/\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n    const cipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n    return Buffer.concat([cipher.update(ciphertext), cipher.final()]);\n}\n/**\n* @ignore\n*/\nfunction hmacSha256(key, content) {\n    return crypto.createHmac('sha256', key).update(content).digest();\n}\n/**\n* @ignore\n*/\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for (let i = 0; i < b1.length; i++) {\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\n/**\n* @ignore\n*/\nfunction sharedSecretToKeys(sharedSecret) {\n    // generate mac and encryption key from shared secret\n    const hashedSecret = crypto.createHash('sha512').update(sharedSecret).digest();\n    return {\n        encryptionKey: hashedSecret.slice(0, 32),\n        hmacKey: hashedSecret.slice(32)\n    };\n}\n/**\n* @ignore\n*/\nfunction getHexFromBN(bnInput) {\n    const hexOut = bnInput.toString('hex');\n    if (hexOut.length === 64) {\n        return hexOut;\n    }\n    else if (hexOut.length < 64) {\n        // pad with leading zeros\n        // the padStart function would require node 9\n        const padding = '0'.repeat(64 - hexOut.length);\n        return `${padding}${hexOut}`;\n    }\n    else {\n        throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n    }\n}\nexports.getHexFromBN = getHexFromBN;\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param {String} publicKey - secp256k1 public key hex string\n * @param {String | Buffer} content - content to encrypt\n * @return {Object} Object containing (hex encoded):\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeral public key\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n *\n * @private\n * @ignore\n */\nfunction encryptECIES(publicKey, content) {\n    const isString = (typeof (content) === 'string');\n    // always copy to buffer\n    const plainText = content instanceof Buffer ? Buffer.from(content) : Buffer.from(content);\n    const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n    const ephemeralSK = ecurve.genKeyPair();\n    const ephemeralPK = ephemeralSK.getPublic();\n    const sharedSecret = ephemeralSK.derive(ecPK);\n    const sharedSecretHex = getHexFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecretHex, 'hex'));\n    const initializationVector = crypto.randomBytes(16);\n    const cipherText = aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, plainText);\n    const macData = Buffer.concat([initializationVector,\n        Buffer.from(ephemeralPK.encode('array', true)),\n        cipherText]);\n    const mac = hmacSha256(sharedKeys.hmacKey, macData);\n    return {\n        iv: initializationVector.toString('hex'),\n        ephemeralPK: ephemeralPK.encode('hex', true),\n        cipherText: cipherText.toString('hex'),\n        mac: mac.toString('hex'),\n        wasString: isString\n    };\n}\nexports.encryptECIES = encryptECIES;\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {Error} if unable to decrypt\n * @private\n * @ignore\n */\nfunction decryptECIES(privateKey, cipherObject) {\n    const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n    const ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n    const sharedSecret = ecSK.derive(ephemeralPK);\n    const sharedSecretBuffer = Buffer.from(getHexFromBN(sharedSecret), 'hex');\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n    const cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n    const macData = Buffer.concat([ivBuffer,\n        Buffer.from(ephemeralPK.encode('array', true)),\n        cipherTextBuffer]);\n    const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n    const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n    if (!equalConstTime(expectedMac, actualMac)) {\n        throw new Error('Decryption failed: failure in MAC check');\n    }\n    const plainText = aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n    if (cipherObject.wasString) {\n        return plainText.toString();\n    }\n    else {\n        return plainText;\n    }\n}\nexports.decryptECIES = decryptECIES;\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\nfunction signECDSA(privateKey, content) {\n    const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n    const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n    const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n    const contentHash = crypto.createHash('sha256').update(contentBuffer).digest();\n    const signature = ecPrivate.sign(contentHash);\n    const signatureString = signature.toDER('hex');\n    return {\n        signature: signatureString,\n        publicKey\n    };\n}\nexports.signECDSA = signECDSA;\n/**\n* @ignore\n*/\nfunction getBuffer(content) {\n    if (content instanceof Buffer)\n        return content;\n    else if (content instanceof ArrayBuffer)\n        return Buffer.from(content);\n    else\n        return Buffer.from(content);\n}\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\nfunction verifyECDSA(content, publicKey, signature) {\n    const contentBuffer = getBuffer(content);\n    const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n    const contentHash = crypto.createHash('sha256').update(contentBuffer).digest();\n    return ecPublic.verify(contentHash, signature);\n}\nexports.verifyECDSA = verifyECDSA;\n//# sourceMappingURL=ec.js.map"]},"metadata":{},"sourceType":"script"}