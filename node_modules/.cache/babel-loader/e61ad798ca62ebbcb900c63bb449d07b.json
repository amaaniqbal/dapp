{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst hub_1 = require(\"./hub\");\n\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL; // export { type GaiaHubConfig } from './hub'\n\nconst ec_1 = require(\"../encryption/ec\");\n\nconst keys_1 = require(\"../keys\");\n\nconst profileLookup_1 = require(\"../profiles/profileLookup\");\n\nconst errors_1 = require(\"../errors\");\n\nconst logger_1 = require(\"../logger\");\n\nconst userSession_1 = require(\"../auth/userSession\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\n\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n    let bucketUrl = null;\n\n    if (profile.hasOwnProperty('apps')) {\n      if (profile.apps.hasOwnProperty(appOrigin)) {\n        const url = profile.apps[appOrigin];\n        const bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n        bucketUrl = `${bucket}${path}`;\n      }\n    }\n\n    return bucketUrl;\n  });\n}\n\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\n\nfunction encryptContent(content, options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.publicKey) {\n    const privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  }\n\n  const cipherObject = ec_1.encryptECIES(opts.publicKey, content);\n  return JSON.stringify(cipherObject);\n}\n\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\n\nfunction decryptContent(content, options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return ec_1.decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\n\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const opts = normalizeOptions({\n      app,\n      username\n    }, caller);\n    let fileUrl;\n\n    if (username) {\n      fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, zoneFileLookupURL);\n    } else {\n      if (!caller) {\n        caller = new userSession_1.UserSession();\n      }\n\n      const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n      fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);\n    }\n\n    const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n\n    if (!matches) {\n      throw new Error('Failed to parse gaia address');\n    }\n\n    return matches[matches.length - 1];\n  });\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\n\n\nfunction normalizeOptions(options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (opts.username) {\n    if (!opts.app) {\n      const appConfig = (caller || new userSession_1.UserSession()).appConfig;\n\n      if (!appConfig) {\n        throw new errors_1.InvalidStateError('Missing AppConfig');\n      }\n\n      opts.app = appConfig.appDomain;\n    }\n  }\n\n  return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\n\n\nfunction getFileUrl(path, options, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const opts = normalizeOptions(options, caller);\n    let readUrl;\n\n    if (opts.username) {\n      readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n    } else {\n      const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n      readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);\n    }\n\n    if (!readUrl) {\n      throw new Error('Missing readURL');\n    } else {\n      return readUrl;\n    }\n  });\n}\n\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\n\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n  return Promise.resolve().then(() => {\n    const opts = {\n      app,\n      username,\n      zoneFileLookupURL\n    };\n    return getFileUrl(path, opts, caller);\n  }).then(readUrl => fetchUtil_1.fetchPrivate(readUrl)).then(response => {\n    if (response.status !== 200) {\n      if (response.status === 404) {\n        logger_1.Logger.debug(`getFile ${path} returned 404, returning null`);\n        return null;\n      } else {\n        throw new Error(`getFile ${path} failed with HTTP status ${response.status}`);\n      }\n    }\n\n    const contentType = response.headers.get('Content-Type');\n\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\n\n\nfunction getFileSignedUnencrypted(path, opt, caller) {\n  // future optimization note:\n  //    in the case of _multi-player_ reads, this does a lot of excess\n  //    profile lookups to figure out where to read files\n  //    do browsers cache all these requests if Content-Cache is set?\n  return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller), getFileContents(`${path}${SIGNATURE_FILE_SUFFIX}`, opt.app, opt.username, opt.zoneFileLookupURL, true, caller), getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)]).then(([fileContents, signatureContents, gaiaAddress]) => {\n    if (!fileContents) {\n      return fileContents;\n    }\n\n    if (!gaiaAddress) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + `${path}`);\n    }\n\n    if (!signatureContents || typeof signatureContents !== 'string') {\n      throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: ' + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n    }\n\n    let signature;\n    let publicKey;\n\n    try {\n      const sigObject = JSON.parse(signatureContents);\n      signature = sigObject.signature;\n      publicKey = sigObject.publicKey;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse signature content JSON ' + `(path: ${path}${SIGNATURE_FILE_SUFFIX})` + ' The content may be corrupted.');\n      } else {\n        throw err;\n      }\n    }\n\n    const signerAddress = keys_1.publicKeyToAddress(publicKey);\n\n    if (gaiaAddress !== signerAddress) {\n      throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${gaiaAddress})`);\n    } else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: ' + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);\n    } else {\n      return fileContents;\n    }\n  });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\n\n\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n  const appPrivateKey = caller.loadUserData().appPrivateKey;\n  const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n  let addressPromise;\n\n  if (username) {\n    addressPromise = getGaiaAddress(app, username, zoneFileLookupURL, caller);\n  } else {\n    const address = keys_1.publicKeyToAddress(appPublicKey);\n    addressPromise = Promise.resolve(address);\n  }\n\n  return addressPromise.then(address => {\n    if (!address) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + `${path}`);\n    }\n\n    let sigObject;\n\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n\n    const signature = sigObject.signature;\n    const signerPublicKey = sigObject.publicKey;\n    const cipherText = sigObject.cipherText;\n    const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:' + ` ${path}`);\n    } else if (signerAddress !== address) {\n      throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${address})`);\n    } else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:' + ` ${path}`);\n    } else {\n      return caller.decryptContent(cipherText);\n    }\n  });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\n\n\nfunction getFile(path, options, caller) {\n  const defaults = {\n    decrypt: true,\n    verify: false,\n    username: null,\n    app: utils_1.getGlobalObject('location', {\n      returnEmptyObject: true\n    }).origin,\n    zoneFileLookupURL: null\n  };\n  const opt = Object.assign({}, defaults, options);\n\n  if (!caller) {\n    caller = new userSession_1.UserSession();\n  } // in the case of signature verification, but no\n  //  encryption expected, need to fetch _two_ files.\n\n\n  if (opt.verify && !opt.decrypt) {\n    return getFileSignedUnencrypted(path, opt, caller);\n  }\n\n  return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller).then(storedContents => {\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return caller.decryptContent(storedContents);\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n\nexports.getFile = getFile;\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\n\nfunction putFile(path, content, options, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const defaults = {\n      encrypt: true,\n      sign: false,\n      contentType: ''\n    };\n    const opt = Object.assign({}, defaults, options);\n    let {\n      contentType\n    } = opt;\n\n    if (!contentType) {\n      contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n    }\n\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    } // First, let's figure out if we need to get public/private keys,\n    //  or if they were passed in\n\n\n    let privateKey = '';\n    let publicKey = '';\n\n    if (opt.sign) {\n      if (typeof opt.sign === 'string') {\n        privateKey = opt.sign;\n      } else {\n        privateKey = caller.loadUserData().appPrivateKey;\n      }\n    }\n\n    if (opt.encrypt) {\n      if (typeof opt.encrypt === 'string') {\n        publicKey = opt.encrypt;\n      } else {\n        if (!privateKey) {\n          privateKey = caller.loadUserData().appPrivateKey;\n        }\n\n        publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n      }\n    } // In the case of signing, but *not* encrypting,\n    //   we perform two uploads. So the control-flow\n    //   here will return there.\n\n\n    if (!opt.encrypt && opt.sign) {\n      const signatureObject = ec_1.signECDSA(privateKey, content);\n      const signatureContent = JSON.stringify(signatureObject);\n      const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n\n      try {\n        const fileUrls = yield Promise.all([hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType), hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, gaiaHubConfig, 'application/json')]);\n        return fileUrls[0];\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        const fileUrls = yield Promise.all([hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType), hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, freshHubConfig, 'application/json')]);\n        return fileUrls[0];\n      }\n    } // In all other cases, we only need one upload.\n\n\n    if (opt.encrypt && !opt.sign) {\n      content = encryptContent(content, {\n        publicKey\n      });\n      contentType = 'application/json';\n    } else if (opt.encrypt && opt.sign) {\n      const cipherText = encryptContent(content, {\n        publicKey\n      });\n      const signatureObject = ec_1.signECDSA(privateKey, cipherText);\n      const signedCipherObject = {\n        signature: signatureObject.signature,\n        publicKey: signatureObject.publicKey,\n        cipherText\n      };\n      content = JSON.stringify(signedCipherObject);\n      contentType = 'application/json';\n    }\n\n    const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n\n    try {\n      return yield hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType);\n    } catch (error) {\n      const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n      const file = yield hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType);\n      return file;\n    }\n  });\n}\n\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\n\nfunction deleteFile(path, options, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    }\n\n    const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n    const opts = Object.assign({}, options);\n\n    if (opts.wasSigned) {\n      // If signed, delete both the content file and the .sig file\n      try {\n        yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n        yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n        yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n      }\n    } else {\n      try {\n        yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n      }\n    }\n  });\n}\n\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\n\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\n\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\n\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (callCount > 65536) {\n      // this is ridiculously huge, and probably indicates\n      // a faulty Gaia hub anyway (e.g. on that serves endless data)\n      throw new Error('Too many entries to list');\n    }\n\n    hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());\n    let response;\n\n    try {\n      const pageRequest = JSON.stringify({\n        page\n      });\n      const fetchOptions = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': `${pageRequest.length}`,\n          Authorization: `bearer ${hubConfig.token}`\n        },\n        body: pageRequest\n      };\n      response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);\n\n      if (!response.ok) {\n        throw new Error(`listFiles failed with HTTP status ${response.status}`);\n      }\n    } catch (error) {\n      // If error occurs on the first call, perform a gaia re-connection and retry.\n      // Same logic as other gaia requests (putFile, getFile, etc).\n      if (callCount === 0) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);\n      }\n\n      throw error;\n    }\n\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    const entries = responseJSON.entries;\n    const nextPage = responseJSON.page;\n\n    if (entries === null || entries === undefined) {\n      // indicates a misbehaving Gaia hub or a misbehaving driver\n      // (i.e. the data is malformed)\n      throw new Error('Bad listFiles response: no entries');\n    }\n\n    for (let i = 0; i < entries.length; i++) {\n      const rc = callback(entries[i]);\n\n      if (!rc) {\n        // callback indicates that we're done\n        return fileCount + i;\n      }\n    }\n\n    if (nextPage && entries.length > 0) {\n      // keep going -- have more entries\n      return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n    } else {\n      // no more entries -- end of data\n      return fileCount + entries.length;\n    }\n  });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\n\n\nfunction listFiles(callback, caller) {\n  caller = caller || new userSession_1.UserSession();\n  return listFilesLoop(caller, null, null, 0, 0, callback);\n}\n\nexports.listFiles = listFiles;","map":{"version":3,"sources":["../../src/storage/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hub_1 = require(\"./hub\");\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL;\n// export { type GaiaHubConfig } from './hub'\nconst ec_1 = require(\"../encryption/ec\");\nconst keys_1 = require(\"../keys\");\nconst profileLookup_1 = require(\"../profiles/profileLookup\");\nconst errors_1 = require(\"../errors\");\nconst logger_1 = require(\"../logger\");\nconst userSession_1 = require(\"../auth/userSession\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n        let bucketUrl = null;\n        if (profile.hasOwnProperty('apps')) {\n            if (profile.apps.hasOwnProperty(appOrigin)) {\n                const url = profile.apps[appOrigin];\n                const bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n                bucketUrl = `${bucket}${path}`;\n            }\n        }\n        return bucketUrl;\n    });\n}\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nfunction encryptContent(content, options, caller) {\n    const opts = Object.assign({}, options);\n    if (!opts.publicKey) {\n        const privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n        opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n    }\n    const cipherObject = ec_1.encryptECIES(opts.publicKey, content);\n    return JSON.stringify(cipherObject);\n}\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nfunction decryptContent(content, options, caller) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n        opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    }\n    try {\n        const cipherObject = JSON.parse(content);\n        return ec_1.decryptECIES(opts.privateKey, cipherObject);\n    }\n    catch (err) {\n        if (err instanceof SyntaxError) {\n            throw new Error('Failed to parse encrypted content JSON. The content may not '\n                + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n        }\n        else {\n            throw err;\n        }\n    }\n}\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const opts = normalizeOptions({ app, username }, caller);\n        let fileUrl;\n        if (username) {\n            fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, zoneFileLookupURL);\n        }\n        else {\n            if (!caller) {\n                caller = new userSession_1.UserSession();\n            }\n            const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n            fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);\n        }\n        const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n        if (!matches) {\n            throw new Error('Failed to parse gaia address');\n        }\n        return matches[matches.length - 1];\n    });\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\nfunction normalizeOptions(options, caller) {\n    const opts = Object.assign({}, options);\n    if (opts.username) {\n        if (!opts.app) {\n            const appConfig = (caller || new userSession_1.UserSession()).appConfig;\n            if (!appConfig) {\n                throw new errors_1.InvalidStateError('Missing AppConfig');\n            }\n            opts.app = appConfig.appDomain;\n        }\n    }\n    return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\nfunction getFileUrl(path, options, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const opts = normalizeOptions(options, caller);\n        let readUrl;\n        if (opts.username) {\n            readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n        }\n        else {\n            const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n            readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);\n        }\n        if (!readUrl) {\n            throw new Error('Missing readURL');\n        }\n        else {\n            return readUrl;\n        }\n    });\n}\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n    return Promise.resolve()\n        .then(() => {\n        const opts = { app, username, zoneFileLookupURL };\n        return getFileUrl(path, opts, caller);\n    })\n        .then(readUrl => fetchUtil_1.fetchPrivate(readUrl))\n        .then((response) => {\n        if (response.status !== 200) {\n            if (response.status === 404) {\n                logger_1.Logger.debug(`getFile ${path} returned 404, returning null`);\n                return null;\n            }\n            else {\n                throw new Error(`getFile ${path} failed with HTTP status ${response.status}`);\n            }\n        }\n        const contentType = response.headers.get('Content-Type');\n        if (forceText || contentType === null\n            || contentType.startsWith('text')\n            || contentType === 'application/json') {\n            return response.text();\n        }\n        else {\n            return response.arrayBuffer();\n        }\n    });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\nfunction getFileSignedUnencrypted(path, opt, caller) {\n    // future optimization note:\n    //    in the case of _multi-player_ reads, this does a lot of excess\n    //    profile lookups to figure out where to read files\n    //    do browsers cache all these requests if Content-Cache is set?\n    return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller),\n        getFileContents(`${path}${SIGNATURE_FILE_SUFFIX}`, opt.app, opt.username, opt.zoneFileLookupURL, true, caller),\n        getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)])\n        .then(([fileContents, signatureContents, gaiaAddress]) => {\n        if (!fileContents) {\n            return fileContents;\n        }\n        if (!gaiaAddress) {\n            throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '\n                + `${path}`);\n        }\n        if (!signatureContents || typeof signatureContents !== 'string') {\n            throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: '\n                + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n        }\n        let signature;\n        let publicKey;\n        try {\n            const sigObject = JSON.parse(signatureContents);\n            signature = sigObject.signature;\n            publicKey = sigObject.publicKey;\n        }\n        catch (err) {\n            if (err instanceof SyntaxError) {\n                throw new Error('Failed to parse signature content JSON '\n                    + `(path: ${path}${SIGNATURE_FILE_SUFFIX})`\n                    + ' The content may be corrupted.');\n            }\n            else {\n                throw err;\n            }\n        }\n        const signerAddress = keys_1.publicKeyToAddress(publicKey);\n        if (gaiaAddress !== signerAddress) {\n            throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`\n                + ` match gaia address (${gaiaAddress})`);\n        }\n        else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n            throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: '\n                + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);\n        }\n        else {\n            return fileContents;\n        }\n    });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n    const appPrivateKey = caller.loadUserData().appPrivateKey;\n    const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n    let addressPromise;\n    if (username) {\n        addressPromise = getGaiaAddress(app, username, zoneFileLookupURL, caller);\n    }\n    else {\n        const address = keys_1.publicKeyToAddress(appPublicKey);\n        addressPromise = Promise.resolve(address);\n    }\n    return addressPromise.then((address) => {\n        if (!address) {\n            throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '\n                + `${path}`);\n        }\n        let sigObject;\n        try {\n            sigObject = JSON.parse(storedContents);\n        }\n        catch (err) {\n            if (err instanceof SyntaxError) {\n                throw new Error('Failed to parse encrypted, signed content JSON. The content may not '\n                    + 'be encrypted. If using getFile, try passing'\n                    + ' { verify: false, decrypt: false }.');\n            }\n            else {\n                throw err;\n            }\n        }\n        const signature = sigObject.signature;\n        const signerPublicKey = sigObject.publicKey;\n        const cipherText = sigObject.cipherText;\n        const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n        if (!signerPublicKey || !cipherText || !signature) {\n            throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:'\n                + ` ${path}`);\n        }\n        else if (signerAddress !== address) {\n            throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`\n                + ` match gaia address (${address})`);\n        }\n        else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n            throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:'\n                + ` ${path}`);\n        }\n        else {\n            return caller.decryptContent(cipherText);\n        }\n    });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\nfunction getFile(path, options, caller) {\n    const defaults = {\n        decrypt: true,\n        verify: false,\n        username: null,\n        app: utils_1.getGlobalObject('location', { returnEmptyObject: true }).origin,\n        zoneFileLookupURL: null\n    };\n    const opt = Object.assign({}, defaults, options);\n    if (!caller) {\n        caller = new userSession_1.UserSession();\n    }\n    // in the case of signature verification, but no\n    //  encryption expected, need to fetch _two_ files.\n    if (opt.verify && !opt.decrypt) {\n        return getFileSignedUnencrypted(path, opt, caller);\n    }\n    return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller)\n        .then((storedContents) => {\n        if (storedContents === null) {\n            return storedContents;\n        }\n        else if (opt.decrypt && !opt.verify) {\n            if (typeof storedContents !== 'string') {\n                throw new Error('Expected to get back a string for the cipherText');\n            }\n            return caller.decryptContent(storedContents);\n        }\n        else if (opt.decrypt && opt.verify) {\n            if (typeof storedContents !== 'string') {\n                throw new Error('Expected to get back a string for the cipherText');\n            }\n            return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n        }\n        else if (!opt.verify && !opt.decrypt) {\n            return storedContents;\n        }\n        else {\n            throw new Error('Should be unreachable.');\n        }\n    });\n}\nexports.getFile = getFile;\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\nfunction putFile(path, content, options, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const defaults = {\n            encrypt: true,\n            sign: false,\n            contentType: ''\n        };\n        const opt = Object.assign({}, defaults, options);\n        let { contentType } = opt;\n        if (!contentType) {\n            contentType = (typeof (content) === 'string') ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n        }\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        // First, let's figure out if we need to get public/private keys,\n        //  or if they were passed in\n        let privateKey = '';\n        let publicKey = '';\n        if (opt.sign) {\n            if (typeof (opt.sign) === 'string') {\n                privateKey = opt.sign;\n            }\n            else {\n                privateKey = caller.loadUserData().appPrivateKey;\n            }\n        }\n        if (opt.encrypt) {\n            if (typeof (opt.encrypt) === 'string') {\n                publicKey = opt.encrypt;\n            }\n            else {\n                if (!privateKey) {\n                    privateKey = caller.loadUserData().appPrivateKey;\n                }\n                publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n            }\n        }\n        // In the case of signing, but *not* encrypting,\n        //   we perform two uploads. So the control-flow\n        //   here will return there.\n        if (!opt.encrypt && opt.sign) {\n            const signatureObject = ec_1.signECDSA(privateKey, content);\n            const signatureContent = JSON.stringify(signatureObject);\n            const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n            try {\n                const fileUrls = yield Promise.all([\n                    hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType),\n                    hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, gaiaHubConfig, 'application/json')\n                ]);\n                return fileUrls[0];\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                const fileUrls = yield Promise.all([\n                    hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType),\n                    hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, freshHubConfig, 'application/json')\n                ]);\n                return fileUrls[0];\n            }\n        }\n        // In all other cases, we only need one upload.\n        if (opt.encrypt && !opt.sign) {\n            content = encryptContent(content, { publicKey });\n            contentType = 'application/json';\n        }\n        else if (opt.encrypt && opt.sign) {\n            const cipherText = encryptContent(content, { publicKey });\n            const signatureObject = ec_1.signECDSA(privateKey, cipherText);\n            const signedCipherObject = {\n                signature: signatureObject.signature,\n                publicKey: signatureObject.publicKey,\n                cipherText\n            };\n            content = JSON.stringify(signedCipherObject);\n            contentType = 'application/json';\n        }\n        const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n        try {\n            return yield hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType);\n        }\n        catch (error) {\n            const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n            const file = yield hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType);\n            return file;\n        }\n    });\n}\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\nfunction deleteFile(path, options, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n        const opts = Object.assign({}, options);\n        if (opts.wasSigned) {\n            // If signed, delete both the content file and the .sig file\n            try {\n                yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n                yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n                yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n            }\n        }\n        else {\n            try {\n                yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n            }\n        }\n    });\n}\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n    return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (callCount > 65536) {\n            // this is ridiculously huge, and probably indicates\n            // a faulty Gaia hub anyway (e.g. on that serves endless data)\n            throw new Error('Too many entries to list');\n        }\n        hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());\n        let response;\n        try {\n            const pageRequest = JSON.stringify({ page });\n            const fetchOptions = {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Content-Length': `${pageRequest.length}`,\n                    Authorization: `bearer ${hubConfig.token}`\n                },\n                body: pageRequest\n            };\n            response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);\n            if (!response.ok) {\n                throw new Error(`listFiles failed with HTTP status ${response.status}`);\n            }\n        }\n        catch (error) {\n            // If error occurs on the first call, perform a gaia re-connection and retry.\n            // Same logic as other gaia requests (putFile, getFile, etc).\n            if (callCount === 0) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);\n            }\n            throw error;\n        }\n        const responseText = yield response.text();\n        const responseJSON = JSON.parse(responseText);\n        const entries = responseJSON.entries;\n        const nextPage = responseJSON.page;\n        if (entries === null || entries === undefined) {\n            // indicates a misbehaving Gaia hub or a misbehaving driver\n            // (i.e. the data is malformed)\n            throw new Error('Bad listFiles response: no entries');\n        }\n        for (let i = 0; i < entries.length; i++) {\n            const rc = callback(entries[i]);\n            if (!rc) {\n                // callback indicates that we're done\n                return fileCount + i;\n            }\n        }\n        if (nextPage && entries.length > 0) {\n            // keep going -- have more entries\n            return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n        }\n        else {\n            // no more entries -- end of data\n            return fileCount + entries.length;\n        }\n    });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\nfunction listFiles(callback, caller) {\n    caller = caller || new userSession_1.UserSession();\n    return listFilesLoop(caller, null, null, 0, 0, callback);\n}\nexports.listFiles = listFiles;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}