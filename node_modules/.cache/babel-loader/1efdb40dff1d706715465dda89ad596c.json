{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst hub_1 = require(\"./hub\");\n\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL; // export { type GaiaHubConfig } from './hub'\n\nconst ec_1 = require(\"../encryption/ec\");\n\nconst keys_1 = require(\"../keys\");\n\nconst profileLookup_1 = require(\"../profiles/profileLookup\");\n\nconst errors_1 = require(\"../errors\");\n\nconst userSession_1 = require(\"../auth/userSession\");\n\nconst authConstants_1 = require(\"../auth/authConstants\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst etags = {};\nconst SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\n\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n    let bucketUrl = null;\n\n    if (profile.hasOwnProperty('apps')) {\n      if (profile.apps.hasOwnProperty(appOrigin)) {\n        const url = profile.apps[appOrigin];\n        const bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n        bucketUrl = `${bucket}${path}`;\n      }\n    }\n\n    return bucketUrl;\n  });\n}\n\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\n\nfunction encryptContent(content, options, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const opts = Object.assign({}, options);\n    let privateKey;\n\n    if (!opts.publicKey) {\n      privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n      opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n    }\n\n    let wasString;\n\n    if (typeof opts.wasString === 'boolean') {\n      wasString = opts.wasString;\n    } else {\n      wasString = typeof content === 'string';\n    }\n\n    const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n    const cipherObject = yield ec_1.encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n    let cipherPayload = JSON.stringify(cipherObject);\n\n    if (opts.sign) {\n      if (typeof opts.sign === 'string') {\n        privateKey = opts.sign;\n      } else if (!privateKey) {\n        privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n      }\n\n      const signatureObject = ec_1.signECDSA(privateKey, cipherPayload);\n      const signedCipherObject = {\n        signature: signatureObject.signature,\n        publicKey: signatureObject.publicKey,\n        cipherText: cipherPayload\n      };\n      cipherPayload = JSON.stringify(signedCipherObject);\n    }\n\n    return cipherPayload;\n  });\n}\n\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\n\nfunction decryptContent(content, options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return ec_1.decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\n\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const opts = normalizeOptions({\n      app,\n      username,\n      zoneFileLookupURL\n    }, caller);\n    let fileUrl;\n\n    if (username) {\n      fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, opts.zoneFileLookupURL);\n    } else {\n      if (!caller) {\n        caller = new userSession_1.UserSession();\n      }\n\n      const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n      fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);\n    }\n\n    const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n\n    if (!matches) {\n      throw new Error('Failed to parse gaia address');\n    }\n\n    return matches[matches.length - 1];\n  });\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\n\n\nfunction normalizeOptions(options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (opts.username) {\n    if (!opts.app) {\n      caller = caller || new userSession_1.UserSession();\n\n      if (!caller.appConfig) {\n        throw new errors_1.InvalidStateError('Missing AppConfig');\n      }\n\n      opts.app = caller.appConfig.appDomain;\n    }\n\n    if (!opts.zoneFileLookupURL) {\n      caller = caller || new userSession_1.UserSession();\n\n      if (!caller.appConfig) {\n        throw new errors_1.InvalidStateError('Missing AppConfig');\n      }\n\n      if (!caller.store) {\n        throw new errors_1.InvalidStateError('Missing store UserSession');\n      }\n\n      const sessionData = caller.store.getSessionData(); // Use the user specified coreNode if available, otherwise use the app specified coreNode. \n\n      const configuredCoreNode = sessionData.userData.coreNode || caller.appConfig.coreNode;\n\n      if (configuredCoreNode) {\n        opts.zoneFileLookupURL = `${configuredCoreNode}${authConstants_1.NAME_LOOKUP_PATH}`;\n      }\n    }\n  }\n\n  return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\n\n\nfunction getFileUrl(path, options, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const opts = normalizeOptions(options, caller);\n    let readUrl;\n\n    if (opts.username) {\n      readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n    } else {\n      const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n      readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);\n    }\n\n    if (!readUrl) {\n      throw new Error('Missing readURL');\n    } else {\n      return readUrl;\n    }\n  });\n}\n\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\n\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const opts = {\n      app,\n      username,\n      zoneFileLookupURL\n    };\n    const readUrl = yield getFileUrl(path, opts, caller);\n    const response = yield fetchUtil_1.fetchPrivate(readUrl);\n\n    if (!response.ok) {\n      throw yield utils_1.getBlockstackErrorFromResponse(response, `getFile ${path} failed.`, null);\n    }\n\n    let contentType = response.headers.get('Content-Type');\n\n    if (typeof contentType === 'string') {\n      contentType = contentType.toLowerCase();\n    }\n\n    const etag = response.headers.get('ETag');\n\n    if (etag) {\n      etags[path] = etag;\n    }\n\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType.startsWith('application/json')) {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\n\n\nfunction getFileSignedUnencrypted(path, opt, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    // future optimization note:\n    //    in the case of _multi-player_ reads, this does a lot of excess\n    //    profile lookups to figure out where to read files\n    //    do browsers cache all these requests if Content-Cache is set?\n    const sigPath = `${path}${SIGNATURE_FILE_SUFFIX}`;\n\n    try {\n      const [fileContents, signatureContents, gaiaAddress] = yield Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller), getFileContents(sigPath, opt.app, opt.username, opt.zoneFileLookupURL, true, caller), getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)]);\n\n      if (!fileContents) {\n        return fileContents;\n      }\n\n      if (!gaiaAddress) {\n        throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + `${path}`);\n      }\n\n      if (!signatureContents || typeof signatureContents !== 'string') {\n        throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: ' + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n      }\n\n      let signature;\n      let publicKey;\n\n      try {\n        const sigObject = JSON.parse(signatureContents);\n        signature = sigObject.signature;\n        publicKey = sigObject.publicKey;\n      } catch (err) {\n        if (err instanceof SyntaxError) {\n          throw new Error('Failed to parse signature content JSON ' + `(path: ${path}${SIGNATURE_FILE_SUFFIX})` + ' The content may be corrupted.');\n        } else {\n          throw err;\n        }\n      }\n\n      const signerAddress = keys_1.publicKeyToAddress(publicKey);\n\n      if (gaiaAddress !== signerAddress) {\n        throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${gaiaAddress})`);\n      } else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n        throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: ' + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);\n      } else {\n        return fileContents;\n      }\n    } catch (err) {\n      // For missing .sig files, throw `SignatureVerificationError` instead of `DoesNotExist` error.\n      if (err instanceof errors_1.DoesNotExist && err.message.indexOf(sigPath) >= 0) {\n        throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: ' + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n      } else {\n        throw err;\n      }\n    }\n  });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\n\n\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, privateKey, username, zoneFileLookupURL) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const appPrivateKey = privateKey || caller.loadUserData().appPrivateKey;\n    const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n    let address;\n\n    if (username) {\n      address = yield getGaiaAddress(app, username, zoneFileLookupURL, caller);\n    } else {\n      address = keys_1.publicKeyToAddress(appPublicKey);\n    }\n\n    if (!address) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + `${path}`);\n    }\n\n    let sigObject;\n\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n\n    const signature = sigObject.signature;\n    const signerPublicKey = sigObject.publicKey;\n    const cipherText = sigObject.cipherText;\n    const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:' + ` ${path}`);\n    } else if (signerAddress !== address) {\n      throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${address})`);\n    } else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:' + ` ${path}`);\n    } else if (typeof privateKey === 'string') {\n      const decryptOpt = {\n        privateKey\n      };\n      return caller.decryptContent(cipherText, decryptOpt);\n    } else {\n      return caller.decryptContent(cipherText);\n    }\n  });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\n\n\nfunction getFile(path, options, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const defaults = {\n      decrypt: true,\n      verify: false,\n      username: null,\n      app: utils_1.getGlobalObject('location', {\n        returnEmptyObject: true\n      }).origin,\n      zoneFileLookupURL: null\n    };\n    const opt = Object.assign({}, defaults, options);\n\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    } // in the case of signature verification, but no\n    //  encryption expected, need to fetch _two_ files.\n\n\n    if (opt.verify && !opt.decrypt) {\n      return getFileSignedUnencrypted(path, opt, caller);\n    }\n\n    const storedContents = yield getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller);\n\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      if (typeof opt.decrypt === 'string') {\n        const decryptOpt = {\n          privateKey: opt.decrypt\n        };\n        return caller.decryptContent(storedContents, decryptOpt);\n      } else {\n        return caller.decryptContent(storedContents);\n      }\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      let decryptionKey;\n\n      if (typeof opt.decrypt === 'string') {\n        decryptionKey = opt.decrypt;\n      }\n\n      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, decryptionKey, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n\nexports.getFile = getFile;\n/** @ignore */\n\nclass FileContentLoader {\n  constructor(content, contentType) {\n    this.wasString = typeof content === 'string';\n    this.content = FileContentLoader.normalizeContentDataType(content, contentType);\n    this.contentType = contentType || this.detectContentType();\n    this.contentByteLength = this.detectContentLength();\n  }\n\n  static normalizeContentDataType(content, contentType) {\n    try {\n      if (typeof content === 'string') {\n        // If a charset is specified it must be either utf8 or ascii, otherwise the encoded content \n        // length cannot be reliably detected. If no charset specified it will be treated as utf8. \n        const charset = (contentType || '').toLowerCase().replace('-', '');\n\n        if (charset.includes('charset') && !charset.includes('charset=utf8') && !charset.includes('charset=ascii')) {\n          throw new Error(`Unable to determine byte length with charset: ${contentType}`);\n        }\n\n        if (typeof TextEncoder !== 'undefined') {\n          const encodedString = new TextEncoder().encode(content);\n          return Buffer.from(encodedString.buffer);\n        }\n\n        return Buffer.from(content);\n      } else if (Buffer.isBuffer(content)) {\n        return content;\n      } else if (ArrayBuffer.isView(content)) {\n        return Buffer.from(content.buffer, content.byteOffset, content.byteLength);\n      } else if (typeof Blob !== 'undefined' && content instanceof Blob) {\n        return content;\n      } else if (typeof ArrayBuffer !== 'undefined' && content instanceof ArrayBuffer) {\n        return Buffer.from(content);\n      } else if (Array.isArray(content)) {\n        // Provided with a regular number `Array` -- this is either an (old) method \n        // of representing an octet array, or a dev error. Perform basic check for octet array. \n        if (content.length > 0 && (!Number.isInteger(content[0]) || content[0] < 0 || content[0] > 255)) {\n          throw new Error(`Unexpected array values provided as file data: value \"${content[0]}\" at index 0 is not an octet number. ${this.supportedTypesMsg}`);\n        }\n\n        return Buffer.from(content);\n      } else {\n        const typeName = Object.prototype.toString.call(content);\n        throw new Error(`Unexpected type provided as file data: ${typeName}. ${this.supportedTypesMsg}`);\n      }\n    } catch (error) {\n      console.error(error);\n      throw new Error(`Error processing data: ${error}`);\n    }\n  }\n\n  detectContentType() {\n    if (this.wasString) {\n      return 'text/plain; charset=utf-8';\n    } else if (typeof Blob !== 'undefined' && this.content instanceof Blob && this.content.type) {\n      return this.content.type;\n    } else {\n      return 'application/octet-stream';\n    }\n  }\n\n  detectContentLength() {\n    if (ArrayBuffer.isView(this.content) || Buffer.isBuffer(this.content)) {\n      return this.content.byteLength;\n    } else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {\n      return this.content.size;\n    }\n\n    const typeName = Object.prototype.toString.call(this.content);\n    const error = new Error(`Unexpected type \"${typeName}\" while detecting content length`);\n    console.error(error);\n    throw error;\n  }\n\n  loadContent() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        if (Buffer.isBuffer(this.content)) {\n          return this.content;\n        } else if (ArrayBuffer.isView(this.content)) {\n          return Buffer.from(this.content.buffer, this.content.byteOffset, this.content.byteLength);\n        } else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {\n          const reader = new FileReader();\n          const readPromise = new Promise((resolve, reject) => {\n            reader.onerror = err => {\n              reject(err);\n            };\n\n            reader.onload = () => {\n              const arrayBuffer = reader.result;\n              resolve(Buffer.from(arrayBuffer));\n            };\n\n            reader.readAsArrayBuffer(this.content);\n          });\n          const result = yield readPromise;\n          return result;\n        } else {\n          const typeName = Object.prototype.toString.call(this.content);\n          throw new Error(`Unexpected type ${typeName}`);\n        }\n      } catch (error) {\n        console.error(error);\n        const loadContentError = new Error(`Error loading content: ${error}`);\n        console.error(loadContentError);\n        throw loadContentError;\n      }\n    });\n  }\n\n  load() {\n    if (this.loadedData === undefined) {\n      this.loadedData = this.loadContent();\n    }\n\n    return this.loadedData;\n  }\n\n}\n\nFileContentLoader.supportedTypesMsg = 'Supported types are: `string` (to be UTF8 encoded), ' + '`Buffer`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. ';\n/**\n * Determines if a gaia error response is possible to recover from\n * by refreshing the gaiaHubConfig, and retrying the request.\n */\n\nfunction isRecoverableGaiaError(error) {\n  if (!error || !error.hubError || !error.hubError.statusCode) {\n    return false;\n  }\n\n  const statusCode = error.hubError.statusCode; // 401 Unauthorized: possible expired, but renewable auth token.\n\n  if (statusCode === 401) {\n    return true;\n  } // 409 Conflict: possible concurrent writes to a file.\n\n\n  if (statusCode === 409) {\n    return true;\n  } // 500s: possible server-side transient error\n\n\n  if (statusCode >= 500 && statusCode <= 599) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\n\n\nfunction putFile(path, content, options, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const defaults = {\n      encrypt: true,\n      sign: false,\n      cipherTextEncoding: 'hex'\n    };\n    const opt = Object.assign({}, defaults, options);\n\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    }\n\n    const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n    const maxUploadBytes = utils_1.megabytesToBytes(gaiaHubConfig.max_file_upload_size_megabytes);\n    const hasMaxUpload = maxUploadBytes > 0;\n    const contentLoader = new FileContentLoader(content, opt.contentType);\n    let contentType = contentLoader.contentType; // When not encrypting the content length can be checked immediately.\n\n    if (!opt.encrypt && hasMaxUpload && contentLoader.contentByteLength > maxUploadBytes) {\n      const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${contentLoader.contentByteLength} bytes`;\n      const sizeErr = new errors_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);\n      console.error(sizeErr);\n      throw sizeErr;\n    } // When encrypting, the content length must be calculated. Certain types like `Blob`s must\n    // be loaded into memory. \n\n\n    if (opt.encrypt && hasMaxUpload) {\n      const encryptedSize = ec_1.eciesGetJsonStringLength({\n        contentLength: contentLoader.contentByteLength,\n        wasString: contentLoader.wasString,\n        sign: !!opt.sign,\n        cipherTextEncoding: opt.cipherTextEncoding\n      });\n\n      if (encryptedSize > maxUploadBytes) {\n        const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${encryptedSize} bytes after encryption`;\n        const sizeErr = new errors_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);\n        console.error(sizeErr);\n        throw sizeErr;\n      }\n    }\n\n    let etag;\n    let newFile = true;\n\n    if (etags[path]) {\n      newFile = false;\n      etag = etags[path];\n    }\n\n    let uploadFn; // In the case of signing, but *not* encrypting, we perform two uploads.\n\n    if (!opt.encrypt && opt.sign) {\n      const contentData = yield contentLoader.load();\n      let privateKey;\n\n      if (typeof opt.sign === 'string') {\n        privateKey = opt.sign;\n      } else {\n        privateKey = caller.loadUserData().appPrivateKey;\n      }\n\n      const signatureObject = ec_1.signECDSA(privateKey, contentData);\n      const signatureContent = JSON.stringify(signatureObject);\n\n      uploadFn = hubConfig => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const writeResponse = (yield Promise.all([hub_1.uploadToGaiaHub(path, contentData, hubConfig, contentType, newFile, etag), hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, hubConfig, 'application/json')]))[0];\n\n        if (writeResponse.etag) {\n          etags[path] = writeResponse.etag;\n        }\n\n        return writeResponse.publicURL;\n      });\n    } else {\n      // In all other cases, we only need one upload.\n      let contentForUpload;\n\n      if (!opt.encrypt && !opt.sign) {\n        // If content does not need encrypted or signed, it can be passed directly \n        // to the fetch request without loading into memory. \n        contentForUpload = contentLoader.content;\n      } else {\n        // Use the `encrypt` key, otherwise the `sign` key, if neither are specified\n        // then use the current user's app public key. \n        let publicKey;\n\n        if (typeof opt.encrypt === 'string') {\n          publicKey = opt.encrypt;\n        } else if (typeof opt.sign === 'string') {\n          publicKey = keys_1.getPublicKeyFromPrivate(opt.sign);\n        } else {\n          publicKey = keys_1.getPublicKeyFromPrivate(caller.loadUserData().appPrivateKey);\n        }\n\n        const contentData = yield contentLoader.load();\n        contentForUpload = yield encryptContent(contentData, {\n          publicKey,\n          wasString: contentLoader.wasString,\n          cipherTextEncoding: opt.cipherTextEncoding,\n          sign: opt.sign\n        });\n        contentType = 'application/json';\n      }\n\n      uploadFn = hubConfig => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const writeResponse = yield hub_1.uploadToGaiaHub(path, contentForUpload, hubConfig, contentType, newFile, etag);\n\n        if (writeResponse.etag) {\n          etags[path] = writeResponse.etag;\n        }\n\n        return writeResponse.publicURL;\n      });\n    }\n\n    try {\n      return yield uploadFn(gaiaHubConfig);\n    } catch (error) {\n      // If the upload fails on first attempt, it could be due to a recoverable\n      // error which may succeed by refreshing the config and retrying.\n      if (isRecoverableGaiaError(error)) {\n        console.error(error);\n        console.error('Possible recoverable error during Gaia upload, retrying...');\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        return yield uploadFn(freshHubConfig);\n      } else {\n        throw error;\n      }\n    }\n  });\n}\n\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\n\nfunction deleteFile(path, options, caller) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    }\n\n    const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n    const opts = Object.assign({}, options);\n\n    if (opts.wasSigned) {\n      // If signed, delete both the content file and the .sig file\n      try {\n        yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n        yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n        yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n      }\n    } else {\n      try {\n        yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n      }\n    }\n  });\n}\n\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\n\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\n\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\n\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    if (callCount > 65536) {\n      // this is ridiculously huge, and probably indicates\n      // a faulty Gaia hub anyway (e.g. on that serves endless data)\n      throw new Error('Too many entries to list');\n    }\n\n    hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());\n    let response;\n\n    try {\n      const pageRequest = JSON.stringify({\n        page\n      });\n      const fetchOptions = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': `${pageRequest.length}`,\n          Authorization: `bearer ${hubConfig.token}`\n        },\n        body: pageRequest\n      };\n      response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);\n\n      if (!response.ok) {\n        throw yield utils_1.getBlockstackErrorFromResponse(response, 'ListFiles failed.', hubConfig);\n      }\n    } catch (error) {\n      // If error occurs on the first call, perform a gaia re-connection and retry.\n      // Same logic as other gaia requests (putFile, getFile, etc).\n      if (callCount === 0) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);\n      }\n\n      throw error;\n    }\n\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    const entries = responseJSON.entries;\n    const nextPage = responseJSON.page;\n\n    if (entries === null || entries === undefined) {\n      // indicates a misbehaving Gaia hub or a misbehaving driver\n      // (i.e. the data is malformed)\n      throw new Error('Bad listFiles response: no entries');\n    }\n\n    let entriesLength = 0;\n\n    for (let i = 0; i < entries.length; i++) {\n      // An entry array can have null entries, signifying a filtered entry and that there may be\n      // additional pages\n      if (entries[i] !== null) {\n        entriesLength++;\n        const rc = callback(entries[i]);\n\n        if (!rc) {\n          // callback indicates that we're done\n          return fileCount + i;\n        }\n      }\n    }\n\n    if (nextPage && entries.length > 0) {\n      // keep going -- have more entries\n      return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entriesLength, callback);\n    } else {\n      // no more entries -- end of data\n      return fileCount + entriesLength;\n    }\n  });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the total number of listed files.\n * If the call is ended early by the callback, the last file is excluded.\n * If an error occurs the entire call is rejected.\n */\n\n\nfunction listFiles(callback, caller) {\n  caller = caller || new userSession_1.UserSession();\n  return listFilesLoop(caller, null, null, 0, 0, callback);\n}\n\nexports.listFiles = listFiles;","map":{"version":3,"sources":["../../src/storage/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst hub_1 = require(\"./hub\");\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL;\n// export { type GaiaHubConfig } from './hub'\nconst ec_1 = require(\"../encryption/ec\");\nconst keys_1 = require(\"../keys\");\nconst profileLookup_1 = require(\"../profiles/profileLookup\");\nconst errors_1 = require(\"../errors\");\nconst userSession_1 = require(\"../auth/userSession\");\nconst authConstants_1 = require(\"../auth/authConstants\");\nconst utils_1 = require(\"../utils\");\nconst fetchUtil_1 = require(\"../fetchUtil\");\nconst etags = {};\nconst SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n        let bucketUrl = null;\n        if (profile.hasOwnProperty('apps')) {\n            if (profile.apps.hasOwnProperty(appOrigin)) {\n                const url = profile.apps[appOrigin];\n                const bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n                bucketUrl = `${bucket}${path}`;\n            }\n        }\n        return bucketUrl;\n    });\n}\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nfunction encryptContent(content, options, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const opts = Object.assign({}, options);\n        let privateKey;\n        if (!opts.publicKey) {\n            privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n            opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n        }\n        let wasString;\n        if (typeof opts.wasString === 'boolean') {\n            wasString = opts.wasString;\n        }\n        else {\n            wasString = typeof content === 'string';\n        }\n        const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n        const cipherObject = yield ec_1.encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n        let cipherPayload = JSON.stringify(cipherObject);\n        if (opts.sign) {\n            if (typeof opts.sign === 'string') {\n                privateKey = opts.sign;\n            }\n            else if (!privateKey) {\n                privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n            }\n            const signatureObject = ec_1.signECDSA(privateKey, cipherPayload);\n            const signedCipherObject = {\n                signature: signatureObject.signature,\n                publicKey: signatureObject.publicKey,\n                cipherText: cipherPayload\n            };\n            cipherPayload = JSON.stringify(signedCipherObject);\n        }\n        return cipherPayload;\n    });\n}\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nfunction decryptContent(content, options, caller) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n        opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    }\n    try {\n        const cipherObject = JSON.parse(content);\n        return ec_1.decryptECIES(opts.privateKey, cipherObject);\n    }\n    catch (err) {\n        if (err instanceof SyntaxError) {\n            throw new Error('Failed to parse encrypted content JSON. The content may not '\n                + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n        }\n        else {\n            throw err;\n        }\n    }\n}\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const opts = normalizeOptions({ app, username, zoneFileLookupURL }, caller);\n        let fileUrl;\n        if (username) {\n            fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, opts.zoneFileLookupURL);\n        }\n        else {\n            if (!caller) {\n                caller = new userSession_1.UserSession();\n            }\n            const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n            fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);\n        }\n        const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n        if (!matches) {\n            throw new Error('Failed to parse gaia address');\n        }\n        return matches[matches.length - 1];\n    });\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\nfunction normalizeOptions(options, caller) {\n    const opts = Object.assign({}, options);\n    if (opts.username) {\n        if (!opts.app) {\n            caller = caller || new userSession_1.UserSession();\n            if (!caller.appConfig) {\n                throw new errors_1.InvalidStateError('Missing AppConfig');\n            }\n            opts.app = caller.appConfig.appDomain;\n        }\n        if (!opts.zoneFileLookupURL) {\n            caller = caller || new userSession_1.UserSession();\n            if (!caller.appConfig) {\n                throw new errors_1.InvalidStateError('Missing AppConfig');\n            }\n            if (!caller.store) {\n                throw new errors_1.InvalidStateError('Missing store UserSession');\n            }\n            const sessionData = caller.store.getSessionData();\n            // Use the user specified coreNode if available, otherwise use the app specified coreNode. \n            const configuredCoreNode = sessionData.userData.coreNode || caller.appConfig.coreNode;\n            if (configuredCoreNode) {\n                opts.zoneFileLookupURL = `${configuredCoreNode}${authConstants_1.NAME_LOOKUP_PATH}`;\n            }\n        }\n    }\n    return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\nfunction getFileUrl(path, options, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const opts = normalizeOptions(options, caller);\n        let readUrl;\n        if (opts.username) {\n            readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n        }\n        else {\n            const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n            readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);\n        }\n        if (!readUrl) {\n            throw new Error('Missing readURL');\n        }\n        else {\n            return readUrl;\n        }\n    });\n}\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const opts = { app, username, zoneFileLookupURL };\n        const readUrl = yield getFileUrl(path, opts, caller);\n        const response = yield fetchUtil_1.fetchPrivate(readUrl);\n        if (!response.ok) {\n            throw yield utils_1.getBlockstackErrorFromResponse(response, `getFile ${path} failed.`, null);\n        }\n        let contentType = response.headers.get('Content-Type');\n        if (typeof contentType === 'string') {\n            contentType = contentType.toLowerCase();\n        }\n        const etag = response.headers.get('ETag');\n        if (etag) {\n            etags[path] = etag;\n        }\n        if (forceText || contentType === null\n            || contentType.startsWith('text')\n            || contentType.startsWith('application/json')) {\n            return response.text();\n        }\n        else {\n            return response.arrayBuffer();\n        }\n    });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\nfunction getFileSignedUnencrypted(path, opt, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        // future optimization note:\n        //    in the case of _multi-player_ reads, this does a lot of excess\n        //    profile lookups to figure out where to read files\n        //    do browsers cache all these requests if Content-Cache is set?\n        const sigPath = `${path}${SIGNATURE_FILE_SUFFIX}`;\n        try {\n            const [fileContents, signatureContents, gaiaAddress] = yield Promise.all([\n                getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller),\n                getFileContents(sigPath, opt.app, opt.username, opt.zoneFileLookupURL, true, caller),\n                getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)\n            ]);\n            if (!fileContents) {\n                return fileContents;\n            }\n            if (!gaiaAddress) {\n                throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '\n                    + `${path}`);\n            }\n            if (!signatureContents || typeof signatureContents !== 'string') {\n                throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: '\n                    + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n            }\n            let signature;\n            let publicKey;\n            try {\n                const sigObject = JSON.parse(signatureContents);\n                signature = sigObject.signature;\n                publicKey = sigObject.publicKey;\n            }\n            catch (err) {\n                if (err instanceof SyntaxError) {\n                    throw new Error('Failed to parse signature content JSON '\n                        + `(path: ${path}${SIGNATURE_FILE_SUFFIX})`\n                        + ' The content may be corrupted.');\n                }\n                else {\n                    throw err;\n                }\n            }\n            const signerAddress = keys_1.publicKeyToAddress(publicKey);\n            if (gaiaAddress !== signerAddress) {\n                throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`\n                    + ` match gaia address (${gaiaAddress})`);\n            }\n            else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n                throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: '\n                    + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);\n            }\n            else {\n                return fileContents;\n            }\n        }\n        catch (err) {\n            // For missing .sig files, throw `SignatureVerificationError` instead of `DoesNotExist` error.\n            if (err instanceof errors_1.DoesNotExist && err.message.indexOf(sigPath) >= 0) {\n                throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: '\n                    + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);\n            }\n            else {\n                throw err;\n            }\n        }\n    });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, privateKey, username, zoneFileLookupURL) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const appPrivateKey = privateKey || caller.loadUserData().appPrivateKey;\n        const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n        let address;\n        if (username) {\n            address = yield getGaiaAddress(app, username, zoneFileLookupURL, caller);\n        }\n        else {\n            address = keys_1.publicKeyToAddress(appPublicKey);\n        }\n        if (!address) {\n            throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '\n                + `${path}`);\n        }\n        let sigObject;\n        try {\n            sigObject = JSON.parse(storedContents);\n        }\n        catch (err) {\n            if (err instanceof SyntaxError) {\n                throw new Error('Failed to parse encrypted, signed content JSON. The content may not '\n                    + 'be encrypted. If using getFile, try passing'\n                    + ' { verify: false, decrypt: false }.');\n            }\n            else {\n                throw err;\n            }\n        }\n        const signature = sigObject.signature;\n        const signerPublicKey = sigObject.publicKey;\n        const cipherText = sigObject.cipherText;\n        const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n        if (!signerPublicKey || !cipherText || !signature) {\n            throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:'\n                + ` ${path}`);\n        }\n        else if (signerAddress !== address) {\n            throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`\n                + ` match gaia address (${address})`);\n        }\n        else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n            throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:'\n                + ` ${path}`);\n        }\n        else if (typeof (privateKey) === 'string') {\n            const decryptOpt = { privateKey };\n            return caller.decryptContent(cipherText, decryptOpt);\n        }\n        else {\n            return caller.decryptContent(cipherText);\n        }\n    });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\nfunction getFile(path, options, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const defaults = {\n            decrypt: true,\n            verify: false,\n            username: null,\n            app: utils_1.getGlobalObject('location', { returnEmptyObject: true }).origin,\n            zoneFileLookupURL: null\n        };\n        const opt = Object.assign({}, defaults, options);\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        // in the case of signature verification, but no\n        //  encryption expected, need to fetch _two_ files.\n        if (opt.verify && !opt.decrypt) {\n            return getFileSignedUnencrypted(path, opt, caller);\n        }\n        const storedContents = yield getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller);\n        if (storedContents === null) {\n            return storedContents;\n        }\n        else if (opt.decrypt && !opt.verify) {\n            if (typeof storedContents !== 'string') {\n                throw new Error('Expected to get back a string for the cipherText');\n            }\n            if (typeof (opt.decrypt) === 'string') {\n                const decryptOpt = { privateKey: opt.decrypt };\n                return caller.decryptContent(storedContents, decryptOpt);\n            }\n            else {\n                return caller.decryptContent(storedContents);\n            }\n        }\n        else if (opt.decrypt && opt.verify) {\n            if (typeof storedContents !== 'string') {\n                throw new Error('Expected to get back a string for the cipherText');\n            }\n            let decryptionKey;\n            if (typeof (opt.decrypt) === 'string') {\n                decryptionKey = opt.decrypt;\n            }\n            return handleSignedEncryptedContents(caller, path, storedContents, opt.app, decryptionKey, opt.username, opt.zoneFileLookupURL);\n        }\n        else if (!opt.verify && !opt.decrypt) {\n            return storedContents;\n        }\n        else {\n            throw new Error('Should be unreachable.');\n        }\n    });\n}\nexports.getFile = getFile;\n/** @ignore */\nclass FileContentLoader {\n    constructor(content, contentType) {\n        this.wasString = typeof content === 'string';\n        this.content = FileContentLoader.normalizeContentDataType(content, contentType);\n        this.contentType = contentType || this.detectContentType();\n        this.contentByteLength = this.detectContentLength();\n    }\n    static normalizeContentDataType(content, contentType) {\n        try {\n            if (typeof content === 'string') {\n                // If a charset is specified it must be either utf8 or ascii, otherwise the encoded content \n                // length cannot be reliably detected. If no charset specified it will be treated as utf8. \n                const charset = (contentType || '').toLowerCase().replace('-', '');\n                if (charset.includes('charset') && !charset.includes('charset=utf8') && !charset.includes('charset=ascii')) {\n                    throw new Error(`Unable to determine byte length with charset: ${contentType}`);\n                }\n                if (typeof TextEncoder !== 'undefined') {\n                    const encodedString = new TextEncoder().encode(content);\n                    return Buffer.from(encodedString.buffer);\n                }\n                return Buffer.from(content);\n            }\n            else if (Buffer.isBuffer(content)) {\n                return content;\n            }\n            else if (ArrayBuffer.isView(content)) {\n                return Buffer.from(content.buffer, content.byteOffset, content.byteLength);\n            }\n            else if (typeof Blob !== 'undefined' && content instanceof Blob) {\n                return content;\n            }\n            else if (typeof ArrayBuffer !== 'undefined' && content instanceof ArrayBuffer) {\n                return Buffer.from(content);\n            }\n            else if (Array.isArray(content)) {\n                // Provided with a regular number `Array` -- this is either an (old) method \n                // of representing an octet array, or a dev error. Perform basic check for octet array. \n                if (content.length > 0\n                    && (!Number.isInteger(content[0]) || content[0] < 0 || content[0] > 255)) {\n                    throw new Error(`Unexpected array values provided as file data: value \"${content[0]}\" at index 0 is not an octet number. ${this.supportedTypesMsg}`);\n                }\n                return Buffer.from(content);\n            }\n            else {\n                const typeName = Object.prototype.toString.call(content);\n                throw new Error(`Unexpected type provided as file data: ${typeName}. ${this.supportedTypesMsg}`);\n            }\n        }\n        catch (error) {\n            console.error(error);\n            throw new Error(`Error processing data: ${error}`);\n        }\n    }\n    detectContentType() {\n        if (this.wasString) {\n            return 'text/plain; charset=utf-8';\n        }\n        else if (typeof Blob !== 'undefined' && this.content instanceof Blob && this.content.type) {\n            return this.content.type;\n        }\n        else {\n            return 'application/octet-stream';\n        }\n    }\n    detectContentLength() {\n        if (ArrayBuffer.isView(this.content) || Buffer.isBuffer(this.content)) {\n            return this.content.byteLength;\n        }\n        else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {\n            return this.content.size;\n        }\n        const typeName = Object.prototype.toString.call(this.content);\n        const error = new Error(`Unexpected type \"${typeName}\" while detecting content length`);\n        console.error(error);\n        throw error;\n    }\n    loadContent() {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            try {\n                if (Buffer.isBuffer(this.content)) {\n                    return this.content;\n                }\n                else if (ArrayBuffer.isView(this.content)) {\n                    return Buffer.from(this.content.buffer, this.content.byteOffset, this.content.byteLength);\n                }\n                else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {\n                    const reader = new FileReader();\n                    const readPromise = new Promise((resolve, reject) => {\n                        reader.onerror = (err) => {\n                            reject(err);\n                        };\n                        reader.onload = () => {\n                            const arrayBuffer = reader.result;\n                            resolve(Buffer.from(arrayBuffer));\n                        };\n                        reader.readAsArrayBuffer(this.content);\n                    });\n                    const result = yield readPromise;\n                    return result;\n                }\n                else {\n                    const typeName = Object.prototype.toString.call(this.content);\n                    throw new Error(`Unexpected type ${typeName}`);\n                }\n            }\n            catch (error) {\n                console.error(error);\n                const loadContentError = new Error(`Error loading content: ${error}`);\n                console.error(loadContentError);\n                throw loadContentError;\n            }\n        });\n    }\n    load() {\n        if (this.loadedData === undefined) {\n            this.loadedData = this.loadContent();\n        }\n        return this.loadedData;\n    }\n}\nFileContentLoader.supportedTypesMsg = 'Supported types are: `string` (to be UTF8 encoded), '\n    + '`Buffer`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. ';\n/**\n * Determines if a gaia error response is possible to recover from\n * by refreshing the gaiaHubConfig, and retrying the request.\n */\nfunction isRecoverableGaiaError(error) {\n    if (!error || !error.hubError || !error.hubError.statusCode) {\n        return false;\n    }\n    const statusCode = error.hubError.statusCode;\n    // 401 Unauthorized: possible expired, but renewable auth token.\n    if (statusCode === 401) {\n        return true;\n    }\n    // 409 Conflict: possible concurrent writes to a file.\n    if (statusCode === 409) {\n        return true;\n    }\n    // 500s: possible server-side transient error\n    if (statusCode >= 500 && statusCode <= 599) {\n        return true;\n    }\n    return false;\n}\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\nfunction putFile(path, content, options, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        const defaults = {\n            encrypt: true,\n            sign: false,\n            cipherTextEncoding: 'hex'\n        };\n        const opt = Object.assign({}, defaults, options);\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n        const maxUploadBytes = utils_1.megabytesToBytes(gaiaHubConfig.max_file_upload_size_megabytes);\n        const hasMaxUpload = maxUploadBytes > 0;\n        const contentLoader = new FileContentLoader(content, opt.contentType);\n        let contentType = contentLoader.contentType;\n        // When not encrypting the content length can be checked immediately.\n        if (!opt.encrypt && hasMaxUpload && contentLoader.contentByteLength > maxUploadBytes) {\n            const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${contentLoader.contentByteLength} bytes`;\n            const sizeErr = new errors_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);\n            console.error(sizeErr);\n            throw sizeErr;\n        }\n        // When encrypting, the content length must be calculated. Certain types like `Blob`s must\n        // be loaded into memory. \n        if (opt.encrypt && hasMaxUpload) {\n            const encryptedSize = ec_1.eciesGetJsonStringLength({\n                contentLength: contentLoader.contentByteLength,\n                wasString: contentLoader.wasString,\n                sign: !!opt.sign,\n                cipherTextEncoding: opt.cipherTextEncoding\n            });\n            if (encryptedSize > maxUploadBytes) {\n                const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${encryptedSize} bytes after encryption`;\n                const sizeErr = new errors_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);\n                console.error(sizeErr);\n                throw sizeErr;\n            }\n        }\n        let etag;\n        let newFile = true;\n        if (etags[path]) {\n            newFile = false;\n            etag = etags[path];\n        }\n        let uploadFn;\n        // In the case of signing, but *not* encrypting, we perform two uploads.\n        if (!opt.encrypt && opt.sign) {\n            const contentData = yield contentLoader.load();\n            let privateKey;\n            if (typeof opt.sign === 'string') {\n                privateKey = opt.sign;\n            }\n            else {\n                privateKey = caller.loadUserData().appPrivateKey;\n            }\n            const signatureObject = ec_1.signECDSA(privateKey, contentData);\n            const signatureContent = JSON.stringify(signatureObject);\n            uploadFn = (hubConfig) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                const writeResponse = (yield Promise.all([\n                    hub_1.uploadToGaiaHub(path, contentData, hubConfig, contentType, newFile, etag),\n                    hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, hubConfig, 'application/json')\n                ]))[0];\n                if (writeResponse.etag) {\n                    etags[path] = writeResponse.etag;\n                }\n                return writeResponse.publicURL;\n            });\n        }\n        else {\n            // In all other cases, we only need one upload.\n            let contentForUpload;\n            if (!opt.encrypt && !opt.sign) {\n                // If content does not need encrypted or signed, it can be passed directly \n                // to the fetch request without loading into memory. \n                contentForUpload = contentLoader.content;\n            }\n            else {\n                // Use the `encrypt` key, otherwise the `sign` key, if neither are specified\n                // then use the current user's app public key. \n                let publicKey;\n                if (typeof opt.encrypt === 'string') {\n                    publicKey = opt.encrypt;\n                }\n                else if (typeof opt.sign === 'string') {\n                    publicKey = keys_1.getPublicKeyFromPrivate(opt.sign);\n                }\n                else {\n                    publicKey = keys_1.getPublicKeyFromPrivate(caller.loadUserData().appPrivateKey);\n                }\n                const contentData = yield contentLoader.load();\n                contentForUpload = yield encryptContent(contentData, {\n                    publicKey,\n                    wasString: contentLoader.wasString,\n                    cipherTextEncoding: opt.cipherTextEncoding,\n                    sign: opt.sign\n                });\n                contentType = 'application/json';\n            }\n            uploadFn = (hubConfig) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                const writeResponse = yield hub_1.uploadToGaiaHub(path, contentForUpload, hubConfig, contentType, newFile, etag);\n                if (writeResponse.etag) {\n                    etags[path] = writeResponse.etag;\n                }\n                return writeResponse.publicURL;\n            });\n        }\n        try {\n            return yield uploadFn(gaiaHubConfig);\n        }\n        catch (error) {\n            // If the upload fails on first attempt, it could be due to a recoverable\n            // error which may succeed by refreshing the config and retrying.\n            if (isRecoverableGaiaError(error)) {\n                console.error(error);\n                console.error('Possible recoverable error during Gaia upload, retrying...');\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                return yield uploadFn(freshHubConfig);\n            }\n            else {\n                throw error;\n            }\n        }\n    });\n}\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\nfunction deleteFile(path, options, caller) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        if (!caller) {\n            caller = new userSession_1.UserSession();\n        }\n        const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n        const opts = Object.assign({}, options);\n        if (opts.wasSigned) {\n            // If signed, delete both the content file and the .sig file\n            try {\n                yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n                yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n                yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);\n            }\n        }\n        else {\n            try {\n                yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n            }\n            catch (error) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n            }\n        }\n    });\n}\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n    return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        if (callCount > 65536) {\n            // this is ridiculously huge, and probably indicates\n            // a faulty Gaia hub anyway (e.g. on that serves endless data)\n            throw new Error('Too many entries to list');\n        }\n        hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());\n        let response;\n        try {\n            const pageRequest = JSON.stringify({ page });\n            const fetchOptions = {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Content-Length': `${pageRequest.length}`,\n                    Authorization: `bearer ${hubConfig.token}`\n                },\n                body: pageRequest\n            };\n            response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);\n            if (!response.ok) {\n                throw yield utils_1.getBlockstackErrorFromResponse(response, 'ListFiles failed.', hubConfig);\n            }\n        }\n        catch (error) {\n            // If error occurs on the first call, perform a gaia re-connection and retry.\n            // Same logic as other gaia requests (putFile, getFile, etc).\n            if (callCount === 0) {\n                const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n                return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);\n            }\n            throw error;\n        }\n        const responseText = yield response.text();\n        const responseJSON = JSON.parse(responseText);\n        const entries = responseJSON.entries;\n        const nextPage = responseJSON.page;\n        if (entries === null || entries === undefined) {\n            // indicates a misbehaving Gaia hub or a misbehaving driver\n            // (i.e. the data is malformed)\n            throw new Error('Bad listFiles response: no entries');\n        }\n        let entriesLength = 0;\n        for (let i = 0; i < entries.length; i++) {\n            // An entry array can have null entries, signifying a filtered entry and that there may be\n            // additional pages\n            if (entries[i] !== null) {\n                entriesLength++;\n                const rc = callback(entries[i]);\n                if (!rc) {\n                    // callback indicates that we're done\n                    return fileCount + i;\n                }\n            }\n        }\n        if (nextPage && entries.length > 0) {\n            // keep going -- have more entries\n            return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entriesLength, callback);\n        }\n        else {\n            // no more entries -- end of data\n            return fileCount + entriesLength;\n        }\n    });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the total number of listed files.\n * If the call is ended early by the callback, the last file is excluded.\n * If an error occurs the entire call is rejected.\n */\nfunction listFiles(callback, caller) {\n    caller = caller || new userSession_1.UserSession();\n    return listFilesLoop(caller, null, null, 0, 0, callback);\n}\nexports.listFiles = listFiles;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}